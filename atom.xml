<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abner</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-07T06:35:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Abnerzhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小试Ansible Python API</title>
    <link href="http://yoursite.com/2016/11/04/ansible-python-api/"/>
    <id>http://yoursite.com/2016/11/04/ansible-python-api/</id>
    <published>2016-11-04T10:49:12.000Z</published>
    <updated>2016-11-07T06:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ping 模块</div><div class="line">$ ansible localhost -m ping</div><div class="line">localhost | success &gt;&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line">// shell 模块</div><div class="line">$ ansible localhost -m shell -a &apos;uptime&apos;</div><div class="line">localhost | success | rc=0 &gt;&gt;</div><div class="line">11:00:11 up 66 days, 23:34,  1 user,  load average: 0.00, 0.01, 0.05</div></pre></td></tr></table></figure>
<h3 id="Python-API"><a href="#Python-API" class="headerlink" title="Python API"></a>Python API</h3><p>通过ansible.runner模块来实现</p>
<a id="more"></a>
<h4 id="使用API实现ping模块功能："><a href="#使用API实现ping模块功能：" class="headerlink" title="使用API实现ping模块功能："></a>使用API实现ping模块功能：</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">runner = ansible.runner.Runner(</div><div class="line">    module_name=<span class="string">'ping'</span>,  //模块名</div><div class="line">    module_args=<span class="string">''</span>,  //模块参数</div><div class="line">    pattern=<span class="string">'localhost'</span>,  //匹配主机或主机组</div><div class="line">    forks=<span class="number">2</span> //多线程</div><div class="line">)</div><div class="line">data = runner.run()</div><div class="line"><span class="keyword">print</span> data  //打印输出结果默认json格式</div><div class="line"></div><div class="line">//stdout</div><div class="line">&#123;<span class="string">'dark'</span>: &#123;&#125;, <span class="string">'contacted'</span>: &#123;<span class="string">'localhost'</span>: &#123;<span class="string">'invocation'</span>: &#123;<span class="string">'module_name'</span>: <span class="string">'ping'</span>, <span class="string">'module_args'</span>: <span class="string">''</span>&#125;, <span class="string">u'changed'</span>: <span class="keyword">False</span>, <span class="string">u'ping'</span>: <span class="string">u'pong'</span>&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<p>由于输出结果默认是json格式，那么我们可以格式化一下，让它更美观</p>
<blockquote>
<p>sort_keys  <code>按key排序</code><br>indent <code>缩进</code><br>separators <code>指定分隔符(默认分隔符&#39;, &#39;,使用&#39;,&#39;,&#39;: &#39; 避免尾部空格)</code></p>
</blockquote>
<p>上例中的输出格式化：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">print</span> json.dumps(data, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>)) //对json格式化输出</div><div class="line">//stdout</div><div class="line">&#123;</div><div class="line">    <span class="string">"contacted"</span>: &#123;</div><div class="line">        <span class="string">"localhost"</span>: &#123;</div><div class="line">            <span class="string">"changed"</span>: false,</div><div class="line">            <span class="string">"invocation"</span>: &#123;</div><div class="line">                <span class="string">"module_args"</span>: <span class="string">""</span>,</div><div class="line">                <span class="string">"module_name"</span>: <span class="string">"ping"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"ping"</span>: <span class="string">"pong"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"dark"</span>: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用API实现shell模块功能"><a href="#使用API实现shell模块功能" class="headerlink" title="使用API实现shell模块功能"></a>使用API实现shell模块功能</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">runner = ansible.runner.Runner(</div><div class="line">   module_name=<span class="string">'shell'</span>,</div><div class="line">   module_args=<span class="string">'uptime'</span>,</div><div class="line">   pattern=<span class="string">'localhost'</span>,</div><div class="line">   forks=<span class="number">2</span></div><div class="line">)</div><div class="line">data = runner.run()</div><div class="line"><span class="keyword">print</span> json.dumps(data, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</div><div class="line"></div><div class="line">//stdout</div><div class="line">&#123;</div><div class="line">    <span class="string">"contacted"</span>: &#123;</div><div class="line">        <span class="string">"localhost"</span>: &#123;</div><div class="line">            <span class="string">"changed"</span>: true,</div><div class="line">            <span class="string">"cmd"</span>: <span class="string">"uptime"</span>,</div><div class="line">            <span class="string">"delta"</span>: <span class="string">"0:00:00.002573"</span>,</div><div class="line">            <span class="string">"end"</span>: <span class="string">"2016-11-04 14:57:26.549208"</span>,</div><div class="line">            <span class="string">"invocation"</span>: &#123;</div><div class="line">                <span class="string">"module_args"</span>: <span class="string">"uptime"</span>,</div><div class="line">                <span class="string">"module_name"</span>: <span class="string">"shell"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"rc"</span>: <span class="number">0</span>,</div><div class="line">            <span class="string">"start"</span>: <span class="string">"2016-11-04 14:57:26.546635"</span>,</div><div class="line">            <span class="string">"stderr"</span>: <span class="string">""</span>,</div><div class="line">            <span class="string">"stdout"</span>: <span class="string">" 14:57:26 up 67 days,  3:31,  1 user,  load average: 0.00, 0.06, 0.07"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"dark"</span>: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="打印stdout"><a href="#打印stdout" class="headerlink" title="打印stdout"></a>打印stdout</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(contacted)</span>:</span></div><div class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> contacted.items():</div><div class="line">        <span class="keyword">if</span> k == <span class="string">'stdout'</span>:</div><div class="line">            <span class="keyword">print</span> v</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping_module</span><span class="params">()</span>:</span></div><div class="line">    runner = ansible.runner.Runner(</div><div class="line">        module_name=<span class="string">'ping'</span>,</div><div class="line">        module_args=<span class="string">''</span>,</div><div class="line">        pattern=<span class="string">'localhost'</span>,</div><div class="line">        forks=<span class="number">2</span></div><div class="line">        )</div><div class="line">    data = runner.run()</div><div class="line">    <span class="keyword">print</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_module</span><span class="params">()</span>:</span></div><div class="line">    runner = ansible.runner.Runner(</div><div class="line">        module_name=<span class="string">'shell'</span>,</div><div class="line">        module_args=<span class="string">'uptime'</span>,</div><div class="line">        pattern=<span class="string">'localhost'</span>,</div><div class="line">        forks=<span class="number">2</span></div><div class="line">        )</div><div class="line">    data = runner.run()</div><div class="line">    result(data[<span class="string">'contacted'</span>][<span class="string">'localhost'</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    shell_module()</div><div class="line">    </div><div class="line">//stdout</div><div class="line"><span class="number">15</span>:<span class="number">34</span>:<span class="number">09</span> up <span class="number">67</span> days,  <span class="number">4</span>:<span class="number">07</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></div></pre></td></tr></table></figure>
<h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>playbook描述了在远程主机上执行的策略或一组任务</p>
<p>一个playbook文件由一个或多个play组成，每个play定义了一系列的task，每个task通过ansible的模块来实现特定的功能</p>
<p>exp.yml (<code>playbook使用YAML语言编写，文件名以.yaml或.yml结尾</code>)</p>
<pre><code>- hosts: localhost_group   //主机组
   tasks:
    - name: kernel release info  //task1
      command: uname -a

    - name: memory info  //task2
      shell: free -m
</code></pre><p>这个playbook可以查看远程主机的内核版本信息和内存信息</p>
<h3 id="ansible-playbook命令"><a href="#ansible-playbook命令" class="headerlink" title="ansible-playbook命令"></a>ansible-playbook命令</h3><p>命令行执行playbook</p>
<pre><code>$ ansible-playbook  -i /etc/ansible/hosts  test.yml

PLAY [localhost_group] ********************************************************

GATHERING FACTS ***************************************************************
ok: [localhost]

TASK: [kernel info] ***********************************************************
changed: [localhost]

TASK: [memory info] ***********************************************************
changed: [localhost]

PLAY RECAP ********************************************************************
localhost                  : ok=3    changed=2    unreachable=0    failed=0
</code></pre><h3 id="Python-API-1"><a href="#Python-API-1" class="headerlink" title="Python API"></a>Python API</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># encoding=utf8</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"><span class="keyword">import</span> ansible.playbook</div><div class="line"><span class="keyword">import</span> ansible.inventory</div><div class="line"><span class="keyword">from</span> ansible <span class="keyword">import</span> callbacks</div><div class="line"><span class="keyword">from</span> ansible <span class="keyword">import</span> utils</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">playbook_path = <span class="string">"/home/ubuntu/scripts/exp.yml"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##添加主机信息</span></div><div class="line">host = ansible.inventory.host.Host(</div><div class="line">    name = <span class="string">'localhost'</span></div><div class="line">    )</div><div class="line"></div><div class="line"><span class="comment">##设置主机组并添加主机</span></div><div class="line">group = ansible.inventory.group.Group(</div><div class="line">    name = <span class="string">'localhost_group'</span></div><div class="line">    )</div><div class="line">group.add_host(host)</div><div class="line"></div><div class="line"><span class="comment">##主机列表</span></div><div class="line">example_inventory = ansible.inventory.Inventory()</div><div class="line">example_inventory.add_group(group)</div><div class="line"></div><div class="line"><span class="comment">#回调信息</span></div><div class="line">stats = callbacks.AggregateStats()</div><div class="line">playbook_cb = callbacks.PlaybookCallbacks(verbose=utils.VERBOSITY)</div><div class="line">runner_cb = callbacks.PlaybookRunnerCallbacks(stats, verbose=utils.VERBOSITY)</div><div class="line"></div><div class="line"><span class="comment">#创建实例，playbook位于playbook_path</span></div><div class="line">pb = ansible.playbook.PlayBook(</div><div class="line">    playbook = playbook_path,</div><div class="line">    stats = stats,</div><div class="line">    callbacks = playbook_cb,</div><div class="line">    runner_callbacks = runner_cb,</div><div class="line">    inventory = example_inventory,</div><div class="line">    subset = <span class="string">'all'</span>,</div><div class="line">    )</div><div class="line"></div><div class="line"><span class="comment">#运行playbook</span></div><div class="line">pr = pb.run()</div><div class="line"></div><div class="line"><span class="comment">#打印结果</span></div><div class="line"><span class="keyword">print</span> json.dumps(pr, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</div></pre></td></tr></table></figure>
<p>//stdout</p>
<pre><code>PLAY [localhost_group] ********************************************************

GATHERING FACTS ***************************************************************
ok: [localhost]

TASK: [kernel info] ***********************************************************
changed: [localhost]

TASK: [memory info] ***********************************************************
changed: [localhost]
{
    &quot;localhost&quot;: {
    &quot;changed&quot;: 2,
    &quot;failures&quot;: 0,
    &quot;ok&quot;: 3,
    &quot;skipped&quot;: 0,
    &quot;unreachable&quot;: 0
    }
}
</code></pre><h4 id="ansible-runner更多信息"><a href="#ansible-runner更多信息" class="headerlink" title="ansible.runner更多信息"></a>ansible.runner更多信息</h4><pre><code>&gt;&gt;&gt; import ansible.runner
&gt;&gt;&gt; dir(ansible.runner)
[&apos;C&apos;, &apos;DefaultRunnerCallbacks&apos;, &apos;HAS_ATFORK&apos;, &apos;HostVars&apos;, &apos;ModuleReplacer&apos;, &apos;OUTPUT_LOCKFILE&apos;, &apos;PROCESS_LOCKFILE&apos;, &apos;Queue&apos;, &apos;ReturnData&apos;, &apos;Runner&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;_executor_hook&apos;, &apos;ansible&apos;, &apos;atfork&apos;, &apos;base64&apos;, &apos;check_conditional&apos;, &apos;collections&apos;, &apos;connection&apos;, &apos;errors&apos;, &apos;getpass&apos;, &apos;jinja2&apos;, &apos;module_common&apos;, &apos;module_replacer&apos;, &apos;multiprocessing&apos;, &apos;multiprocessing_runner&apos;, &apos;os&apos;, &apos;pipes&apos;, &apos;poller&apos;, &apos;pwd&apos;, &apos;random&apos;, &apos;return_data&apos;, &apos;signal&apos;, &apos;socket&apos;, &apos;split_args&apos;, &apos;string_functions&apos;, &apos;subprocess&apos;, &apos;sys&apos;, &apos;tempfile&apos;, &apos;template&apos;, &apos;time&apos;, &apos;traceback&apos;, &apos;utils&apos;, &apos;vv&apos;]
&gt;&gt;&gt; help(ansible.runner.Runner)    
</code></pre><h4 id="Python-yaml-模块自定义playbook"><a href="#Python-yaml-模块自定义playbook" class="headerlink" title="Python yaml 模块自定义playbook"></a>Python yaml 模块自定义playbook</h4><p>define_yaml.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> yaml</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">playbook_path = <span class="string">'/home/ubuntu/scripts'</span></div><div class="line"></div><div class="line">Yml_args = &#123;&#125;</div><div class="line">Yml = []</div><div class="line">Yml_args[<span class="string">"gather_facts"</span>] = <span class="keyword">False</span></div><div class="line">Yml_args[<span class="string">"hosts"</span>] = <span class="string">"localhost_group"</span></div><div class="line">Yml_args[<span class="string">"remote_user"</span>] = <span class="string">"ubuntu"</span></div><div class="line">Yml_task = []</div><div class="line">Yml_task.append(&#123;<span class="string">'shell'</span>: <span class="string">'uptime'</span>, <span class="string">'name'</span>: <span class="string">'uptime info'</span>&#125;)</div><div class="line">Yml_task.append(&#123;<span class="string">'shell'</span>: <span class="string">'free -m'</span>, <span class="string">'name'</span>: <span class="string">'memory info'</span>&#125;)</div><div class="line">Yml_args[<span class="string">"tasks"</span>] = Yml_task</div><div class="line">Yml.append(Yml_args)</div><div class="line">Yml = yaml.dump(Yml)</div><div class="line">Yml_path = os.path.join(playbook_path, <span class="string">"exp.yml"</span>)</div><div class="line"><span class="keyword">with</span> open(Yml_path, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(Yml)</div></pre></td></tr></table></figure></p>
<p>运行并检测：</p>
<pre><code>$ python define_yaml.py

$ ansible-playbook  -i /etc/ansible/hosts  exp.yml

PLAY [localhost_group] ********************************************************

TASK: [uptime info] ***********************************************************
changed: [localhost]

TASK: [memory info] ***********************************************************
changed: [localhost]

PLAY RECAP ********************************************************************
localhost                  : ok=2    changed=2    unreachable=0    failed=0

$ cat exp.yml
- gather_facts: false
  hosts: localhost_group
  remote_user: ubuntu
  tasks:
  - {name: uptime info, shell: uptime}
  - {name: memory info, shell: free -m}
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.ansible.com/ansible/dev_guide/developing_api.html" target="_blank" rel="external">Ansible Python API</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h2&gt;&lt;h3 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// ping 模块&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ansible localhost -m ping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;localhost | success &amp;gt;&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;changed&amp;quot;: false,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;ping&amp;quot;: &amp;quot;pong&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// shell 模块&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ansible localhost -m shell -a &amp;apos;uptime&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;localhost | success | rc=0 &amp;gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11:00:11 up 66 days, 23:34,  1 user,  load average: 0.00, 0.01, 0.05&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Python-API&quot;&gt;&lt;a href=&quot;#Python-API&quot; class=&quot;headerlink&quot; title=&quot;Python API&quot;&gt;&lt;/a&gt;Python API&lt;/h3&gt;&lt;p&gt;通过ansible.runner模块来实现&lt;/p&gt;
    
    </summary>
    
      <category term="Dev" scheme="http://yoursite.com/categories/Dev/"/>
    
    
      <category term="Ansible" scheme="http://yoursite.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>跨仓库转移SVN代码目录</title>
    <link href="http://yoursite.com/2016/11/01/svn-code-transfer/"/>
    <id>http://yoursite.com/2016/11/01/svn-code-transfer/</id>
    <published>2016-11-01T10:59:38.000Z</published>
    <updated>2016-11-07T08:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司先前代码管理比较混乱，不同部门之间的代码有放在同一个仓库的，抽空转移了部分并记录备忘。</p>
<p><strong>project项目位于dev仓库的主分支，现需要将他转移到ops仓库主分支</strong></p>
<blockquote>
<p>old svn: <a href="http://svnserver/svn/dev/trunk/project/" target="_blank" rel="external">http://svnserver/svn/dev/trunk/project/</a></p>
<p>new svn:<a href="http://svnserver/svn/ops/trunk/" target="_blank" rel="external">http://svnserver/svn/ops/trunk/</a></p>
</blockquote>
<p><strong>直接svn move 报错：</strong></p>
<pre><code>$ svn move  http://svnserver/svn/dev/trunk/project/  http://svnserver/svn/ops/trunk/
svn: E200007: Source and destination URLs appear not to point to the same repository.
</code></pre><blockquote>
<p>svn: E200007: Source and destination URLs appear not to point to the same repository. </p>
<p>不同的仓库之间无法直接move或cp项目代码</p>
</blockquote>
<a id="more"></a>
<h3 id="转移方法："><a href="#转移方法：" class="headerlink" title="转移方法："></a>转移方法：</h3><p><strong>方法一：</strong></p>
<p>先将old svn项目代码check到本地然后import到new svn中</p>
<ul>
<li><p>缺点：old svn的代码的历史记录都会清空</p>
</li>
<li><p>优点：在客户端本地就能完成</p>
</li>
</ul>
<p>操作如下：</p>
<pre><code>$ svn --username=abner.zhao checkout http://svnserver/svn/dev/trunk/project/ project
$ svn import project  svn:http://svnserver/svn/ops/trunk/  -m &apos;import project to trunk&apos;
</code></pre><p><strong>方法二：</strong></p>
<p>将old svn中要迁移的项目代码dump出来，然后load 到new svn中</p>
<ul>
<li><p>优点：保留历史记录</p>
</li>
<li><p>缺点：要到svn服务端上操作</p>
</li>
</ul>
<p>操作如下：</p>
<pre><code>$ svnadmin dump dev | svndumpfilter include /trunk/UDPServer/ --drop-empty-revs --renumber-revs --preserve-revprops &gt; /tmp/project.dump
$ svnadmin load ops &lt; /tmp/project.dump
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://falstaff.agner.ch/2011/11/12/subversion-move-folder-from-one-repository-to-another/" target="_blank" rel="external">subversion-move-folder-from-one-repository-to-another</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司先前代码管理比较混乱，不同部门之间的代码有放在同一个仓库的，抽空转移了部分并记录备忘。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;project项目位于dev仓库的主分支，现需要将他转移到ops仓库主分支&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;old svn: &lt;a href=&quot;http://svnserver/svn/dev/trunk/project/&quot;&gt;http://svnserver/svn/dev/trunk/project/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;new svn:&lt;a href=&quot;http://svnserver/svn/ops/trunk/&quot;&gt;http://svnserver/svn/ops/trunk/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;直接svn move 报错：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn move  http://svnserver/svn/dev/trunk/project/  http://svnserver/svn/ops/trunk/
svn: E200007: Source and destination URLs appear not to point to the same repository.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;svn: E200007: Source and destination URLs appear not to point to the same repository. &lt;/p&gt;
&lt;p&gt;不同的仓库之间无法直接move或cp项目代码&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="svn" scheme="http://yoursite.com/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Python编码风格</title>
    <link href="http://yoursite.com/2016/10/29/Python-code-style/"/>
    <id>http://yoursite.com/2016/10/29/Python-code-style/</id>
    <published>2016-10-29T07:00:25.000Z</published>
    <updated>2016-11-07T08:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标记"><a href="#标记" class="headerlink" title="#!标记"></a>#!标记</h3><blockquote>
<p>大部分.py文件不必以#!作为文件的开始。 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始。 (<code>#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略。因此只有被直接执行的文件中才有必要加入#!</code>)</p>
</blockquote>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><blockquote>
<p>不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
</blockquote>
<h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><blockquote>
<p>每行不超过80个字符</p>
</blockquote>
<a id="more"></a>
<h4 id="例外："><a href="#例外：" class="headerlink" title="例外："></a>例外：</h4><ul>
<li>长的导入模块语句</li>
<li>注释里的URL</li>
</ul>
<p>Python会将<code>圆括号、中括号和花括号</code>中的行隐式的连接起来，不要使用反斜杠连接行</p>
<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<pre><code>long_str = (&apos;This will build a very long long&apos;
            &apos;long long long long long long string&apos;)                                 
</code></pre><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><blockquote>
<p>尽量少使用括号，除非实现隐式行，不要在返回语句或条件语句中使用括号，在元组两边可以使用括号</p>
</blockquote>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote>
<p>用4个空格来缩进代码</p>
</blockquote>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>顶级定义（类和函数）之间空两行, 方法定义之间空一行</li>
<li>括号内不要有空格</li>
<li>逗号, 分号, 冒号前面不要加空格，应该在它们后面加(除了在行尾)</li>
<li>参数列表, 索引或切片的左括号前不应加空格</li>
<li>在二元操作符两边都加上一个空格, 比如赋值<code>(=，==， &lt;， &gt;， !=， &lt;&gt;， &lt;=， &gt;=，in， not in， is， is not)， 布尔(and， or， not)</code></li>
<li>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格</li>
<li>不要用空格来垂直对齐多行间的标记，这会成为维护的负担(适用于:, #, =等)</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>文档字符串</li>
</ul>
<blockquote>
<p>使用三重双引号”””(一个文档字符串应该这样组织: 首先是一行以句号，问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行)接着是一个空行。接着是文档字符串剩下的部分， 它应该与文档字符串的第一行的第一个引号对齐 )</p>
</blockquote>
<ul>
<li>函数和方法</li>
</ul>
<blockquote>
<p>函数必须要有文档字符串，除非它外部不可见、非常短小、简单明了。文档字符串应该包含函数做什么, 以及输入和输出的详细描述</p>
</blockquote>
<p><strong>Args:</strong></p>
<p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.描述应该包括所需的类型和含义，如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)</p>
<p><strong>Returns: (或者 Yields: 用于生成器)</strong></p>
<p>描述返回值的类型和语义。如果函数返回None, 这一部分可以省略</p>
<p><strong>Raises:</strong></p>
<p>列出与接口有关的所有异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></div><div class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></div><div class="line"></div><div class="line">    Retrieves rows pertaining to the given keys from the Table instance</div><div class="line">    represented by big_table.  Silly things may happen if</div><div class="line">    other_silly_variable is not None.</div><div class="line"></div><div class="line">    Args:</div><div class="line">        big_table: An open Bigtable Table instance.</div><div class="line">        keys: A sequence of strings representing the key of each table row</div><div class="line">        to fetch.</div><div class="line">        other_silly_variable: Another optional variable, that has a much</div><div class="line">        longer name than the other args, and which does nothing.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        A dict mapping keys to the corresponding table row data</div><div class="line">        fetched. Each row is represented as a tuple of strings. For</div><div class="line">        example:</div><div class="line"></div><div class="line">        &#123;'Serak': ('Rigel VII', 'Preparer'),</div><div class="line">        'Zim': ('Irk', 'Invader'),</div><div class="line">        'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</div><div class="line"></div><div class="line">        If a key from the keys argument is missing from the dictionary,</div><div class="line">        then that row was not found in the table.</div><div class="line"></div><div class="line">    Raises:</div><div class="line">        IOError: An error occurred accessing the bigtable.Table object.</div><div class="line">    """</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段。并且应该遵守和函数参数相同的格式</p>
<pre><code class="python">
<span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span>
    <span class="string">"""Summary of class here.

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    """</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span>
        <span class="string">"""Inits SampleClass with blah."""</span>
        self.likes_spam = likes_spam
        self.eggs = <span class="number">0</span>

    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span>
        <span class="string">"""Performs operation blah."""</span>
</code></pre>
<blockquote>
<p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串</li>
</ul>
<blockquote>
<p>避免在循环中用+和+=操作符来累加字符串，字符串是不可变的，这样做会创建不必要的临时对象。作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表</p>
</blockquote>
<ul>
<li><p>在同一个文件中, 保持使用字符串引号的一致性(使用单引号’或者双引号”)</p>
</li>
<li><p>为多行字符串使用三重双引号”“”</p>
</li>
</ul>
<h3 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h3><blockquote>
<p>在文件和sockets结束时, 显式的关闭它，文件使用<code>with</code></p>
</blockquote>
<h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><blockquote>
<p>为临时代码使用TODO注释</p>
</blockquote>
<p>TODO注释应该在所有开头处包含”TODO”字符串，紧跟着是用括号括起来的你的名字，email地址或其它标识符。然后是一个可选的冒号。接着必须有一行注释，解释要做什么.</p>
<pre><code># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.
# TODO(Zeke) Change this to use relations.
</code></pre><h3 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h3><blockquote>
<p>每个导入应该独占一行</p>
</blockquote>
<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p>
<pre><code>1.标准库导入
2.第三方库导入
3.应用程序指定导入
</code></pre><p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<pre><code>import foo
from foo import bar
from foo.bar import baz
from foo.bar import Quux
from Foob import ar
</code></pre><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><blockquote>
<p>通常每个语句应该独占一行</p>
</blockquote>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>
<p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><blockquote>
<p>`module_name, package_name, ClassName, method_name, ExceptionName, function_name,</p>
<p> GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.`</p>
</blockquote>
<p>应该避免的名称</p>
<ul>
<li>单字符名称, 除了计数器和迭代器</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ul>
<p>命名约定</p>
<ul>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含)</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有</li>
<li>将相关的类和顶级函数放在同一个模块里</li>
<li>对类名使用大写字母开头的单词(如CapWords), 但是模块名应该用小写加下划线的方式(如lower_with_under.py)</li>
</ul>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code></p>
<pre><code>def main():
  ...

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="external">Google 开源项目风格指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;标记&quot;&gt;&lt;a href=&quot;#标记&quot; class=&quot;headerlink&quot; title=&quot;#!标记&quot;&gt;&lt;/a&gt;#!标记&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;大部分.py文件不必以#!作为文件的开始。 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始。 (&lt;code&gt;#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略。因此只有被直接执行的文件中才有必要加入#!&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分号&quot;&gt;&lt;a href=&quot;#分号&quot; class=&quot;headerlink&quot; title=&quot;分号&quot;&gt;&lt;/a&gt;分号&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不要在行尾加分号, 也不要用分号将两条命令放在同一行.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;行长度&quot;&gt;&lt;a href=&quot;#行长度&quot; class=&quot;headerlink&quot; title=&quot;行长度&quot;&gt;&lt;/a&gt;行长度&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;每行不超过80个字符&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Dev" scheme="http://yoursite.com/categories/Dev/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ss获取内核状态信息</title>
    <link href="http://yoursite.com/2016/06/16/ss/"/>
    <id>http://yoursite.com/2016/06/16/ss/</id>
    <published>2016-06-16T12:46:44.000Z</published>
    <updated>2016-11-07T08:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ss-简介"><a href="#一、ss-简介" class="headerlink" title="一、ss 简介"></a>一、ss 简介</h2><blockquote>
<p>ss  is  used to dump socket statistics. It allows showing information similar to netstat.  It can dis‐<br>       play more TCP and state informations than other tools.</p>
<p>The ss command is capable of showing more information than the netstat and is faster. The netstat command reads various /proc files to gather information. However this approach falls weak when there are lots of connections to display. This makes it slower.</p>
<p>The ss command gets its information directly from kernel space. The options used with the ss commands are very similar to netstat making it an easy replacement.</p>
</blockquote>
<p>ss 命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但 ss 的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p>
<p>ss 利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。</p>
<a id="more"></a>
<h3 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1 选项"></a>1.1 选项</h3><pre><code>Usage: ss [ OPTIONS ]
    ss [ OPTIONS ] [ FILTER ]
-h, --help      this message
-V, --version   output version information
-n, --numeric   don&apos;t resolve service names  #不解析服务名称，以数字方式显示
-a, --all       display all sockets #显示所有的套接字
-l, --listening display listening sockets #显示处于监听状态的套接字
-o, --options       show timer information #显示计时器信息
-m, --memory        show socket memory usage #显示套接字的内存使用情况
-p, --processes show process using socket #显示使用套接字的进程信息
-i, --info      show internal TCP information #显示内部TCP信息
-t, --tcp       display only TCP sockets #只显示TCP套接字
-u, --udp       display only UDP sockets #只显示UDP套接字
-d, --dccp      display only DCCP sockets #只显示DCCP套接字
-w, --raw       display only RAW sockets #只显示RAW套接字
-x, --unix      display only Unix domain sockets #只显示UNIX域套接字
</code></pre><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><h3 id="2-1-显示所有的连接"><a href="#2-1-显示所有的连接" class="headerlink" title="2.1 显示所有的连接"></a>2.1 显示所有的连接</h3><pre><code># ss | more
Netid  State      Recv-Q Send-Q   Local Address:Port       Peer Address:Port
u_str  ESTAB      0      0      /var/run/dbus/system_bus_socket 24643                 * 39740
u_str  ESTAB      0      0                    * 26693                 * 26694
u_str  ESTAB      0      0                    * 26683                 * 39746
u_str  ESTAB      0      0      @/com/ubuntu/upstart 16419                 * 101
u_str  ESTAB      0      0      /var/run/mysqld/mysqld.sock 23234                 * 8691
......
</code></pre><h3 id="2-2-过滤TCP、UDP和UNIX域套接字"><a href="#2-2-过滤TCP、UDP和UNIX域套接字" class="headerlink" title="2.2 过滤TCP、UDP和UNIX域套接字"></a>2.2 过滤TCP、UDP和UNIX域套接字</h3><pre><code># ss -t  //仅显示建立的tcp连接
State      Recv-Q Send-Q                      Local Address:Port                          Peer Address:Port
ESTAB      0      0                               127.0.0.1:59954                            127.0.0.1:2633
ESTAB      0      0                               127.0.0.1:2633                             127.0.0.1:59954
ESTAB      0      148                          10.249.7.247:ssh                          10.249.23.101:50285
# ss -ta //显示tcp连接的所有状态
State      Recv-Q Send-Q                      Local Address:Port                          Peer Address:Port
LISTEN     0      128                                     *:40861                                    *:*
LISTEN     0      15                                      *:2633                                     *:*
LISTEN     0      50                              127.0.0.1:mysql                                    *:*
ESTAB      0      0                               127.0.0.1:59956                            127.0.0.1:2633
TIME-WAIT  0      0                               127.0.0.1:2633                             127.0.0.1:59951
# ss -u
# ss -ua
# ss -x
# ss -ltu //查看处于监听状态的tcp和udp连接
</code></pre><h3 id="2-3-显示-Sockets-摘要"><a href="#2-3-显示-Sockets-摘要" class="headerlink" title="2.3 显示 Sockets 摘要"></a>2.3 显示 Sockets 摘要</h3><pre><code># ss -s
Total: 168 (kernel 1734)
TCP:   22 (estab 1, closed 9, orphaned 0, synrecv 0, timewait 8/0), ports 0

Transport Total     IP        IPv6
*     1734      -         -
RAW   0         0         0
UDP   10        7         3
TCP   13        10        3
INET      23        17        6
FRAG      0         0         0
</code></pre><h3 id="2-4-查看进程使用的Socket"><a href="#2-4-查看进程使用的Socket" class="headerlink" title="2.4 查看进程使用的Socket"></a>2.4 查看进程使用的Socket</h3><pre><code># ss -plt
State      Recv-Q Send-Q                      Local Address:Port                          Peer Address:Port
LISTEN     0      128                                     *:40861                                    *:*        users:((&quot;rpc.statd&quot;,1325,9))
LISTEN     0      15                                      *:2633                                     *:*        users:((&quot;oned&quot;,2204,26))
LISTEN     0      50                              127.0.0.1:mysql                                    *:*        users:((&quot;mysqld&quot;,1525,10))
LISTEN     0      100                          10.249.7.247:9869                                     *:*        users:((&quot;ruby&quot;,2070,8))
LISTEN     0      128                                     *:sunrpc                                   *:*        users:((&quot;rpcbind&quot;,1319,8))
LISTEN     0      100                                     *:29876                                    *:*        users:((&quot;python&quot;,2054,0))
</code></pre><h3 id="2-5-根据TCP状态过滤连接"><a href="#2-5-根据TCP状态过滤连接" class="headerlink" title="2.5 根据TCP状态过滤连接"></a>2.5 根据TCP状态过滤连接</h3><pre><code># ss [ OPTIONS ] [ STATE-FILTER ] [ ADDRESS-FILTER ]
# ss -t4 state established
Recv-Q Send-Q                           Local Address:Port                               Peer Address:Port
0      148                               10.249.7.247:ssh                               10.249.23.101:50285
0      0                                    127.0.0.1:60035                                 127.0.0.1:2633
0      0                                    127.0.0.1:2633                                  127.0.0.1:60035
# ss -t4 state time-wait
Recv-Q Send-Q                           Local Address:Port                               Peer Address:Port
0      0                                    127.0.0.1:2633                                  127.0.0.1:60033
0      0                                 10.249.7.247:9869                              10.249.23.101:60243
0      0                                 10.249.7.247:9869                              10.249.23.101:60248
0      0                                 10.249.7.247:9869                              10.249.23.101:60239
0      0                                 10.249.7.247:9869                              10.249.23.101:60245
</code></pre><p>状态如下：</p>
<blockquote>
<p>1.established</p>
<p>2.syn-sent </p>
<p>3.syn-recv </p>
<p>4.fin-wait-1  </p>
<p>5.fin-wait-2 </p>
<p>6.time-wait </p>
<p>7.closed </p>
<p>8.close-wait </p>
<p>9.last-ack </p>
<p>10.closing </p>
<p>11.all - All of the above states </p>
<p>12.connected - All the states except for listen and closed </p>
<p>13.synchronized - All the connected states except for syn-sent </p>
<p>14.bucket - Show states, which are maintained as minisockets, i.e. time-wait and syn-recv. </p>
<p>15.big - Opposite to bucket state.</p>
</blockquote>
<h3 id="2-6-根据IP地址和端口过滤连接"><a href="#2-6-根据IP地址和端口过滤连接" class="headerlink" title="2.6 根据IP地址和端口过滤连接"></a>2.6 根据IP地址和端口过滤连接</h3><pre><code># ss -at &apos;( dport = :ssh or sport = :ssh )&apos;
# ss -nt  dst :443 or dst :80 
# ss -nt dst 74.125.236.178
</code></pre><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="http://www.binarytides.com/linux-ss-command/" target="_blank" rel="external">10 examples of Linux ss command to monitor network connections</a><br><a href="http://man.linuxde.net/ss" target="_blank" rel="external">ss 命令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、ss-简介&quot;&gt;&lt;a href=&quot;#一、ss-简介&quot; class=&quot;headerlink&quot; title=&quot;一、ss 简介&quot;&gt;&lt;/a&gt;一、ss 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ss  is  used to dump socket statistics. It allows showing information similar to netstat.  It can dis‐&lt;br&gt;       play more TCP and state informations than other tools.&lt;/p&gt;
&lt;p&gt;The ss command is capable of showing more information than the netstat and is faster. The netstat command reads various /proc files to gather information. However this approach falls weak when there are lots of connections to display. This makes it slower.&lt;/p&gt;
&lt;p&gt;The ss command gets its information directly from kernel space. The options used with the ss commands are very similar to netstat making it an easy replacement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ss 命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但 ss 的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。&lt;/p&gt;
&lt;p&gt;ss 利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。&lt;/p&gt;
    
    </summary>
    
      <category term="Cmd" scheme="http://yoursite.com/categories/Cmd/"/>
    
    
      <category term="ss" scheme="http://yoursite.com/tags/ss/"/>
    
  </entry>
  
  <entry>
    <title>raid磁盘状态备忘</title>
    <link href="http://yoursite.com/2016/06/12/raid_states/"/>
    <id>http://yoursite.com/2016/06/12/raid_states/</id>
    <published>2016-06-12T13:06:42.000Z</published>
    <updated>2016-11-07T08:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Physical-Drive-States"><a href="#Physical-Drive-States" class="headerlink" title="Physical Drive States"></a>Physical Drive States</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/54211F71-8626-4FEE-A37D-91E5F1464B74.png" alt=""></p>
<a id="more"></a>
<p>Unconfigured Good：表示该硬盘为空闲硬盘,没有加入到raid阵列中也没有设置为热备盘</p>
<p>Unconfigured Bad：表示该硬盘为空闲硬盘且硬盘有损坏</p>
<p>Rebuild:表示该盘正在重建数据</p>
<p>Foreign:表示该盘有外来的阵列信息，需要清除原来的阵列信息才能配置</p>
<p>readly –&gt; online  [ foreign –&gt; readly –&gt; online ]</p>
<h3 id="Virtual-Disk-States"><a href="#Virtual-Disk-States" class="headerlink" title="Virtual Disk States"></a>Virtual Disk States</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/AB6872BA-666F-4EEE-A33C-4B0FE067ED95.png" alt=""></p>
<p>Virtual Disk States：指的是由物理硬盘做完raid后的虚拟磁盘（逻辑磁盘）</p>
<p>Optimal:表示整个raid的状态正常</p>
<p>Degraded:表示有一块物理硬盘出错或下线，导致raid进入降级模式</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="ftp://ftp.sgi.com/public/Technical%20Support/Pdf%20files/LSI/84016E_mr_sas_sw_ug.pdf" target="_blank" rel="external">megacli_user_guide.pdf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Physical-Drive-States&quot;&gt;&lt;a href=&quot;#Physical-Drive-States&quot; class=&quot;headerlink&quot; title=&quot;Physical Drive States&quot;&gt;&lt;/a&gt;Physical Drive States&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7vzmp5.com1.z0.glb.clouddn.com/54211F71-8626-4FEE-A37D-91E5F1464B74.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="raid" scheme="http://yoursite.com/tags/raid/"/>
    
  </entry>
  
  <entry>
    <title>cpuinfo</title>
    <link href="http://yoursite.com/2016/06/07/cpuinfo/"/>
    <id>http://yoursite.com/2016/06/07/cpuinfo/</id>
    <published>2016-06-07T12:39:35.000Z</published>
    <updated>2016-11-07T08:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h3><blockquote>
<p> Information about the processor, such as its type, make, model, and performance.</p>
</blockquote>
<h3 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h3><h4 id="CPU型号"><a href="#CPU型号" class="headerlink" title="CPU型号"></a>CPU型号</h4><pre><code># cat /proc/cpuinfo | grep vendor | uniq
vendor_id   : GenuineIntel
#  cat /proc/cpuinfo | grep &apos;model name&apos; | uniq
model name  : Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz
</code></pre><h4 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h4><pre><code># lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
......
</code></pre><a id="more"></a>
<h4 id="物理CPU个数"><a href="#物理CPU个数" class="headerlink" title="物理CPU个数"></a>物理CPU个数</h4><pre><code># cat /proc/cpuinfo | grep &quot;physical id&quot; | sort -u | wc -l
2
</code></pre><h4 id="单个物理CPU中Core个数"><a href="#单个物理CPU中Core个数" class="headerlink" title="单个物理CPU中Core个数"></a>单个物理CPU中Core个数</h4><pre><code># cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq
cpu cores   : 8
</code></pre><h4 id="所有物理CPU上的Core个数（core-id-数量）"><a href="#所有物理CPU上的Core个数（core-id-数量）" class="headerlink" title="所有物理CPU上的Core个数（core id 数量）"></a>所有物理CPU上的Core个数（core id 数量）</h4><pre><code># cat /proc/cpuinfo | grep &quot;core id&quot; | uniq |  wc -l
32
</code></pre><h4 id="逻辑CPU个数"><a href="#逻辑CPU个数" class="headerlink" title="逻辑CPU个数"></a>逻辑CPU个数</h4><pre><code># cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l
32
</code></pre><h4 id="超线程（HT）技术"><a href="#超线程（HT）技术" class="headerlink" title="超线程（HT）技术"></a>超线程（HT）技术</h4><blockquote>
<p>number of processing units = number of cores [ no hyper threading ] </p>
<p>number of processing units = number of cores * 2 [ hyper threading present ]</p>
</blockquote>
<pre><code># cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq
cpu cores   : 8
# cat /proc/cpuinfo | grep &quot;siblings&quot; | sort -u
siblings    : 16
# lscpu | grep Thread
Thread(s) per core:    2
</code></pre><h4 id="重要字段含义"><a href="#重要字段含义" class="headerlink" title="重要字段含义"></a>重要字段含义</h4><ul>
<li>processor 逻辑处理器的唯一标识符</li>
<li>physical id 每个物理封装的唯一标识符</li>
<li>core id 每个内核的唯一标识符</li>
<li>siblings 位于相同物理封装中的逻辑处理器的数量</li>
<li>cpu cores 位于相同物理封装中的内核数量</li>
</ul>
<p>各字段关系如下图所示：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/5793DDE2-40C0-4147-AD14-C85C1574C2DE.png" alt=""> </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.binarytides.com/linux-check-processor/" target="_blank" rel="external">How to check processor and cpu details on Linux</a><br><a href="https://www.centos.org/docs/5/html/5.1/Deployment_Guide/s2-proc-cpuinfo.html" target="_blank" rel="external">Deployment_Guide/s2-proc-cpuinfo</a><br><a href="http://blog.csdn.net/sycflash/article/details/6643492" target="_blank" rel="external">CPU信息/proc/cpuinfo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;proc-cpuinfo&quot;&gt;&lt;a href=&quot;#proc-cpuinfo&quot; class=&quot;headerlink&quot; title=&quot;/proc/cpuinfo&quot;&gt;&lt;/a&gt;/proc/cpuinfo&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; Information about the processor, such as its type, make, model, and performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;信息查看&quot;&gt;&lt;a href=&quot;#信息查看&quot; class=&quot;headerlink&quot; title=&quot;信息查看&quot;&gt;&lt;/a&gt;信息查看&lt;/h3&gt;&lt;h4 id=&quot;CPU型号&quot;&gt;&lt;a href=&quot;#CPU型号&quot; class=&quot;headerlink&quot; title=&quot;CPU型号&quot;&gt;&lt;/a&gt;CPU型号&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;# cat /proc/cpuinfo | grep vendor | uniq
vendor_id   : GenuineIntel
#  cat /proc/cpuinfo | grep &amp;apos;model name&amp;apos; | uniq
model name  : Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;CPU-架构&quot;&gt;&lt;a href=&quot;#CPU-架构&quot; class=&quot;headerlink&quot; title=&quot;CPU 架构&quot;&gt;&lt;/a&gt;CPU 架构&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;# lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
......
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="cpuinfo" scheme="http://yoursite.com/tags/cpuinfo/"/>
    
  </entry>
  
  <entry>
    <title>iostat查看磁盘IO信息</title>
    <link href="http://yoursite.com/2016/05/27/iostat/"/>
    <id>http://yoursite.com/2016/05/27/iostat/</id>
    <published>2016-05-27T03:19:17.000Z</published>
    <updated>2016-11-07T08:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、iostat简介"><a href="#一、iostat简介" class="headerlink" title="一、iostat简介"></a>一、iostat简介</h3><blockquote>
<p>iostat - Report Central Processing Unit (CPU) statistics and input/out-put statistics for devices and partitions.</p>
</blockquote>
<p>iostat 用于输出CPU和磁盘I/O相关的统计信息。</p>
<a id="more"></a>
<p>选项如下：</p>
<pre><code>-c     The  -c  option  is exclusive of the -d option and displays only
       the CPU usage report.  //仅显示CPU统计信息，与-d选项互斥

-d     The -d option is exclusive of the -c option  and  displays  only
       the device utilization report. //仅显示磁盘统计信息，与-c选项互斥

-k     Display statistics in kilobytes per second instead of blocks per
       second.  Data displayed are valid  only  with  kernels  2.4  and
       newer. // 以KB为单位显示每秒的磁盘请求数，默认单位块

 -p device | ALL
       The -p option is exclusive of the -x option and displays statis-
       tics for block devices and all their partitions that are used by
       the  system.   If  a device name is entered on the command line,
       then statistics for it and all  its  partitions  are  displayed.
       Last,  the ALL keyword indicates that statistics have to be dis-
       played for all the block devices and partitions defined  by  the
       system,  including  those  that have never been used.  Note that
       this option works only with post 2.5 kernels. 
       // 用于显示块设备及系统分区的统计信息，与-x选项互斥

-t     Print the time for each report displayed.

-V     Print version number and usage then exit.

-x     Display extended statistics.  This option is exclusive of the -p
       one,   and   works   with   post  2.5  kernels  since  it  needs
       /proc/diskstats file or a mounted sysfs to get  the  statistics.
       This  option may also work with older kernels (e.g. 2.4) only if
       extended statistics are available in /proc/partitions (the  ker-
       nel needs to be patched for that).
</code></pre><h3 id="二、iostat的简单使用"><a href="#二、iostat的简单使用" class="headerlink" title="二、iostat的简单使用"></a>二、iostat的简单使用</h3><pre><code># iostat  // 显示CPU和设备吞吐率的统计信息
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
            0.05    0.00    0.07    0.01    0.00   99.87

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               0.76         3.69        12.60   60628026  206899224
</code></pre><p>输出项说明：</p>
<p>%user:  在用户级别运行所使用的 CPU 的百分比。</p>
<p>%nice:  nice 操作所使用的 CPU 的百分比。</p>
<p>%system:    在核心级别（kernel）运行所使用 CPU 的百分比。</p>
<p>%iowait:    CPU 等待硬件 I/O 所占用 CPU 的百分比。</p>
<p>%steal: 当管理程序（hypervisor）为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比。</p>
<p>%idle:  CPU 空闲时间的百分比。</p>
<p>tps:    每秒钟物理设备的 I/O 传输总量。</p>
<p>[MB/KB/B]lk_read:   读入的数据总量，单位为MB/KB/块。</p>
<p>[MB/KB/B]lk_wrtn    :写入的数据总量，单位为MB/KB/块。</p>
<p>[MB/KB/B]lk_read/s: 每秒从驱动器读入的数据量，单位为MB/KB/块。</p>
<p>[MB/KB/B]lk_wrtn/s: 每秒向驱动器写入的数据量，单位为MB/KB/块。</p>
<pre><code># iostat -d 2  //每隔2秒显示一次设备吞吐率的统计信息（单位为 块/s）
# iostat -dk 2 //每隔2秒显示一次设备吞吐率的统计信息（单位为 KB/s）
# iostat -dk 2 3 // 每隔2秒显示一次，共显示3次

# iostat -x sda  //显示 sda 设备扩展统计信息
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
            0.05    0.00    0.07    0.01    0.00   99.87

Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.00     0.86    0.05    0.72     3.69    12.60    21.36     0.00    1.83   0.75   0.06
# iostat -p sda  //显示sda 及上面所有分区的统计信息
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
            0.05    0.00    0.07    0.01    0.00   99.87

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               0.76         3.69        12.60   60628026  206904888
sda1              0.00         0.00         0.00       4994        512
sda2              0.04         3.52         2.22   57853834   36386304
sda3              0.72         0.17        10.38    2763066  170501848
sda4              0.00         0.00         0.00         20          0
sda5              0.00         0.00         0.00       4816      16224
</code></pre><p>输出项说明：</p>
<p>rrqm/s: 将读入请求合并后，每秒发送到设备的读入请求数。</p>
<p>wrqm/s: 将写入请求合并后，每秒发送到设备的写入请求数。</p>
<p>r/s:    每秒发送到设备的读入请求数。</p>
<p>w/s:    每秒发送到设备的写入请求数。</p>
<p>rsec/s: 每秒从设备读入的扇区数。</p>
<p>wsec/s: 每秒向设备写入的扇区数。</p>
<p>rkB/s:  每秒从设备读入的数据量，单位为 KB/s。</p>
<p>wkB/s:  每秒向设备写入的数据量，单位为 KB/s。</p>
<p>rMB/s:  每秒从设备读入的数据量，单位为 MB/s。</p>
<p>wMB/s:  每秒向设备写入的数据量，单位为 MB/s。</p>
<p>avgrq-sz:   发送到设备的请求的平均大小，单位为扇区。</p>
<p>avgqu-sz:   发送到设备的请求的平均队列长度。</p>
<p>await:  I/O请求平均执行时间。包括发送请求和执行的时间。单位为毫秒。</p>
<p>svctm:  发送到设备的I/O请求的平均执行时间。单位为毫秒。</p>
<p>%util:  在I/O请求发送到设备期间，占用CPU时间的百分比。用于显示设备的带宽利用率。当这个值接近100%时，表示设备带宽已经占满。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、iostat简介&quot;&gt;&lt;a href=&quot;#一、iostat简介&quot; class=&quot;headerlink&quot; title=&quot;一、iostat简介&quot;&gt;&lt;/a&gt;一、iostat简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;iostat - Report Central Processing Unit (CPU) statistics and input/out-put statistics for devices and partitions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;iostat 用于输出CPU和磁盘I/O相关的统计信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Cmd" scheme="http://yoursite.com/categories/Cmd/"/>
    
    
      <category term="iostat" scheme="http://yoursite.com/tags/iostat/"/>
    
  </entry>
  
  <entry>
    <title>sar系统状态信息统计</title>
    <link href="http://yoursite.com/2016/05/26/sar/"/>
    <id>http://yoursite.com/2016/05/26/sar/</id>
    <published>2016-05-26T03:15:51.000Z</published>
    <updated>2016-11-07T08:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、sar-简介"><a href="#一、sar-简介" class="headerlink" title="一、sar 简介"></a>一、sar 简介</h3><blockquote>
<p>sar - Collect, report, or save system activity information.</p>
<p>Usage: sar [ options ] [ interval  count  ]    </p>
<p> sar 选项 [输出间隔时间] [输出次数(默认为1)]</p>
</blockquote>
<p>sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。</p>
<p>sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</p>
<a id="more"></a>
<pre><code># cat /etc/cron.d/sysstat
# Run system activity accounting tool every 10 minutes
*/10 * * * * root /usr/lib64/sa/sa1 1 1
# Generate a daily summary of process accounting at 23:53
53 23 * * * root /usr/lib64/sa/sa2 -A   //将当天的汇总信息写入文件 /var/log/sa/saDD

sa1: stores system activities in binary data file. sa1 depends on sadc for this purpose. sa1 runs from cron.
sa2: creates daily summary of the collected statistics. sa2 runs from cron.
</code></pre><h3 id="二、sar-常用命令"><a href="#二、sar-常用命令" class="headerlink" title="二、sar 常用命令"></a>二、sar 常用命令</h3><h4 id="2-1-CPU-Usage"><a href="#2-1-CPU-Usage" class="headerlink" title="2.1 CPU Usage"></a>2.1 CPU Usage</h4><blockquote>
<p>sar -u:   Displays CPU usage for the current day that was collected until that point.</p>
<p>sar -u ALL:  Same as “sar -u” but displays additional fields.</p>
<p>sar -P ALL:  indicates that it should displays statistics for ALL the individual Cores.</p>
<p>sar -u -f /var/log/sa/sa10:  Displays CPU usage for the 10day of the month from the sa10 file.</p>
</blockquote>
<pre><code># sar -u  1 3
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/24/2016  _x86_64_    (2 CPU)

06:23:59 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
06:24:00 PM     all      0.00      0.00      0.00      0.00      0.00    100.00
06:24:01 PM     all      0.00      0.00      0.50      0.00      0.00     99.50
06:24:02 PM     all      0.50      0.00      0.50      0.00      0.00     99.00
Average:        all      0.17      0.00      0.33      0.00      0.00     99.50

# sar -P ALL 1 1
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/24/2016  _x86_64_    (2 CPU)

06:28:13 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
06:28:14 PM     all      0.00      0.00      0.00      0.00      0.00    100.00
06:28:14 PM       0      0.00      0.00      0.00      0.00      0.00    100.00
06:28:14 PM       1      0.00      0.00      0.00      0.00      0.00    100.00

Average:        CPU     %user     %nice   %system   %iowait    %steal     %idle
Average:        all      0.00      0.00      0.00      0.00      0.00    100.00
Average:          0      0.00      0.00      0.00      0.00      0.00    100.00
Average:          1      0.00      0.00      0.00      0.00      0.00    100.00

%iowait: Percentage of time that the CPU or CPUs were idle during which the  system  had an outstanding disk I/O request.
         显示用于等待I/O操作占用 CPU 总时间的百分比，若该值过高则表示硬盘存在I/O瓶颈
%idle: Percentage of time that the CPU or CPUs were idle and the system did  not  have an outstanding disk I/O request.
         显示 CPU 空闲时间占用 CPU 总时间的百分比。
</code></pre><h4 id="2-2-Memory-Free-and-Used"><a href="#2-2-Memory-Free-and-Used" class="headerlink" title="2.2 Memory Free and Used"></a>2.2 Memory Free and Used</h4><blockquote>
<p> sar -r : Report memory utilization statistics.</p>
</blockquote>
<pre><code># sar -r 1 3
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/25/2016  _x86_64_    (2 CPU)

10:20:16 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
10:20:17 AM    157356   1764852     91.81    207948   1288836    791016      7.82
10:20:18 AM    157356   1764852     91.81    207948   1288836    791016      7.82
10:20:19 AM    157356   1764852     91.81    207948   1288836    791016      7.82
Average:       157356   1764852     91.81    207948   1288836    791016      7.82
</code></pre><h4 id="2-3-Swap-Space-Used"><a href="#2-3-Swap-Space-Used" class="headerlink" title="2.3 Swap Space Used"></a>2.3 Swap Space Used</h4><blockquote>
<p>sar -S: Reports  swap statistics.</p>
</blockquote>
<pre><code># sar -S 1 3
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

10:05:34 AM kbswpfree kbswpused  %swpused  kbswpcad   %swpcad
10:05:35 AM   8183488      7484      0.09       532      7.11
10:05:36 AM   8183488      7484      0.09       532      7.11
10:05:37 AM   8183488      7484      0.09       532      7.11
Average:      8183488      7484      0.09       532      7.11
</code></pre><h4 id="2-4-Overall-I-O-Activities"><a href="#2-4-Overall-I-O-Activities" class="headerlink" title="2.4 Overall I/O Activities"></a>2.4 Overall I/O Activities</h4><blockquote>
<p>sar -b: reports I/O statistics.</p>
</blockquote>
<pre><code># sar -b 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:12:27 AM       tps      rtps      wtps   bread/s   bwrtn/s
10:12:28 AM     49.49      0.00     49.49      0.00    412.12
10:12:29 AM      0.00      0.00      0.00      0.00      0.00
10:12:30 AM      0.00      0.00      0.00      0.00      0.00
Average:        16.39      0.00     16.39      0.00    136.45
</code></pre><h4 id="2-5-Individual-Block-Device-I-O-Activities"><a href="#2-5-Individual-Block-Device-I-O-Activities" class="headerlink" title="2.5 Individual Block Device I/O Activities"></a>2.5 Individual Block Device I/O Activities</h4><blockquote>
<p>sar -d: To identify the activities by the individual block devices </p>
<p> -p: Pretty-print  device names</p>
</blockquote>
<pre><code># sar -d 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:17:42 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:17:43 AM    dev8-0      1.98      0.00    847.52    428.00      0.01      3.00      1.50      0.30

10:17:43 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:17:44 AM    dev8-0      3.00      0.00     96.00     32.00      0.00      0.00      0.00      0.00

10:17:44 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:17:45 AM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average:       dev8-0      1.67      0.00    317.33    190.40      0.00      1.20      0.60      0.10
# sar -dp 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:21:36 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:21:37 AM       sda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

10:21:37 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:21:38 AM       sda     10.00      0.00    184.00     18.40      0.00      0.30      0.30      0.30

10:21:38 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:21:39 AM       sda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average:          sda      3.36      0.00     61.74     18.40      0.00      0.30      0.30      0.10
</code></pre><h4 id="2-6-Display-context-switch-per-second"><a href="#2-6-Display-context-switch-per-second" class="headerlink" title="2.6 Display context switch per second"></a>2.6 Display context switch per second</h4><blockquote>
<p>sar -w: Reports the total number of processes created per second, and total number of context switches per second.    </p>
</blockquote>
<pre><code># sar -w 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:33:49 AM    proc/s   cswch/s
10:33:50 AM      8.08    732.32
10:33:51 AM     10.00    964.00
10:33:52 AM      8.08    686.87
Average:         8.72    794.97
</code></pre><h4 id="2-7-Reports-run-queue-and-load-average"><a href="#2-7-Reports-run-queue-and-load-average" class="headerlink" title="2.7 Reports run queue and load average"></a>2.7 Reports run queue and load average</h4><blockquote>
<p>sar -q: Reports the run queue size and load average of last 1 minute, 5 minutes, and 15 minutes.</p>
</blockquote>
<pre><code># sar -q 1 3
Linux 2.6.32-504.el6.x86_64 (tjtx-83-97.58os.org)   05/26/2016  _x86_64_    (32 CPU)

10:58:55 AM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15
10:58:56 AM         4       874      0.79      0.58      0.51
10:58:57 AM         0       873      0.79      0.58      0.51
10:58:58 AM         0       865      0.79      0.58      0.51
Average:            1       871      0.79      0.58      0.51
</code></pre><h4 id="2-8-Report-network-statistics"><a href="#2-8-Report-network-statistics" class="headerlink" title="2.8 Report network statistics"></a>2.8 Report network statistics</h4><blockquote>
<p>sar  -n { keyword [,…] | ALL } : Report network statistics.</p>
<p>Possible  keywords  are  DEV,  EDEV, NFS, NFSD, SOCK, IP, EIP, ICMP, EICMP, TCP, ETCP,<br>              UDP, SOCK6, IP6, EIP6, ICMP6, EICMP6 and UDP6.</p>
<p>   DEV – Displays network devices vital statistics for eth0, eth1, etc.</p>
</blockquote>
<pre><code># sar -n DEV 1 1
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

11:06:32 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
11:06:33 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:06:33 AM      eth0    175.76    173.74     27.92     31.94      0.00      0.00      0.00
11:06:33 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:06:33 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:06:33 AM      eth3      0.00      0.00      0.00      0.00      0.00      0.00      0.00


Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth0    175.76    173.74     27.92     31.94      0.00      0.00      0.00
Average:         eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth3      0.00      0.00      0.00      0.00      0.00      0.00      0.00
# sar -n DEV  | grep eth0
</code></pre><h4 id="2-9-Report-Sar-Data-Using-Start-Time"><a href="#2-9-Report-Sar-Data-Using-Start-Time" class="headerlink" title="2.9 Report Sar Data Using Start Time"></a>2.9 Report Sar Data Using Start Time</h4><blockquote>
<p>-s [ hh:mm:ss ]</p>
<p>   Set  the  starting  time of the data, causing the sar command to extract records time-<br>              tagged at, or following, the time specified.</p>
<p>When you view historic sar data from the /var/log/sa/saXX file using “sar -f” option, it displays all the sar data for that specific day starting from 12:00 a.m for that day.</p>
<p>Using “-s hh:mi:ss” option, you can specify the start time. For example, if you specify “sar -s 10:00:00”, it will display the sar data starting from 10 a.m (instead of starting from midnight) as shown below.</p>
</blockquote>
<pre><code># sar -q -f /var/log/sa/sa23 -s 10:00:01
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.thegeekstuff.com/2011/03/sar-examples/" target="_blank" rel="external">10 Useful Sar (Sysstat) Examples for UNIX / Linux Performance Monitoring</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、sar-简介&quot;&gt;&lt;a href=&quot;#一、sar-简介&quot; class=&quot;headerlink&quot; title=&quot;一、sar 简介&quot;&gt;&lt;/a&gt;一、sar 简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;sar - Collect, report, or save system activity information.&lt;/p&gt;
&lt;p&gt;Usage: sar [ options ] [ interval  count  ]    &lt;/p&gt;
&lt;p&gt; sar 选项 [输出间隔时间] [输出次数(默认为1)]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。&lt;/p&gt;
&lt;p&gt;sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。&lt;/p&gt;
    
    </summary>
    
      <category term="Cmd" scheme="http://yoursite.com/categories/Cmd/"/>
    
    
      <category term="sar" scheme="http://yoursite.com/tags/sar/"/>
    
  </entry>
  
  <entry>
    <title>Screen会话管理</title>
    <link href="http://yoursite.com/2016/05/23/screen/"/>
    <id>http://yoursite.com/2016/05/23/screen/</id>
    <published>2016-05-23T12:47:12.000Z</published>
    <updated>2016-11-07T08:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<p><a href="http://www.gnu.org/software/screen/" target="_blank" rel="external">GNU’s Screen 官方站点</a></p>
<h3 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h3><h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。对于远程登录的用户即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。</p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p>
<a id="more"></a>
<h4 id="会话共享"><a href="#会话共享" class="headerlink" title="会话共享"></a>会话共享</h4><p>Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。</p>
<h3 id="三、常用参数"><a href="#三、常用参数" class="headerlink" title="三、常用参数"></a>三、常用参数</h3><pre><code>screen -S yourname   //新建一个叫yourname的session
screen -ls（或者screen -list） //列出当前所有的session
screen -r yourname  //回到yourname这个session
screen -d yourname   //远程detach某个session，转移到当前终端
screen -d -r yourname  //结束当前session并回到yourname这个session

ctrl+a x -&gt; 锁住当前的 window，需用用户密码解锁
ctrl-a k -&gt; kill window，强行关闭当前的 window
ctrl+a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响
</code></pre><h3 id="四、使用实例"><a href="#四、使用实例" class="headerlink" title="四、使用实例"></a>四、使用实例</h3><h4 id="创建新窗口"><a href="#创建新窗口" class="headerlink" title="创建新窗口"></a>创建新窗口</h4><pre><code># screen  -S text   // 创建一个名字为text的会话，会打开一个默认的shell环境（一般都是bash shell）
# vi file.txt
</code></pre><p>或</p>
<pre><code># screen vi file.txt   //退出vi将退出该会话
</code></pre><h3 id="会话分离与恢复"><a href="#会话分离与恢复" class="headerlink" title="会话分离与恢复"></a>会话分离与恢复</h3><p>在screen窗口键入C-a d，Screen会给出detached，暂时中断会话。</p>
<p>找到并恢复会话：</p>
<pre><code># screen -ls    //查看当前会话
There is a screen on:
10526.test  (05/23/2016 07:48:58 PM)    (Detached)
1 Socket in /var/run/screen/S-root. 

# screen -r  test  // 进入被中断的会话，screen的名字和编号都行
</code></pre><h4 id="清除-dead会话"><a href="#清除-dead会话" class="headerlink" title="清除 dead会话"></a>清除 dead会话</h4><pre><code># screen -wipe
</code></pre><h4 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h4><pre><code>Ctrl-a k  // kill会话，同时kill会话里的进程
Ctrl-a :   // 然后输入quit命令退出Screen会话,会杀死所有窗口并退出其中运行的所有程序
</code></pre><h3 id="会话共享-1"><a href="#会话共享-1" class="headerlink" title="会话共享"></a>会话共享</h3><pre><code># screen -x  screenname

-x  Attach to a not detached screen. (Multi display mode).
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h3&gt;&lt;p&gt;GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.gnu.org/software/screen/&quot;&gt;GNU’s Screen 官方站点&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、功能&quot;&gt;&lt;a href=&quot;#二、功能&quot; class=&quot;headerlink&quot; title=&quot;二、功能&quot;&gt;&lt;/a&gt;二、功能&lt;/h3&gt;&lt;h4 id=&quot;会话恢复&quot;&gt;&lt;a href=&quot;#会话恢复&quot; class=&quot;headerlink&quot; title=&quot;会话恢复&quot;&gt;&lt;/a&gt;会话恢复&lt;/h4&gt;&lt;p&gt;只要Screen本身没有终止，在其内部运行的会话都可以恢复。对于远程登录的用户即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。&lt;/p&gt;
&lt;h4 id=&quot;多窗口&quot;&gt;&lt;a href=&quot;#多窗口&quot; class=&quot;headerlink&quot; title=&quot;多窗口&quot;&gt;&lt;/a&gt;多窗口&lt;/h4&gt;&lt;p&gt;在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="screen" scheme="http://yoursite.com/tags/screen/"/>
    
  </entry>
  
  <entry>
    <title>OpenNebula life-cycle</title>
    <link href="http://yoursite.com/2016/05/20/opennebula-life-cycle/"/>
    <id>http://yoursite.com/2016/05/20/opennebula-life-cycle/</id>
    <published>2016-05-20T09:34:53.000Z</published>
    <updated>2016-11-07T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OpenNebula-Virtual-Machine-Life-cycle"><a href="#OpenNebula-Virtual-Machine-Life-cycle" class="headerlink" title="OpenNebula Virtual Machine Life-cycle"></a>OpenNebula Virtual Machine Life-cycle</h3><p><img src="http://docs.opennebula.org/4.14/_images/states-simple.png" alt=""></p>
<p>具体状态详情请参考：<a href="http://docs.opennebula.org/4.14/user/virtual_resource_management/vm_guide_2.html" target="_blank" rel="external">vm_guide_2</a></p>
<a id="more"></a>
<h3 id="OpenNebula-Host-Life-cycle"><a href="#OpenNebula-Host-Life-cycle" class="headerlink" title="OpenNebula Host Life-cycle"></a>OpenNebula Host Life-cycle</h3><table>
<thead>
<tr>
<th>state</th>
<th>State</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>INIT</td>
<td>Initial state for enabled hosts.</td>
</tr>
<tr>
<td>update</td>
<td>MONITORING_MONITORED</td>
<td>Monitoring a healthy Host.</td>
</tr>
<tr>
<td>on</td>
<td>MONITORED</td>
<td>The host has been successfully monitored.</td>
</tr>
<tr>
<td>err</td>
<td>ERROR</td>
<td>An error occurred while monitoring the host. See the Host information with <code>onehost show</code> for an error message.</td>
</tr>
<tr>
<td>off</td>
<td>DISABLED</td>
<td>The host is disabled, and won’t be monitored. The scheduler ignores Hosts in this state.</td>
</tr>
<tr>
<td>retry</td>
<td>MONITORING_ERROR</td>
<td>Monitoring a host in error state.</td>
</tr>
</tbody>
</table>
<p>当 host 节点状态为error时，执行 onehost show 命令获取错误信息或是在web上查看日志。<br>当节点文件丢失时，host状态就是变成error，host上面的vm状态则会为unknown。此时可用以下命令修复：</p>
<pre><code>onehost sync --force 
</code></pre><p>更多host管理信息请参考：<a href="http://docs.opennebula.org/4.14/administration/hosts_and_clusters/host_guide.html#sync" target="_blank" rel="external">host_guide</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OpenNebula-Virtual-Machine-Life-cycle&quot;&gt;&lt;a href=&quot;#OpenNebula-Virtual-Machine-Life-cycle&quot; class=&quot;headerlink&quot; title=&quot;OpenNebula Virtual Machine Life-cycle&quot;&gt;&lt;/a&gt;OpenNebula Virtual Machine Life-cycle&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://docs.opennebula.org/4.14/_images/states-simple.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体状态详情请参考：&lt;a href=&quot;http://docs.opennebula.org/4.14/user/virtual_resource_management/vm_guide_2.html&quot;&gt;vm_guide_2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="opennebula" scheme="http://yoursite.com/tags/opennebula/"/>
    
  </entry>
  
  <entry>
    <title>Ansible基础知识备忘</title>
    <link href="http://yoursite.com/2016/05/20/ansible/"/>
    <id>http://yoursite.com/2016/05/20/ansible/</id>
    <published>2016-05-20T08:25:38.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、体系结构"><a href="#一、体系结构" class="headerlink" title="一、体系结构"></a>一、体系结构</h3><p>ansible是一款基于python开发，揉合了众多自动化运维工具功能的轻量级自动化运维工具，目前实现了除系统安装以外的批量系统配置、批量任务执行及批量程序部署等功能。</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/25.png" alt=""></p>
<ul>
<li>Inventory：主机库，定义可控制的主机</li>
<li>Modules：基于模块化设计，通过模块来实现批量部署</li>
<li>playbook：剧本，使用YAML编写的声明性的配置文件</li>
<li>plugins: 插件，完成日志记录、邮件等功能</li>
</ul>
<h3 id="二、-特点"><a href="#二、-特点" class="headerlink" title="二、 特点"></a>二、 特点</h3><ul>
<li>高度模块化，借助模块完成各种任务</li>
<li>agentless，无需在被控制端安装agent</li>
<li>默认基于ssh协议向被控制端发送操作指令<ul>
<li>基于密钥认证</li>
<li>在inventory文件中指定账号和密码</li>
</ul>
</li>
<li>批量任务执行可写成剧本playbook</li>
<li>幂等性：不会重复执行相同操作</li>
</ul>
<h3 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h3><h4 id="3-1-ssh免密钥登录"><a href="#3-1-ssh免密钥登录" class="headerlink" title="3.1 ssh免密钥登录"></a>3.1 ssh免密钥登录</h4><pre><code># ssh-keygen -t rsa -P &apos;&apos;  
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.249.6.64
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.48.156.8
</code></pre><h4 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h4><p>ansible-doc</p>
<pre><code>Options:

-l, --list            List available modules  //列出所有模块
-s, --snippet         Show playbook snippet for specified module(s) //查看指定模块用法

更多信息请参考manual手册
</code></pre><p>ansible</p>
<p> ansible <host-pattern>  [-f forks][-m module_name] [-a args] [options]</host-pattern></p>
<pre><code>Options:

  -a MODULE_ARGS, --args=MODULE_ARGS
                    module arguments   // 传递模块参数
  -f FORKS, --forks=FORKS  // 指定并发数
                    specify number of parallel processes to use
                    (default=5)
  -i INVENTORY, --inventory-file=INVENTORY 
                    specify inventory host file
                    (default=/etc/ansible/hosts)    
  -m MODULE_NAME, --module-name=MODULE_NAME
                    module name to execute (default=command)   

 更多信息请参考manual手册        
</code></pre><p>ansible-playbook  </p>
<p>ansible-playbook <filename.yml> … [options]             </filename.yml></p>
<h3 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h3><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>命令模块: ansible默认模块，用于在远程执行命令，command模块并不支持shell变量和管道等，若想使用shell来执行，应使用shell模块。</p>
<pre><code># ansible-doc -l | grep ^command
command              Executes a command on a remote node                        

# ansible 10.249.6.64 -m command -a &quot;date&quot;
10.249.6.64 | success | rc=0 &gt;&gt;
Wed May 11 21:21:35 CST 2016                        
</code></pre><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping模块：测试指定主机是否能连接</p>
<pre><code># ansible-doc -l | grep  -w ^ping
ping                 Try to connect to host and return `pong&apos; on success.                  

# ansible 10.249.6.64 -m ping
10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
</code></pre><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>计划任务模块 ：管理计划任务</p>
<pre><code># ansible-doc -l | grep  ^cron
cron                 Manage cron.d and crontab entries.

# ansible-doc  -s cron
- name: Manage cron.d and crontab entries.
action: cron
  backup                 # If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup&apos; variable by this module.
  cron_file              # If specified, uses this file in cron.d instead of an individual user&apos;s crontab.
  day                    # Day of the month the job should run ( 1-31, *, */2, etc )
  hour                   # Hour when the job should run ( 0-23, *, */2, etc )
  job                    # The command to execute. Required if state=present.
  minute                 # Minute when the job should run ( 0-59, *, */2, etc )
  month                  # Month of the year the job should run ( 1-12, *, */2, etc )
  name                   # Description of a crontab entry.
  reboot                 # If the job should be run at reboot. This option is deprecated. Users should use special_time.
  special_time           # Special time specification nickname.
  state                  # Whether to ensure the job is present or absent.
  user                   # The specific user who&apos;s crontab should be modified.
  weekday                # Day of the week that the job should run ( 0-7 for Sunday - Saturday, *, etc )        

# ansible 10.249.6.64 -m cron -a &apos;name=&quot;sync time&quot; minute=&quot;*/10&quot; \ 
job=&quot;/usr/sbin/ntpdate 0.centos.pool.ntp.org &amp;&amp; hwclock -w&quot; &apos;

10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: true,
    &quot;jobs&quot;: [
    &quot;sync time&quot;
    ]
}                   
</code></pre><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>用户模块：管理用户账户</p>
<pre><code># ansible-doc -l | grep ^user
user                 Manage user accounts  

# ansible 10.249.6.64 -m user -a &apos;name=work shell=/bin/bash home=/home/www&apos;   //添加用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;comment&quot;: &quot;&quot;,
&quot;createhome&quot;: true,
&quot;group&quot;: 500,
&quot;home&quot;: &quot;/home/www&quot;,
&quot;name&quot;: &quot;work&quot;,
&quot;shell&quot;: &quot;/bin/bash&quot;,
&quot;state&quot;: &quot;present&quot;,
&quot;system&quot;: false,
&quot;uid&quot;: 500
}        

# ansible 10.249.6.64 -m user -a &apos;name=work state=absent&apos;  // 删除用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;force&quot;: false,
&quot;name&quot;: &quot;work&quot;,
&quot;remove&quot;: false,
&quot;state&quot;: &quot;absent&quot;
}             
</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy模块：文件复制</p>
<pre><code>#  ansible-doc -l | grep ^copy
copy                 Copies files to remote locations. 

# ansible-doc -s copy
- name: Copies files to remote locations.
action: copy
  backup                 # Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
  content                # When used instead of &apos;src&apos;, sets the contents of a file directly to the specified value.
  dest=                  # Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.
  directory_mode         # When doing a recursive copy set the mode for the directories. If this is not set we will default the system defaults.
  force                  # the default is `yes&apos;, which will replace the remote file when contents are different than the source.  If `no&apos;, the file will only be transferred if the destination does not exist.
  src                    # Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with &quot;/&quot;, only inside contents of that directory are copied to destination. Otherwise, if it does not end with &quot;/&quot;, the directory itself with all contents is copied. This behavior is similar to Rsync.
  validate               # The validation command to run before copying into place.  The path to the file to validate is passed in via &apos;%s&apos; which must be present as in the visudo example below. The command is passed securely so shell features like expansion and pipes won&apos;t work.

# ansible 10.249.6.64 -m copy -a &quot;src=/root/test.txt dest=/tmp/&quot;
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;dest&quot;: &quot;/tmp/test.txt&quot;,
&quot;gid&quot;: 0,
&quot;group&quot;: &quot;root&quot;,
&quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;,
&quot;mode&quot;: &quot;0644&quot;,
&quot;owner&quot;: &quot;root&quot;,
&quot;size&quot;: 0,
&quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1463662606.99-26627840524349/source&quot;,
&quot;state&quot;: &quot;file&quot;,
&quot;uid&quot;: 0
}   
# ansible 10.249.6.64 -m copy -a &quot;content=&apos;hello world&apos; dest=/tmp/test.txt&quot;
# ansible 10.249.6.64 -m copy -a &apos;src=/root/test.txt dest=/tmp/test.txt owner=evans group=evans mode=600 backup=yes&apos;
</code></pre><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file模块：文件模块，设置文件属性</p>
<pre><code># ansible-doc -l | grep -w ^file
file                 Sets attributes of files   
# ansible 10.249.6.64 -m file -a &quot;src=/tmp/test.txt path=/tmp/test.link state=link&quot;
# ansible 10.249.6.64 -m file -a &quot;owner=evans group=evans mode=600 path=/tmp/test.txt&quot;
</code></pre><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service模块： 服务模块，管理系统服务</p>
<pre><code># ansible-doc -l | grep ^service
service              Manage services.
# ansible-doc -s service
 - name: Manage services.
 action: service
  arguments              # Additional arguments provided on the command line
  enabled                # Whether the service should start on boot. *At least one of state and enabled are required.*
  name=                  # Name of the service.
  pattern                # If the service does not respond to the status command, name a substring to look for as would be found in the output of the `ps&apos; command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.
  runlevel               # For OpenRC init scripts (ex: Gentoo) only.  The runlevel that this service belongs to.
  sleep                  # If the service is being `restarted&apos; then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.
  state                  # `started&apos;/`stopped&apos; are idempotent actions that will not run commands unless necessary.  `restarted&apos; will always bounce the service.  `reloaded&apos; will always reload. *At least one of state and enabled are required.*
  # ansible 10.249.6.64 -m service -a &quot;name=mysqld state=restarted enabled=true&quot;  //重启mysql服务并设置开机自启动
</code></pre><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell模块：远程执行命令</p>
<pre><code># ansible 10.249.6.64 -m shell -a &apos;date&apos;
10.249.6.64 | success | rc=0 &gt;&gt;
Thu May 19 21:20:51 CST 2016    
</code></pre><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>script模块：脚本模块，远程主机运行脚本</p>
<pre><code># ansible-doc  -l | grep ^script
script               Runs a local script on a remote node after transferring it..
# ansible 10.249.6.64 -m script -a &apos;/root/test.sh&apos;  //在远程主机上运行脚本，并没有拷贝到指定目录
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;rc&quot;: 0,
&quot;stderr&quot;: &quot;&quot;,
&quot;stdout&quot;: &quot;&quot;
}   
</code></pre><h4 id="yum、apt"><a href="#yum、apt" class="headerlink" title="yum、apt"></a>yum、apt</h4><p>yum模块和apt模块：包管理模块</p>
<pre><code>yum                  Manages packages with the `yum&apos; package manager
apt                  Manages apt-packages
# ansible 10.249.6.64 -m yum -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=absent&quot;
</code></pre><blockquote>
<p> state<br> Whether to install (<code>present&#39;,</code>latest’), or remove (`absent’) a package.</p>
</blockquote>
<h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup模块：收集主机信息，playbook运行时，会自动调用setup模块收集远程主机的相关信息（称为facts，如操作系统版本、ip地址、cpu数量等），这些信息保存于变量中，可在playbook中引用</p>
<pre><code># ansible-doc -l | grep  setup
setup                Gathers facts about remote hosts
# ansible-doc -s setup
- name: Gathers facts about remote hosts
 action: setup
  fact_path              # path used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. File/results format can be json or ini-format
  filter                 # if supplied, only return facts that match this shell-style (fnmatch) wildcard.
# ansible 10.249.6.43 -m setup
# ansible 10.249.6.43 -m setup -a &apos;filter=ansible_eth0&apos;   //过滤信息
# ansible 10.249.6.64 -m setup --tree /tmp/test.txt  //将收集的信息输出到本地文件
</code></pre><p>更多模块信息请查看：<a href="http://docs.ansible.com/ansible/list_of_all_modules.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="五、playbook"><a href="#五、playbook" class="headerlink" title="五、playbook"></a>五、playbook</h3><h4 id="5-1-YAML"><a href="#5-1-YAML" class="headerlink" title="5.1 YAML"></a>5.1 YAML</h4><p>YAML是一种可读性高的用来表达资料序列的语言，其语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。</p>
<p>所有的yaml文件都以”—“开头表示开始一个document，所有的列表元素以”-“开头，键值对用”:”，后面必须有空格。YAML文件扩展名通常为.yaml或.yml</p>
<h4 id="5-2-playbook简介"><a href="#5-2-playbook简介" class="headerlink" title="5.2 playbook简介"></a>5.2 playbook简介</h4><p>playbook是ansible管理配置、部署应用和编排的文件，可用来描述在远程主机上执行的策略或一组任务。</p>
<p>一个playbook文件由一个或多个play组成，每个play定义了在一个或多个远程主机上执行的一系列的task，其中每个task一般就是调用一个ansible的模块。</p>
<p>playbook使用YAML语言编写，文件名以.yaml或.yml结尾。此外playbook和模板文件（template）还可使用jinja2语法语法实现高级功能。</p>
<p>5.2.1 playbook的基本组成</p>
<ul>
<li>targets：指定要执行playbook的远程主机组</li>
<li>variables：定义playbook运行时需要使用的变量</li>
<li>tasks：要执行的任务</li>
<li>handlers：处理器，在某些条件下被触发的操作</li>
</ul>
<p>简单playbook示例：</p>
<pre><code># cat nginx.yml
---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started

  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
# ansible-playbook  nginx.yml   // 执行playbook
</code></pre><ul>
<li>hosts、user</li>
</ul>
<p>hosts用于指定要执行指定任务的主机，其可以是一个或多个由逗号分隔主机组；user则用于指定远程主机上的执行任务的用户，还能使用sudo</p>
<ul>
<li>task list、action</li>
</ul>
<p>task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可。</p>
<p> task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致。</p>
<p> 每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出。</p>
<p>定义task的可以使用“action: module options”或“module: options”的格式，推荐使用后者以实现向后兼容例如：</p>
<pre><code>tasks:
- name: make sure apache is running
  service: name=httpd state=running
</code></pre><p> 在众多模块中，只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式，例如：</p>
<pre><code>tasks:
- name: disable selinux
  command: /sbin/setenforce 0
</code></pre><p>shell模块执行多条命令       </p>
<pre><code>---
- name: update zabbix agent conf
shell: |     
   sed  -i &quot;/Hostname/d&quot; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf
   wget -O /tmp/hostinfo.txt http://10.126.93.2/bak/hostinfo.txt
   IP=`ifconfig | egrep -A1 eth[0-9] | egrep  -o  addr:[0-9]+.[0-9]+.[0-9]+.[0-9]+ | awk -F: &apos;{print $2}&apos;`
   USE=`egrep -w  $IP /tmp/hostinfo.txt | awk &apos;{print $2}&apos;| uniq`
   HOST=`hostname | awk -F . &apos;{print $1}&apos;`
   echo &quot;Hostname=${USE}${HOST}&quot; &gt;&gt; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf   
</code></pre><p>如果模块执行返回值不为零，即表示执行失败，任务会立即中止，后续任务不再执行。可以使用ignore_errors来忽略错误信息确保后续任务的执行。</p>
<pre><code>tasks:
   - name: run this command and ignore the result
     shell: /usr/bin/somecommand
     ignore_errors: yes
</code></pre><ul>
<li>handlers</li>
</ul>
<p>当关注的资源发生变化时触发一定的操作。handler是task列表，这些task与前述的task并没有本质上的不同。</p>
<p>“notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，取而代之，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。       </p>
<pre><code>- name: template configuration file
  template: src=/root/template.conf dest=/etc/template.conf

notify:
  - restart memcached
  - restart apache

handlers:
- name: restart memcached
  service: name=memcached state=restarted
- name: restart apache
  service: name=apache state=restarted
</code></pre><ul>
<li>vars</li>
</ul>
<p>变量名仅能由字母、数字和下划线组成，且只能以字母开头  </p>
<ul>
<li>when </li>
</ul>
<p>条件判断：如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提，这时就要用到条件判断。</p>
<pre><code>when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;

when: ansible_distribution == &apos;CentOS&apos; or ansible_distribution == &apos;RedHat&apos; and ansible_distribution_version|int &gt;=6
</code></pre><p>忽略此前某语句的错误并基于其结果（failed或者sucess）运行后面指定的语句:</p>
<pre><code>---
- hosts: 10.249.6.64
  user: root
  tasks:
    - name: false test
      command: /bin/false
      register: result
      ignore_errors: yes
    - name: when false  to do
      command: touch /tmp/1.txt
      when: result | failed
    - name: when success to do
      command: touch /tmp/2.txt
      when: result | success
    - name: when skip to do
      command: touch /tmp/3.txt
      when: result | skipped
</code></pre><ul>
<li>item</li>
</ul>
<p>item 迭代：当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可</p>
<pre><code>- name: install base software
  apt: pkg={{ item }} state=present force=yes
  with_items:
    - gcc
    - g++
    - mysql-client-5.5
    - libmcrypt-dev
    - libmysqlclient-dev
    - libgmp10
    - vim
    - openssh-client
    - ethtool
when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;
</code></pre><ul>
<li>tag</li>
</ul>
<p>tag标签：让用户选择运行playbook中的某个或某些任务。虽然ansible具有幂等性，会跳过没有变化的部分，有些代码为测试其确实没有发生变化，也会耗费很长时间。我们将playbook中的指定任务打上标签，在运行playbook时指定标签名称，这样就不用运行全部代码了。</p>
<pre><code>---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started
  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
    # ansible-playbook nginx.yml -t conf   // 只执行tags部分
</code></pre><h3 id="六、roles"><a href="#六、roles" class="headerlink" title="六、roles"></a>六、roles</h3><p>roles 用于层次性、结构化地组织playbook。</p>
<p>roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p>
<pre><code># ls
deploy_hosts  deploy.yml  roles  run.sh
# cat deploy_hosts   //主机或主机组列表
[web]
10.126.83.30
10.126.93.83
[db]
10.126.87.150
10.126.92.89
# cat deploy.yml  // 总的playbook 调用roles
---
- name: init for os
  hosts: web
  user: root
  gather_facts: True
  roles:
    - init
    - raid
- name: init for os
  hosts: db
  user: root
  gather_facts: True
  roles:
    - init
    - raid
    - db_init

# cat run.sh  // 运行playbook脚本
#!/bin/bash
/usr/bin/ansible-playbook -i ./deploy_hosts deploy.yml
# ls roles/
db_init   init    raid 
</code></pre><p>在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录，用不到的目录可以创建为空目录，也可以不创建。</p>
<p>role内各目录中可用的文件:</p>
<ul>
<li><p>tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件</p>
</li>
<li><p>files目录：存放由copy或script等模块调用的静态文件</p>
</li>
<li><p>templates目录：template模块会自动在此目录中寻找Jinja2模板文件</p>
</li>
<li><p>handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；此文件可以使用include包含其它的位于此目录中的handler文件</p>
</li>
<li><p>vars目录：至少有一个main.yml文件，用于定义此角色用到的变量</p>
</li>
<li><p>meta目录：至少有一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持</p>
</li>
<li><p>default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件</p>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://9124573.blog.51cto.com/9114573/1769887" target="_blank" rel="external">轻量级自动化运维工具ansible</a></p>
<p><a href="http://docs.ansible.com/ansible/intro.html" target="_blank" rel="external">ansible doc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、体系结构&quot;&gt;&lt;a href=&quot;#一、体系结构&quot; class=&quot;headerlink&quot; title=&quot;一、体系结构&quot;&gt;&lt;/a&gt;一、体系结构&lt;/h3&gt;&lt;p&gt;ansible是一款基于python开发，揉合了众多自动化运维工具功能的轻量级自动化运维工具，目前实现了除系
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix工作模式</title>
    <link href="http://yoursite.com/2016/05/18/zabbix-agent/"/>
    <id>http://yoursite.com/2016/05/18/zabbix-agent/</id>
    <published>2016-05-18T10:03:31.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Zabbix uses a JSON based communication protocol for communicating with Zabbix agent.</p>
</blockquote>
<p>zabbix agent通信过程中的协议均基于json格式。主动模式和被动模式是相对于agent来说的。agent主动发送数据给server即为主动模式。</p>
<h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h3><p>server向agent请求获取监控项的数据，agent返回数据。</p>
<blockquote>
<p>A passive check is a simple data request. Zabbix server or proxy asks for some data (for example, CPU load) and Zabbix agent sends back the result to the server.</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Server 发起请求：</p>
<pre><code>&lt;item key&gt;\n
</code></pre><p>Agent 返回响应数据：</p>
<pre><code>&lt;HEADER&gt;&lt;DATALEN&gt;&lt;DATA&gt;
</code></pre><p>server发送request给agent，agent收到request后本地执行相关检测收集到数据之后，发送数据到server端， 以agent.ping key 值为例具体工作流程如下：</p>
<p>1.Server opens a TCP connection</p>
<p>2.Server sends agent.ping\n</p>
<p>3.Agent reads the request and responds with <header><datalen></datalen></header></p>
<p>4.Server processes data to get the value, ‘1’ in our case</p>
<p>5.TCP connection is closed</p>
<h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h3><blockquote>
<p>Active checks require more complex processing. The agent must first retrieve from the server(s) a list of items for independent processing.</p>
<p>The servers to get the active checks from are listed in the ‘ServerActive’ parameter of the agent configuration file. The frequency of asking for these checks is set by the ‘RefreshActiveChecks’ parameter in the same configuration file. However, if refreshing active checks fails, it is retried after hardcoded 60 seconds. The agent then periodically sends the new values to the server(s).</p>
</blockquote>
<p>主动模式的工作流程要比被动模式的复杂一些，zabbix客户端代理（Agent）首先必须从服务器获取监控项列表来进行独立处理，然后它将定期发送新数据给服务器。</p>
<p>Part1: Getting the list of items</p>
<ol>
<li><p>Agent opens a TCP connection</p>
</li>
<li><p>Agent asks for the list of checks</p>
</li>
<li><p>Server responds with a list of items (item key, delay)</p>
</li>
<li><p>Agent parses the response</p>
</li>
<li><p>TCP connection is closed</p>
</li>
<li><p>Agent starts periodical collection of data</p>
</li>
</ol>
<p>Part2: agent send values</p>
<ol>
<li>Agent opens a TCP connection</li>
<li>Agent sends a list of values</li>
<li>Server processes the data and sends the status back</li>
<li>TCP connection is closed</li>
</ol>
<p>当使用被动式的时候，server和agent之间需要对每个item的检测建立一次tcp连接。 如果检测的item和agent过多的时候，对server端的性能是一个很大的考验，所以当agent 和items 数量增多时可以根据实际情况设置工作模式。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zabbix.com/documentation/2.2/manual/appendix/items/activepassive#passive_checks" target="_blank" rel="external">zabbix doc </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Zabbix uses a JSON based communication protocol for communicating with Zabbix agent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;zabbix agent通信过程中的
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="zabbix agent" scheme="http://yoursite.com/tags/zabbix-agent/"/>
    
  </entry>
  
  <entry>
    <title>nc小知识</title>
    <link href="http://yoursite.com/2016/05/05/nc/"/>
    <id>http://yoursite.com/2016/05/05/nc/</id>
    <published>2016-05-05T13:18:40.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="远程拷贝文件"><a href="#远程拷贝文件" class="headerlink" title="远程拷贝文件"></a>远程拷贝文件</h3><p>server1: 10.48.156.8</p>
<p>server2: 10.249.6.43</p>
<p><strong>从server1拷贝文件到server2</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -lp 1234 &gt; file.txt
</code></pre><blockquote>
<p>-l：使用监听模式，监控传入的资料</p>
<p>-p &lt;通信端口&gt;：设置本地主机使用的通信端口</p>
</blockquote>
<p>然后server1上运行：</p>
<pre><code># ll file.txt
-rw-r--r-- 1 root root 35 May  5 20:43 file.txt
# nc 10.249.6.43  1234 &lt; file.txt
</code></pre><h3 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h3><p><strong>从server1拷贝MySQL-python-1.2.3目录内容到server2上</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -l 1234 | tar xzvf -
</code></pre><p>然后server1上运行：</p>
<pre><code># ll -d MySQL-python-1.2.3
drwxrwxr-x 3 500 500 4096 Jan  3 18:13 MySQL-python-1.2.3
# tar czvf - MySQL-python-1.2.3 | nc 10.249.6.43 1234
</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><pre><code># nc localhost -z 22   //扫描本机端口
Connection to localhost 22 port [tcp/ssh] succeeded!
# nc 10.126.93.2 -z 80  //扫描远程机器端口
Connection to 10.126.93.2 80 port [tcp/http] succeeded!
# nc -v 10.126.93.2 -z 1-100  //指示扫描过程    
</code></pre><blockquote>
<p>-v：显示指令执行过程</p>
<p>-z：使用0输入/输出模式，只在扫描通信端口时使用</p>
<p>-w &lt;超时秒数&gt;：设置等待连线的时间</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;远程拷贝文件&quot;&gt;&lt;a href=&quot;#远程拷贝文件&quot; class=&quot;headerlink&quot; title=&quot;远程拷贝文件&quot;&gt;&lt;/a&gt;远程拷贝文件&lt;/h3&gt;&lt;p&gt;server1: 10.48.156.8&lt;/p&gt;
&lt;p&gt;server2: 10.249.6.43&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Cmd" scheme="http://yoursite.com/categories/Cmd/"/>
    
    
      <category term="nc" scheme="http://yoursite.com/tags/nc/"/>
    
  </entry>
  
  <entry>
    <title>OpenNebula 4.14 快速入门</title>
    <link href="http://yoursite.com/2016/04/23/opennebula/"/>
    <id>http://yoursite.com/2016/04/23/opennebula/</id>
    <published>2016-04-23T14:17:53.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、OpenNebula简介"><a href="#一、OpenNebula简介" class="headerlink" title="一、OpenNebula简介"></a>一、OpenNebula简介</h3><ul>
<li>1.1 云管理平台的选择</li>
<li>1.2 OpenNebula体系结构</li>
<li>1.3 OpenNebula组件介绍</li>
</ul>
<h3 id="二、OpenNebula安装配置"><a href="#二、OpenNebula安装配置" class="headerlink" title="二、OpenNebula安装配置"></a>二、OpenNebula安装配置</h3><ul>
<li>2.1 环境说明</li>
<li>2.2 软件包组成</li>
<li>2.3 Server端安装和配置</li>
<li>2.4 节点端安装配置</li>
</ul>
<h3 id="三、节点添加"><a href="#三、节点添加" class="headerlink" title="三、节点添加"></a>三、节点添加</h3><ul>
<li>3.1 web界面添加主机</li>
<li>3.2 命令行添加主机<ul>
<li>3.2.1 onehost 命令</li>
</ul>
</li>
</ul>
<h3 id="四、制作系统镜像"><a href="#四、制作系统镜像" class="headerlink" title="四、制作系统镜像"></a>四、制作系统镜像</h3><ul>
<li>4.1 qemu-img命令</li>
<li>4.2 qemu-kvm（ kvm ）命令</li>
<li>4.3 系统优化</li>
</ul>
<h3 id="五、导入镜像"><a href="#五、导入镜像" class="headerlink" title="五、导入镜像"></a>五、导入镜像</h3><ul>
<li>5.1 web界面导入映像</li>
<li>5.2 命令行导入映像<ul>
<li>5.2.1 oneimg 命令</li>
</ul>
</li>
</ul>
<h3 id="六、虚拟网络"><a href="#六、虚拟网络" class="headerlink" title="六、虚拟网络"></a>六、虚拟网络</h3><ul>
<li>6.1 web界面添加虚拟网络</li>
<li>6.2 命令行添加虚拟网络<ul>
<li>6.2.1 onevnet 命令</li>
</ul>
</li>
</ul>
<h3 id="七、制作模板"><a href="#七、制作模板" class="headerlink" title="七、制作模板"></a>七、制作模板</h3><ul>
<li>7.1 web 界面制作模板</li>
<li>7.2 Context初始化功能<ul>
<li>7.2.1 修改母盘镜像</li>
</ul>
</li>
</ul>
<h3 id="八、创建虚拟机"><a href="#八、创建虚拟机" class="headerlink" title="八、创建虚拟机"></a>八、创建虚拟机</h3><ul>
<li>8.1 web界面创建虚拟机 </li>
</ul>
<h2 id="一、OpenNebula简介-1"><a href="#一、OpenNebula简介-1" class="headerlink" title="一、OpenNebula简介"></a>一、OpenNebula简介</h2><h3 id="1-1-云管理平台的选择"><a href="#1-1-云管理平台的选择" class="headerlink" title="1.1 云管理平台的选择"></a>1.1 云管理平台的选择</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/5BA41662-3FBA-42C6-928C-4EB8B665BD4C.png" alt=""></p>
<p><strong>OpenNebula</strong></p>
<p>OpenNebula是一款功能丰富且灵活性非常强的解决方案，用于构建和管理企业云及数据中心虚拟化。OpenNebula支持Xen、KVM、VMware ESX虚拟化引擎，可以一起混合建立和管理私有云，同时还提供了Deltacloud适配器和Amazon EC2的API兼容。官方网站 <a href="http://opennebula.org/。" target="_blank" rel="external">http://opennebula.org/。</a></p>
<h3 id="1-2-OpenNebula体系结构"><a href="#1-2-OpenNebula体系结构" class="headerlink" title="1.2 OpenNebula体系结构"></a>1.2 OpenNebula体系结构</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/039ED6D4-843B-4C7C-827E-88D680082A58.png" alt=""></p>
<h3 id="1-3-OpenNebula组件介绍"><a href="#1-3-OpenNebula组件介绍" class="headerlink" title="1.3 OpenNebula组件介绍"></a>1.3 OpenNebula组件介绍</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C7012638-A918-4D89-815C-15BAEAB2E735.png" alt=""></p>
<p><strong>Front-End（前端）</strong></p>
<p>用于运行OpenNebula服务。包含了诸多功能组件，如OpenNebula管理进程oned、调度器mm_sched、一个Web接口服务sunstone-server。</p>
<p><strong>Host（宿主机）</strong></p>
<p>用于运行所有虚拟机</p>
<p><strong>Datastores（数据存储）</strong></p>
<p>用于实际存放虚拟机的硬盘，可以是任意一种存储介质，NAS（网络附加存储）、SAN（存储区域网络）、直连存储设备（宿主机本地硬盘）。<br>数据存储可以细分为三大类：</p>
<ul>
<li>系统数据存储</li>
<li>镜像数据存储</li>
<li>文件数据存储</li>
</ul>
<p><strong>Network（网络）</strong></p>
<h2 id="二、OpenNebula安装配置-1"><a href="#二、OpenNebula安装配置-1" class="headerlink" title="二、OpenNebula安装配置"></a>二、OpenNebula安装配置</h2><h3 id="2-1-环境说明"><a href="#2-1-环境说明" class="headerlink" title="2.1 环境说明"></a>2.1 环境说明</h3><p>系统环境：ubuntu 14.04</p>
<p>OpenNebula版本：4.14</p>
<h3 id="2-2-软件包组成"><a href="#2-2-软件包组成" class="headerlink" title="2.2 软件包组成"></a>2.2 软件包组成</h3><p>从官网下载源码包或使用OpenNebula源，添加 OpenNebula 源方法如下:</p>
<pre><code># wget -q -O- http://downloads.opennebula.org/repo/Ubuntu/repo.key | apt-key add -
# echo &quot;deb http://downloads.opennebula.org/repo/4.14/Ubuntu/14.04/ stable opennebula&quot; \
&gt; /etc/apt/sources.list.d/opennebula.list
</code></pre><p>OpenNebula主要由以下软件包组成：</p>
<ul>
<li>opennebula-common  Provides the user and common files</li>
<li>ruby-opennebula: All ruby libraries</li>
<li>opennebula-node: Prepares a node as an opennebula-node</li>
<li>opennebula-sunstone: OpenNebula Sunstone Web Interface</li>
<li>opennebula-tools: Command Line interface</li>
<li>opennebula-gate: Gate server that enables communication between VMs and OpenNebula</li>
<li>opennebula-flow: Manages services and elasticity</li>
<li>libopennebula-java: Java Language bindings for OpenNebula API</li>
<li>opennebula: OpenNebula Daemon</li>
<li>libopennebula-java: Java Language bindings for OpenNebula API</li>
</ul>
<h3 id="2-3-Server端安装和配置"><a href="#2-3-Server端安装和配置" class="headerlink" title="2.3 Server端安装和配置"></a>2.3 Server端安装和配置</h3><p>上文已经配置好了OpenNebula 的源,安装方法如下:</p>
<pre><code># apt-get install opennebula opennebula-sunstone -y
</code></pre><p>安装完成之后检查创建的用户以及目录文件：</p>
<pre><code># grep oneadmin /etc/passwd
oneadmin:x:9869:9869::/var/lib/one:/bin/bash
# ls -ld /etc/one/
drwxr-xr-x 8 root root 4096 Apr 23 16:22 /etc/one/
# ls /etc/init.d/opennebula*
/etc/init.d/opennebula        /etc/init.d/opennebula-novnc
/etc/init.d/opennebula-econe  /etc/init.d/opennebula-sunstone
# ls -ld /var/log/one/
drwxr-xr-x 2 oneadmin oneadmin 4096 Apr 23 16:22 /var/log/one/
</code></pre><p>默认 OpenNebula 使用数据库为sqlite,如果需要使用 MySQL,则需要做如下操作:</p>
<p>1.创建opennebula数据库</p>
<pre><code>mysql&gt; create database opennebula;
Query OK, 1 row affected (0.00 sec)

mysql&gt; grant all privileges on opennebula.* to oneadmin@&apos;localhost&apos; identified by &apos;oneadmin&apos;;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)
</code></pre><p>2.修改配置文件</p>
<pre><code># vi /etc/one/oned.conf
......
#DB = [ backend = &quot;sqlite&quot; ]
# Sample configuration for MySQL 

DB = [ backend = &quot;mysql&quot;,
   server  = &quot;localhost&quot;,
   port    = 3306,
   user    = &quot;oneadmin&quot;,
   passwd  = &quot;oneadmin&quot;,
   db_name = &quot;opennebula&quot; ]
......
</code></pre><p>修改 sunstone 默认监听 IP:</p>
<pre><code># grep &apos;:host&apos; /etc/one/sunstone-server.conf
:host: 127.0.0.1
# sed -i &apos;/:host/s/127.0.0.1/10.249.7.247/g&apos; /etc/one/sunstone-server.conf
# grep &apos;:host&apos; /etc/one/sunstone-server.conf
:host: 10.249.7.247
</code></pre><p>启动相关服务:</p>
<pre><code># /etc/init.d/opennebula start
# /etc/init.d/opennebula-sunstone  start
# lsof -i:9869
COMMAND   PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ruby    15387 oneadmin    8u  IPv4  50024      0t0  TCP 10.249.7.247:9869 (LISTEN)
</code></pre><p>修改datastore：</p>
<p>OpenNebula 默认用的是 Shared Transfer Driver,这种模式比较适合快速部署和热迁移,但是要配置网络文件系统。由于我们这里并没有配置网络文件系统,暂时也无法做热迁移,那么可以换成 SSH Transfer Driver 测试部署。</p>
<pre><code># onedatastore list
ID NAME                SIZE AVAIL CLUSTER      IMAGES TYPE DS      TM      STAT
0 system                0M -     -                 0 sys  -       shared  on
1 default             2.6T 95%   -                 0 img  fs      shared  on
2 files               2.6T 95%   -                 0 fil  fs      ssh     on
# onedatastore update 1
BASE_PATH=&quot;/var/lib/one//datastores/&quot;
CLONE_TARGET=&quot;SYSTEM&quot;
DISK_TYPE=&quot;FILE&quot;
DS_MAD=&quot;fs&quot;
LN_TARGET=&quot;SYSTEM&quot;
TM_MAD=&quot;ssh&quot;
TYPE=&quot;IMAGE_DS&quot;
# onedatastore list
ID NAME                SIZE AVAIL CLUSTER      IMAGES TYPE DS      TM      STAT
0 system                0M -     -                 0 sys  -       shared  on
1 default             2.6T 95%   -                 0 img  fs      ssh     on
2 files               2.6T 95%   -                 0 fil  fs      ssh     on
</code></pre><p>浏览器登陆测试: </p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/03030E96-598A-479F-9043-722559F20579.png" alt=""></p>
<p>用户名和密码通过以下方式获得:</p>
<pre><code># cat /var/lib/one/.one/one_auth
oneadmin:EcvubryacOv9
</code></pre><h3 id="2-4-节点端安装配置"><a href="#2-4-节点端安装配置" class="headerlink" title="2.4 节点端安装配置"></a>2.4 节点端安装配置</h3><p>opennebula的源的配置见Server端安装配置章节，节点端软件包安装如下：</p>
<pre><code># apt-get install opennebula-node  bridge-utils -y
</code></pre><p>安装过程同时会安装虚拟化相关组件,包括 bridge-utils、libvirt、 kvm、qemu-img 等。</p>
<p>网络配置：</p>
<p>eth0 为管理网口，eth1 为trunk口用作虚拟机通信，需要创建桥接网口。官方文档中提示需要手动创建桥接网络，但是本人在实际使用中通过web管理平台的虚拟网络可以实现自动绑定br0 到eth1网卡上。</p>
<pre><code># cat /etc/network/interfaces
auto lo
iface lo inet loopback
auto eth0
iface eth0 inet static
address 10.249.7.247
netmask 255.255.255.0
gateway 10.249.7.254
auto eth1
iface eth1 inet manual
# brctl show
bridge name bridge id       STP enabled interfaces
virbr0      8000.000000000000   yes
</code></pre><p>查看qemu的配置：</p>
<pre><code># cat /etc/libvirt/qemu.conf
user  = &quot;oneadmin&quot;
group = &quot;oneadmin&quot;
dynamic_ownership = 0
</code></pre><p>启动libvirt服务：</p>
<pre><code># service libvirt-bin restart
</code></pre><p>ssh 无密码登陆:</p>
<p>管理端：</p>
<pre><code># su - oneadmin
$ cat &lt;&lt; EOT &gt; ~/.ssh/config    //不询问直接添加主机到known_hosts文件
Host *
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
EOT
$ chmod 600 ~/.ssh/config
</code></pre><p>节点端：</p>
<pre><code>￼# su - oneadmin
$ vim  ~/.ssh/authorized_key   //把管理端ssh公钥加入节点.ssh/authorized_keys文件
$ chmod 400 .ssh/authorized_keys
</code></pre><h2 id="三、节点添加-1"><a href="#三、节点添加-1" class="headerlink" title="三、节点添加"></a>三、节点添加</h2><p>节点配置完成之后便可以在 Server 端添加了,可以使用web 添加,也可以在命令行中添加。</p>
<h3 id="3-1-web界面添加主机"><a href="#3-1-web界面添加主机" class="headerlink" title="3.1 web界面添加主机"></a>3.1 web界面添加主机</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/907F38A5-3CA1-4424-8867-BA815E3EE4D6.png" alt=""></p>
<p>创建主机,主机名一栏可以是IP也可以是可以解析的主机域名,这里使用的是IP</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/7250BDBA-1EAE-4750-9C93-5BD3D29A7263.png" alt=""></p>
<p>如上图选择完之后,点击创建按钮就可以出现如下主机,状态为初始化</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/02DF2945-100E-4846-8D66-297B86D3A8BD.png" alt=""></p>
<p>如果一切正常,等待片刻则状态就会变为开机,也会显示主机CPU和内存信息,如下图:</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/44D05DBE-D2D4-450B-BFC0-61E48606F944.png" alt=""></p>
<p>可以看到当前运行的VM数量是0，点击目标主机，可以查看主机的详细信息，如下图：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/826BEA35-1853-4B62-A1B6-61F082DAD23F.png" alt=""></p>
<h3 id="3-2-命令行添加主机"><a href="#3-2-命令行添加主机" class="headerlink" title="3.2 命令行添加主机"></a>3.2 命令行添加主机</h3><h4 id="3-2-1-onehost-命令"><a href="#3-2-1-onehost-命令" class="headerlink" title="3.2.1  onehost 命令"></a>3.2.1  onehost 命令</h4><p>使用 onehost 命令删除之前 web 创建的主机,如下:</p>
<pre><code># su - oneadmin
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
1 10.249.7.247    -           0      0 / 3200 (0%)   0K / 125.7G (0%) on
$ onehost delete 1
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
</code></pre><p> 然后我们再使用 onehost 命令创建主机：</p>
<pre><code>$ onehost create   10.249.7.247 --im kvm --vm kvm --net dummy
ID: 2
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
2 10.249.7.247    -           0                  -                  - init
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
2 10.249.7.247    -           0      0 / 3200 (0%)   0K / 125.7G (0%) on
</code></pre><ul>
<li>-i, –im im_mad           Set the information driver for the host   //信息管理 driver. 可选: kvm, xen, vmware, ec2, ganglia, dummy.</li>
<li>-v, –vm vmm_mad          Set the virtualization driver for the host //虚拟化管理 driver. 可选: kvm, xen, vmware, ec2, dummy.</li>
<li>-n, –net vnet_mad        Set the network driver for the host  //虚拟网络driver.可选：802.1Q,dummy,ebtables,fw,ovswitch,vmware.</li>
</ul>
<p>了解更多 onehost 命令用法请查看man手册。</p>
<h2 id="四、制作系统镜像-1"><a href="#四、制作系统镜像-1" class="headerlink" title="四、制作系统镜像"></a>四、制作系统镜像</h2><p>虚拟机有多种镜像格式可供选择,常见的有如 raw、vdi、 qcow2、vmdk、qed、vhd 等格式。</p>
<p>虚拟机镜像和服务器之间的关系如下图所示：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/2533DDFD-5676-437A-9788-B173ECE01179.png" alt=""></p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/4B51B99B-FF41-4806-839A-8927817F314C.png" alt=""></p>
<h3 id="4-1-qemu-img命令"><a href="#4-1-qemu-img命令" class="headerlink" title="4.1 qemu-img命令"></a>4.1 qemu-img命令</h3><p>qemu-img 是 QEMU 的磁盘管理工具,支持多种虚拟镜像格式。</p>
<pre><code># qemu-img  -h | grep Supported
Supported formats: vvfat vpc vmdk vhdx vdi sheepdog sheepdog sheepdog rbd raw host_cdrom host_floppy host_device file qed qcow2 qcow parallels nbd nbd nbd dmg tftp ftps ftp https http cow cloop bochs blkverify blkdebug
</code></pre><p>qemu-img 默认创建的格式是 raw，常用的格式为 raw、qcow2等。qemu-img常用的命令有：</p>
<pre><code># qemu-img check [-f fmt]  filename    //对磁盘镜像文件进行一致性检查,查找镜像文件中的错误,目前仅支持对“qcow2”、“qed”、“vdi”格式文件的检查。
# qemu-img create [-f fmt] filename [size]   //创建一个格式为 fmt 大小为 size 文件名为filename 的镜像文件。
# qemu-img info [-f fmt] filename  //显示 filename 镜像文件的信息。
</code></pre><p>这里我们使用 qemu-img 命令创建一个 50G 大小格式为 qcow2 的系统镜像：</p>
<pre><code># qemu-img  create -f qcow2 ubuntu14.04.qcow2 50G
</code></pre><p>关于 qemu-img 的更多高级用法可以参考 man 手册。</p>
<h3 id="4-2-qemu-kvm（-kvm-）命令"><a href="#4-2-qemu-kvm（-kvm-）命令" class="headerlink" title="4.2 qemu-kvm（ kvm ）命令"></a>4.2 qemu-kvm（ kvm ）命令</h3><p>在centos中该命令为 qemu-kvm, 而在ubuntu的系统中该命令为kvm，由于我的测试机为ubuntu的系统所以后面会使用到 kvm 命令。</p>
<p>安装系统：</p>
<pre><code># kvm -m 1024 -cdrom /work-space/ubuntu-14.04.3-server-amd64.iso \ 
-drive file=/work-space/ubuntu14.04.qcow2,if=virtio -net nic,model=virtio \
-net tap,script=no -boot d -nographic -vnc :0
</code></pre><p>以上参数释义如下，更多 kvm 的参数使用说明请参考 man 手册：</p>
<ul>
<li>-m  指定内存大小</li>
<li>-cdrom   指定系统 iso 镜像</li>
<li>-drive file=xx,if=xx   指定硬盘镜像,file=镜像文件名,if=镜像格式类型 </li>
<li>-net nic,model=xx   表示网卡配置,model=模拟网卡类型,默认 rt18139</li>
<li>-net tap,script=no   虚拟设备,桥接网络,script 表启动虚拟机自动执行网络配置脚本,<br>如果不需要启动,则写 no </li>
<li>-boot d  系统启动顺序,d表示表示cdrom </li>
<li>-nographic  关闭图形输出</li>
<li>-vnc:0 开启vnc监听</li>
</ul>
<p>输入以上命令之后,通过 VNC 客户端连接按照正常的安装流程安装系统即可：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/E2156E2D-BF0F-4EFD-A37D-9E685DA900FD.png" alt=""></p>
<h3 id="4-3-系统优化"><a href="#4-3-系统优化" class="headerlink" title="4.3 系统优化"></a>4.3 系统优化</h3><p>在母盘上装好系统之后，可以进行一些优化如 selinux、iptables、软件源、相关服务等，这样后面使用该母盘创建的虚拟机就可以省去优化的步骤。</p>
<pre><code># kvm -m 1024  -drive file=/work-space/ubuntu14.04.qcow2,if=virtio \
-net nic,model=virtio -net tap,script=no  -nographic -vnc :0
</code></pre><p>输入以上命令之后,通过 VNC 客户端连接就能进入刚装好的系统。</p>
<h2 id="五、导入镜像-1"><a href="#五、导入镜像-1" class="headerlink" title="五、导入镜像"></a>五、导入镜像</h2><p>添加主机可以使用 web 页面添加,也可以使用命令添加,导入镜像 web 和命令也都可以实现。</p>
<h3 id="5-1-web界面导入映像"><a href="#5-1-web界面导入映像" class="headerlink" title="5.1 web界面导入映像"></a>5.1 web界面导入映像</h3><p>1.选择映像管理—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/A408EEF7-7ADC-4B3F-86EB-FACB978093B4.png" alt=""></p>
<p>2.点击添加之后出现如下弹框,根据实际填写<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C32678CF-1D95-4AB6-B56A-7F31FFEB8297.png" alt=""></p>
<p>持久性:如果您在虚拟机模板中使用了持久性的磁盘映像,你只能够基于该模板创建一个正在运行的虚拟机。这是因为一个持久型的磁盘映像只能够同时被应用到一台正在运行的虚拟机上。如果您在虚拟机模板中使用的是临时性的磁盘映像,则可以同时基于该模板创建 多个虚拟机。</p>
<p>3.导入后初始状态为锁定<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/49406625-17E8-4914-834B-4967587B66D1.png" alt=""></p>
<p>4.导入完成之后就会显示就绪状态<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/F08296E6-2554-462C-9215-62D4F4938FF0.png" alt=""></p>
<h3 id="5-2-命令行导入映像"><a href="#5-2-命令行导入映像" class="headerlink" title="5.2 命令行导入映像"></a>5.2 命令行导入映像</h3><h4 id="5-2-1-oneimg-命令"><a href="#5-2-1-oneimg-命令" class="headerlink" title="5.2.1 oneimg 命令"></a>5.2.1 oneimg 命令</h4><pre><code># su - oneadmin
$ oneimage list
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
</code></pre><p>使用 oneimg 导入系统映像 </p>
<pre><code>$ cat ubuntu14.04_test.one   //创建相关配置文件
NAME    = &quot;ubuntu14.04_test&quot;
PATH    = /work-space/ubuntu14.04.qcow2
TYPE    = OS
DESCRIPTION = &quot;ubuntu14.04_test&quot;
DRIVER  = qcow2
$ onedatastore list  //选择数据仓库,这里选择default
ID NAME                SIZE AVAIL CLUSTER      IMAGES TYPE DS      TM      STAT
0 system              2.6T 95%   -                 0 sys  -       shared  on
1 default             2.6T 95%   -                 1 img  fs      ssh     on
2 files               2.6T 95%   -                 0 fil  fs      ssh     on
$ oneimage create ubuntu14.04_test.one  --datastore default
ID: 2
$ oneimage list   //初始状态 lock
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No lock    0
$ oneimage list  //再次查看状态变为 rdy
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No rdy     0
</code></pre><p>使用 oneimage 命令和创建 ubuntu14.04_test.one 文件在web 页面创建映像的高级模式中同样能实现：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/CF777085-1F87-484F-AD7E-F8B0B966688B.png" alt=""></p>
<p>克隆镜像：oneimage clone  \<imageid>  \<name></name></imageid></p>
<p>有时需要修改某个镜像,在修改之前我们可以通过克隆的方式备份这个镜像</p>
<pre><code>$ oneimage list
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No rdy     0
$ oneimage  clone 1  ubuntu14.04_bak  // 指定克隆的映像id
ID: 3
$ oneimage list
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No rdy     0
3 oneadmin   oneadmin   ubuntu14.04_bak default        50G OS    No rdy     0
</code></pre><p>删除镜像 :  oneimage delete \<imageid |="" imagename=""></imageid></p>
<p>查看镜像详细信息：oneimage show</p>
<pre><code>$ oneimage show 1
IMAGE 1 INFORMATION
ID             : 1
NAME           : ubuntu14.04_50G
USER           : oneadmin
GROUP          : oneadmin
DATASTORE      : default
TYPE           : OS
REGISTER TIME  : 04/24 12:18:33
PERSISTENT     : No
SOURCE         : /var/lib/one//datastores/1/06f1f1d5f87d7aa92a528800b61e5983
PATH           : /work-space/ubuntu14.04.qcow2
SIZE           : 50G
STATE          : rdy
RUNNING_VMS    : 0

PERMISSIONS
OWNER          : um-
GROUP          : ---
OTHER          : ---

IMAGE TEMPLATE
DESCRIPTION=&quot;ubuntu14.04_50G&quot;
DEV_PREFIX=&quot;hd&quot;
DRIVER=&quot;qcow2&quot;

VIRTUAL MACHINES
</code></pre><h2 id="六、虚拟网络-1"><a href="#六、虚拟网络-1" class="headerlink" title="六、虚拟网络"></a>六、虚拟网络</h2><ul>
<li>eth0 为管理网口</li>
<li>eth1 为trunk口用作虚拟机通信，通过桥接br0</li>
</ul>
<h3 id="6-1-web界面添加虚拟网络"><a href="#6-1-web界面添加虚拟网络" class="headerlink" title="6.1 web界面添加虚拟网络"></a>6.1 web界面添加虚拟网络</h3><p>1.选择虚拟网络—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/6A422EA5-D7E3-4934-BEEF-A2DD5DA5D5B7.png" alt=""></p>
<p>2.点击添加之后出现如下弹框,根据实际填写<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/ADDF280D-B87F-4490-9A4E-85B6EE2D301B.png" alt=""><br>3.将网桥br0绑定到eth1 (网络模式和vlan概念还有点疑惑)<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/E2758C26-77CA-46EB-9441-EE923BFB3E69.png" alt=""><br>4.添加地址范围<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/726A4927-11ED-4726-A2F8-12A904BEED02.png" alt=""></p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/8717FB7C-97F4-4BC8-8505-DAD4C363A946.png" alt=""><br>5.完成其他相关配置，点击创建<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/EFFC8DC0-7B4B-4F0F-B1DF-F6878E731AAE.png" alt=""></p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/DAF058BB-9617-4D6C-A32F-225788F98BCD.png" alt=""></p>
<h3 id="6-2-命令行添加虚拟网络"><a href="#6-2-命令行添加虚拟网络" class="headerlink" title="6.2 命令行添加虚拟网络"></a>6.2 命令行添加虚拟网络</h3><h4 id="6-2-1-onevnet-命令"><a href="#6-2-1-onevnet-命令" class="headerlink" title="6.2.1 onevnet 命令"></a>6.2.1 onevnet 命令</h4><pre><code>$ onevnet list    //显示当前的虚拟网络
ID USER            GROUP        NAME                CLUSTER    BRIDGE   LEASES
0 oneadmin        oneadmin     test-network        -          br0           0
</code></pre><p>添加虚拟网络:</p>
<pre><code>$ cat onevnet_test.net
NAME    = &quot;onevnet_test&quot;
TYPE    = RANGED
BRIDGE = br0
NETWORK_ADDRESS = 10.249.6.0/24
IP_START        = 10.249.6.105
IP_END          = 10.249.6.107

GATEWAY = 10.249.6.254
DNS     = 10.249.6.100
$ onevnet create onevnet_test.net     // 添加虚拟网络
ID: 1
$ onevnet list
ID USER            GROUP        NAME                CLUSTER    BRIDGE   LEASES
0 oneadmin        oneadmin     test-network        -          br0           0
1 oneadmin        oneadmin     onevnet_test        -          br0           0
</code></pre><p>以上.net 文件中的内容可以直接输入到 web 创建虚拟网络的高级模式中创建。</p>
<p>删除虚拟网络:</p>
<pre><code>$ onevnet  delete 1
</code></pre><p>查看虚拟网络详细信息:</p>
<pre><code>$ onevnet  show 0
VIRTUAL NETWORK 0 INFORMATION
ID             : 0
NAME           : test-network
USER           : oneadmin
GROUP          : oneadmin
CLUSTER        : -
BRIDGE         : br0
VLAN           : Yes
PHYSICAL DEVICE: eth1
VLAN ID        : 6
USED LEASES    : 0

......
VIRTUAL NETWORK TEMPLATE
BRIDGE=&quot;br0&quot;
DESCRIPTION=&quot;test-network&quot;
DNS=&quot;10.249.6.100&quot;
GATEWAY=&quot;10.249.6.254&quot;
NETWORK_ADDRESS=&quot;10.249.6.0&quot;
NETWORK_MASK=&quot;255.255.255.0&quot;
PHYDEV=&quot;eth1&quot;
SECURITY_GROUPS=&quot;0&quot;
VLAN=&quot;YES&quot;
VLAN_ID=&quot;6&quot;
......
</code></pre><h2 id="七、制作模板-1"><a href="#七、制作模板-1" class="headerlink" title="七、制作模板"></a>七、制作模板</h2><p>模板就是包括创建虚拟机时使用到的系统镜像、以及各种配置的一个定义。</p>
<h3 id="7-1-web-界面制作模板"><a href="#7-1-web-界面制作模板" class="headerlink" title="7.1  web 界面制作模板"></a>7.1  web 界面制作模板</h3><p>1.选择模板管理—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/F02F53A0-473C-4F70-93E0-98B2B22F7191.png" alt=""><br>2.点击添加之后出现如下弹框,根据实际填写</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/3837A134-D0C5-4EE3-9E8D-83CD18693A85.png" alt=""><br>3.存储<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/87F81732-EEC1-4429-9868-2B6BD3D36382.png" alt=""><br>4.网络<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/80FA24E1-7D22-48F8-A57C-41AACBF326AC.png" alt=""><br>5.引导<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/3B448D17-02A9-4355-BA30-04407A83CDE0.png" alt=""><br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/9BEAEBE4-C0EA-4605-8727-6081260085BB.png" alt=""><br>6.输入输出<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/7AAABE0F-E3A1-4754-83B6-6C7E0D63C1E8.png" alt=""><br>7.Context功能<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/634670E1-53E7-4084-B0BF-84E639726AE7.png" alt=""><br>8.其他几个保持默认就行，填写完点击创建即可。</p>
<h3 id="7-2-Context初始化功能"><a href="#7-2-Context初始化功能" class="headerlink" title="7.2  Context初始化功能"></a>7.2  Context初始化功能</h3><p>Context原理图如下：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/34977BFC-C6FE-4E0B-B3F1-2DCA0CDA56C9.png" alt=""></p>
<p>Context 通过 ISO 镜像的方式配置新启动的虚拟机,即创建虚拟机的时候 Server 管理端 会把相关的配置文件和脚本打包生成到一个 ISO 文件中,新启动的虚拟机会挂载该 ISO 镜像 并执行其中的脚本以达到自动初始化虚拟机的目的。</p>
<h4 id="7-2-1-修改母盘镜像"><a href="#7-2-1-修改母盘镜像" class="headerlink" title="7.2.1 修改母盘镜像"></a>7.2.1 修改母盘镜像</h4><pre><code># oneimage show ubuntu14.04_50G  | grep SOURCE   //获取之前创建镜像位置
SOURCE         : /var/lib/one//datastores/1/06f1f1d5f87d7aa92a528800b61e5983
# kvm -m 1024  -drive file=/var/lib/one//datastores/1/06f1f1d5f87d7aa92a528800b61e5983,if=virtio \
-net nic,model=virtio -net tap,script=no  -nographic -vnc :0
</code></pre><p>通过 VNC View 连接,登陆系统,新建 context 脚本:</p>
<pre><code># chmod +x  /etc/init.d/vmcontext
# cat  /etc/init.d/vmcontext
#!/bin/bash
if [ ! -d /mnt/cdrom ]; then
        mkdir /mnt/cdrom
fi
    mount /dev/cdrom /mnt/cdrom
if [ -f /mnt/cdrom/context.sh ]; then
        bash /mnt/cdrom/context.sh
        bash /mnt/cdrom/init.sh

fi
umount /mnt/cdrom
</code></pre><p>加入开机启动执行,在rc.local中加入: bash  /etc/init.d/vmcontext</p>
<p>这里有两个文件：</p>
<p><strong>/mnt/cdrom/context.sh</strong>   //Context variables generated by OpenNebula,开通虚拟机时从平台里获取到的变量，如网卡相关的配置信息等。</p>
<p><strong>/mnt/cdrom/init.sh</strong>    //自己编写放置在Server端的脚本，主要功能就是让虚拟机能自动配置上context.sh中的变量</p>
<pre><code>$ pwd
/var/lib/one/context
$ ls
centos  ubuntu  windows
$ cd ubuntu/
$ ls
init.sh
$ cat init.sh    // init.sh 脚本内容，简单实例
#!/bin/bash

INTERFACE=&quot;/etc/network/interfaces&quot;
. /mnt/cdrom/context.sh
if [ $HOSTNAME ]; then
    hostname $HOSTNAME
    echo &quot;$HOSTNAME&quot; &gt; /etc/hostname
fi

echo -ne &quot;auto lo\n&quot; &gt; $INTERFACE
echo -ne &quot;iface lo inet loopback\n&quot; &gt;&gt; $INTERFACE

for i in 0 1 2 3; do
    grep &quot;ETH${i}_IP&quot; /mnt/cdrom/context.sh &gt;&gt; /dev/null 2&gt;&amp;1

if [ $? -eq 0 ]; then
    echo -ne &quot;\nauto eth$i\n&quot;               &gt;&gt; $INTERFACE
    echo -ne &quot;iface eth$i inet static\n&quot;    &gt;&gt; $INTERFACE
    echo -ne &quot;address &quot;                     &gt;&gt; $INTERFACE
    eval echo \$ETH${i}_IP                  &gt;&gt; $INTERFACE
    echo -ne &quot;netmask &quot;                     &gt;&gt; $INTERFACE
    eval echo \$ETH${i}_MASK                &gt;&gt; $INTERFACE
    echo -ne &quot;gateway &quot;                     &gt;&gt; $INTERFACE
    eval echo \$ETH${i}_GATEWAY             &gt;&gt; $INTERFACE

    if [ $i -eq 0 ]; then
        echo -ne &quot;dns-nameservers &quot; &gt;&gt; $INTERFACE
        eval echo \$ETH${i}_DNS &gt;&gt; $INTERFACE
        echo -ne &quot;dns-search i.ajkdns.com\n&quot; &gt;&gt; $INTERFACE
    fi
fi
done

/sbin/ifdown eth0
/sbin/ifup eth0
rm -rf /etc/init.d/vmcontext
sed  -i &apos;/vmcontext/d&apos; /etc/rc.local
ifconfig eth0 &gt;/dev/null 2&gt;1
    if [ &quot;$?&quot; != &quot;0&quot; ]; then
    rm -f /etc/udev/rules.d/70-persistent-net.rules
fi
reboot
</code></pre><h2 id="八、创建虚拟机-1"><a href="#八、创建虚拟机-1" class="headerlink" title="八、创建虚拟机"></a>八、创建虚拟机</h2><h3 id="8-1-web界面创建虚拟机"><a href="#8-1-web界面创建虚拟机" class="headerlink" title="8.1 web界面创建虚拟机"></a>8.1 web界面创建虚拟机</h3><p>1.选择虚机管理—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/88C9F701-7418-4948-96D3-703EE759FA40.png" alt=""></p>
<p>2.点击添加选择模板，设置主机名<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/OpenNebula%20Sunstone%20%20Cloud%20Operations%20Center.png" alt=""></p>
<p>3.点击创建后，主机初始状态为PENDING<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/2C3C8F5B-A2EA-4AB6-ADC7-0A981D27A7E4.png" alt=""></p>
<p>4.勾选主机并部署<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/4116E61F-F971-430F-A572-D3E0506E5033.png" alt=""></p>
<p>5.部署到主机<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C816CFBA-4A02-4D39-9CDB-F8FCBF392883.png" alt=""></p>
<p>6.部署完毕后，如果一切正常，虚拟机的状态为PROLOG—&gt; BOOT —&gt; 运行，后面即可ssh登录<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C3182977-E4C6-481A-ADEE-B4DBA7880D2E.png" alt=""><br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/3C0DC59D-C31E-4DDE-8467-2D5AAB680C15.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、OpenNebula简介&quot;&gt;&lt;a href=&quot;#一、OpenNebula简介&quot; class=&quot;headerlink&quot; title=&quot;一、OpenNebula简介&quot;&gt;&lt;/a&gt;一、OpenNebula简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.1 云管理平台的选择&lt;/li
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="opennebula" scheme="http://yoursite.com/tags/opennebula/"/>
    
  </entry>
  
  <entry>
    <title>Create A .deb Package Repository</title>
    <link href="http://yoursite.com/2016/03/08/Create-A-deb-Package-Repository/"/>
    <id>http://yoursite.com/2016/03/08/Create-A-deb-Package-Repository/</id>
    <published>2016-03-08T06:22:22.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Install-Reprepro-and-Generate-Key"><a href="#Install-Reprepro-and-Generate-Key" class="headerlink" title="Install Reprepro and Generate Key"></a>Install Reprepro and Generate Key</h3><p>安装软件包并生成密钥</p>
<pre><code># sudo apt-get  install reprepro gnupg -y
</code></pre><p>创建gpg key需要大量的随机操作，使用rng-tools产生大量随机操作    </p>
<pre><code># apt-get install rng-tools -y

# vim /etc/default/rng-tools   

[...]

HRNGDEVICE=/dev/urandom

[...]

# /etc/init.d/rng-tools start
</code></pre><p>Generate a gpg key using gnupg  </p>
<pre><code># gpg --gen-key
......
Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
Your selection? 4
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
        0 = key does not expire
    &lt;n&gt;  = key expires in n days
    &lt;n&gt;w = key expires in n weeks
    &lt;n&gt;m = key expires in n months
    &lt;n&gt;y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
 &quot;Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;&quot;

Real name: Mr-zhao
Email address: zhifanzhao@gmail.com
Comment: ops deb
Enter passphrase:****
You selected this USER-ID:
    &quot;Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;&quot;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
You need a Passphrase to protect your secret key.

You don&apos;t want a passphrase - this is probably a *bad* idea!
I will do it anyway.  You can change your passphrase at any time,
using this program with the option &quot;--edit-key&quot;.

We need to generate a lot of random bytes.
 It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy.

......
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key D94F748F marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   4096R/D94F748F 2016-03-08
    Key fingerprint = 7D96 2419 19C6 B7C3 7F97  F4BB 63BF 6A4F D94F 748F
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

Note that this key cannot be used for encryption.  You may want to use
the command &quot;--edit-key&quot; to generate a subkey for this purpose. 
</code></pre><p>查看和修改 gpg key</p>
<pre><code># gpg --list-keys
/root/.gnupg/pubring.gpg
------------------------
pub   4096R/D94F748F 2016-03-08
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

# gpg --edit-key
usage: gpg [options] --edit-key user-id [commands]
</code></pre><h3 id="Create-a-Package-Repository-and-Export-Key"><a href="#Create-a-Package-Repository-and-Export-Key" class="headerlink" title="Create a Package Repository and Export Key"></a>Create a Package Repository and Export Key</h3><pre><code># cd /data
# mkdir apt
# mkdir -p ./apt/conf

#vim  ./apt/conf/distributions
Origin:        ops-ubuntu
Label:         ops-ubuntu
Suite:         trusty
Codename:      trusty
Version:       14.04
Architectures: amd64 i386
Components:    main restricted multiverse universe
Description:   private main deb repository for trusty
SignWith: yes

#vim ./apt/conf/options   //reprepro --options命令的集合
verbose
basedir  .
ask-passphrase
distdir  /data/apt/repos/dists   //dist文件的输出位置
outdir   /data/apt/repos    //pool输出的位置
</code></pre><p>Create the repository tree</p>
<pre><code># reprepro --ask-passphrase -Vb /data/apt/ export
</code></pre><p>Export Key</p>
<pre><code># gpg --armor --export Mr-zhao zhifanzhao@gmail.com &gt;&gt; ./repos/public.key
</code></pre><h3 id="Add-Packages-to-Newly-Created-Repository"><a href="#Add-Packages-to-Newly-Created-Repository" class="headerlink" title="Add Packages to Newly Created Repository"></a>Add Packages to Newly Created Repository</h3><pre><code>#reprepro -b . -C main includedeb trusty /tmp/packages.deb  //add

#reprepro remove trusty packages   //remove 
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.tecmint.com/create-deb-pacakge-repository-in-ubuntu/" target="_blank" rel="external">Create A .deb Package Repository</a><br><a href="https://wikitech.wikimedia.org/wiki/Reprepro" target="_blank" rel="external">wiki reprepro</a><br><a href="https://wiki.debian.org/SecureApt" target="_blank" rel="external">SecureApt)</a><br><a href="http://irtfweb.ifa.hawaii.edu/~lockhart/gpg/" target="_blank" rel="external">gpg-cheat</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="external">gpg</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Install-Reprepro-and-Generate-Key&quot;&gt;&lt;a href=&quot;#Install-Reprepro-and-Generate-Key&quot; class=&quot;headerlink&quot; title=&quot;Install Reprepro and Gener
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="deb" scheme="http://yoursite.com/tags/deb/"/>
    
      <category term="reprepro" scheme="http://yoursite.com/tags/reprepro/"/>
    
  </entry>
  
  <entry>
    <title>Work Tips</title>
    <link href="http://yoursite.com/2016/03/05/Feb_tips/"/>
    <id>http://yoursite.com/2016/03/05/Feb_tips/</id>
    <published>2016-03-05T14:11:36.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-无交互修改系统密码"><a href="#1-无交互修改系统密码" class="headerlink" title="1.无交互修改系统密码"></a><u>1.无交互修改系统密码</u></h3><p>CentOS</p>
<pre><code>echo 123456 |  passwd --stdin root
</code></pre><p>Ubuntu</p>
<pre><code>echo &quot;root:123456&quot; | chpasswd   //ubuntu是BSD 非标准的不能用
</code></pre><p>CentOS和Ubuntu还有一个地方要注意，CentOS默认新建的普通用户是没有sudo权限的，需要在/etc/sudoers文件中加入用户和权限才能执行sudo，而Ubuntu执行sudo 默认输入当前用户密码即可执行。</p>
<h3 id="2-deb包的字段含义"><a href="#2-deb包的字段含义" class="headerlink" title="2.deb包的字段含义"></a><u>2.deb包的字段含义</u></h3><pre><code>root@Mr-zhao:~# aptitude search node
p   ansible-node-fireball                           - Ansible fireball transport support for nodes
p   ax25-node                                       - Amateur Packet Radio Node program
p   ax25-node:i386                                  - Amateur Packet Radio Node program
p   knode                                           - graphical news reader
p   knode:i386                                      - graphical news reader
p   leafnode                                        - NNTP server for small sites
p   leafnode:i386                                   - NNTP server for small sites
p   libjs-node-uuid                                 - simple, fast generation of RFC4122 UUIDs - JavaScript libr
v   libnode-node-expat                              -
v   libnode-node-expat:i386                         -
</code></pre><blockquote>
<p>current state of the package: <code>the most common states are p, meaning that no trace of the packageexists on the system, c, meaning that the package was deleted but its configuration files remain on the system, i, meaning that the package is installed, and v, meaning that the package is virtual.</code> ( man aptitude )</p>
</blockquote>
<h3 id="3-apt-get-update-NO-PUBKEY"><a href="#3-apt-get-update-NO-PUBKEY" class="headerlink" title="3.apt-get update NO_PUBKEY"></a><u>3.apt-get update NO_PUBKEY</u></h3><p>将私有镜像仓库的key添加到本地trusted数据库</p>
<pre><code># curl -l http://mirrors.corp.ops.com/ops/public.key|apt-key add -
</code></pre><p>如果还有报错，则使用以下命令：</p>
<pre><code># apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 3B4FE6ACC0B21F32

# apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 40976EAF437D05B5
</code></pre><h3 id="4-Cacti-weathermap-插件-editor-php-的安全性设置"><a href="#4-Cacti-weathermap-插件-editor-php-的安全性设置" class="headerlink" title="4.Cacti weathermap 插件 editor.php 的安全性设置"></a><u>4.Cacti weathermap 插件 editor.php 的安全性设置</u></h3><p>Cacti weathermap采用.htaccess的验证方法</p>
<p>首先在/var/www/html/plugins/weathermap下创建一个验证文件</p>
<pre><code>#htpasswd -cb /var/www/html/plugins/weathermap/.htpasswd cacti catiuser
//cacti是用户名，cactiuser是密码
</code></pre><p>创建好验证文件后，在apache的配置文件末尾加上如下的代码</p>
<pre><code>&lt;Directory/var/www/html/plugins/weathermap&gt;
&lt;Files editor.php&gt;
AuthType Basic
AuthName &quot;Please input your username and password.&quot;
AuthUserFile /var/www/html/plugins/weathermap/.htpasswd
require valid-user
&lt;/Files&gt;
&lt;/Directory&gt;
</code></pre><h3 id="5-SSD磁盘分区4K对齐检测"><a href="#5-SSD磁盘分区4K对齐检测" class="headerlink" title="5.SSD磁盘分区4K对齐检测"></a><u>5.SSD磁盘分区4K对齐检测</u></h3><p>使用fdisk分区，则查看start能否被8整除</p>
<pre><code>fdisk -lu |awk &apos;$1==&quot;/dev/sdb1&quot; {print $2/8}&apos;
</code></pre><p>使用parted分区</p>
<pre><code>root@Mr-zhao:~# parted /dev/sdb
GNU Parted 2.1
Using /dev/sdb
Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.
(parted) print
Model: DELL PERC H730P Mini (scsi)
Disk /dev/sdb: 1439GB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt

Number  Start   End     Size    File system  Name     Flags
1      1049kB  1439GB  1439GB  xfs          primary

(parted) align-check opt 1
1 aligned   #返回aligned，即对齐
(parted)
</code></pre><h3 id="6-drop-caches"><a href="#6-drop-caches" class="headerlink" title="6.drop caches"></a><u>6.drop caches</u></h3><p>Writing to this will cause the kernel to drop clean caches, dentries and inodes from memory, causing thatmemory to become free.</p>
<p>To free pagecache:</p>
<pre><code>echo 1 &gt; /proc/sys/vm/drop_caches
</code></pre><p>To free dentries and inodes:</p>
<pre><code>echo 2 &gt; /proc/sys/vm/drop_caches
</code></pre><p>To free pagecache, dentries andinodes:</p>
<pre><code>echo 3 &gt; /proc/sys/vm/drop_caches
</code></pre><p>As this is a non-destructiveoperation and dirty objects are not freeable, the user should run sync first.</p>
<h3 id="7-系统快速求援"><a href="#7-系统快速求援" class="headerlink" title="7.系统快速求援"></a><u>7.系统快速求援</u></h3><blockquote>
<ul>
<li>at the grub prompt,hit a to append options</li>
<li>add init=/bin/bash to the kernel command line</li>
<li>mount -o remount,rw /</li>
<li>vim /etc/fstab</li>
<li>reboot</li>
</ul>
</blockquote>
<h3 id="8-修改网卡规则（设置显示为eth0）"><a href="#8-修改网卡规则（设置显示为eth0）" class="headerlink" title="8.修改网卡规则（设置显示为eth0）"></a><u>8.修改网卡规则（设置显示为eth0）</u></h3><pre><code>编辑 /etc/udev/rules.d/70-persistent-net.rules  修改网卡规则
</code></pre><h3 id="9-重启网卡失败：device-eth0-does-not-seem-to-be-present-delaying-initialization"><a href="#9-重启网卡失败：device-eth0-does-not-seem-to-be-present-delaying-initialization" class="headerlink" title="9.重启网卡失败：device eth0 does not seem to be present, delaying initialization"></a><u>9.重启网卡失败：device eth0 does not seem to be present, delaying initialization</u></h3><pre><code>/etc/udev/rules.d/70-persistent-net.rules 删除后重启机器
</code></pre><h3 id="10-查看磁盘的rebuild-进度"><a href="#10-查看磁盘的rebuild-进度" class="headerlink" title="10.查看磁盘的rebuild 进度"></a><u>10.查看磁盘的rebuild 进度</u></h3><pre><code># MegaCli -PDRbld -ShowProg -PhysDrv [32:3] -a0
Rebuild Progress on Device at Enclosure 32, Slot 3 Completed 95% in 50 Minutes.
</code></pre><h3 id="11-sed-i-破坏链接文件属性"><a href="#11-sed-i-破坏链接文件属性" class="headerlink" title="11.sed -i  破坏链接文件属性"></a><u>11.sed -i  破坏链接文件属性</u></h3><pre><code>--follow-symlinks

          follow symlinks when processing in place; hard links will still be broken.

-i[SUFFIX], --in-place[=SUFFIX]

          edit  files in place (makes backup if extension supplied).  The default operation mode
          is to break symbolic and hard links.  This can be changed with  --follow-symlinks  and
          --copy.

-c, --copy

          use  copy  instead  of  rename when shuffling files in -i mode.  While this will avoid
          breaking links (symbolic or hard), the resulting  editing  operation  is  not  atomic.
          This  is  rarely the desired mode; --follow-symlinks is usually enough, and it is both
          faster and more secure.
</code></pre><p> mannul中释义 -i选项对软链接和硬链接都会破坏，加上 –follow-symlinks选项只对软链接有效，硬链接还是会被破坏，加上 -c选项则软硬链接都不会遭到破坏。</p>
<h3 id="12-文本内容操作，合并去重"><a href="#12-文本内容操作，合并去重" class="headerlink" title="12.文本内容操作，合并去重"></a><u>12.文本内容操作，合并去重</u></h3><pre><code>cat /etc/rc.local  /etc/rc.d/rc.local |  awk &apos;!a[$0]++&apos;
</code></pre><h3 id="13-ssh登陆信息显示-etc-motd"><a href="#13-ssh登陆信息显示-etc-motd" class="headerlink" title="13.ssh登陆信息显示 /etc/motd"></a><u>13.ssh登陆信息显示 /etc/motd</u></h3><p>/etc/motd/etc/motd即messageoftoday（布告栏信息），每次用户登录时，/etc/motd文件的内容会显示在用户的终端,如果用户登录系统是图形界面，这些信息则不会显示。</p>
<h3 id="14-SSD磁盘型号与系列"><a href="#14-SSD磁盘型号与系列" class="headerlink" title="14.SSD磁盘型号与系列"></a><u>14.SSD磁盘型号与系列</u></h3><pre><code>SSDSC2BB480G4   属于S3500系列
SSDSC2BA800G4   属于S3710系列
SSDSC2BA800G3   属于S3700系列
SSDSC2BX800G4   属于S3610系列
800、480表示磁盘容量
</code></pre><p>  <a href="http://ark.intel.com/ZH-CN#@SolidStateDrives" target="_blank" rel="external">Intel SSD 官网查询</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-无交互修改系统密码&quot;&gt;&lt;a href=&quot;#1-无交互修改系统密码&quot; class=&quot;headerlink&quot; title=&quot;1.无交互修改系统密码&quot;&gt;&lt;/a&gt;&lt;u&gt;1.无交互修改系统密码&lt;/u&gt;&lt;/h3&gt;&lt;p&gt;CentOS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 
    
    </summary>
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>free查看内存相关信息</title>
    <link href="http://yoursite.com/2016/03/03/free/"/>
    <id>http://yoursite.com/2016/03/03/free/</id>
    <published>2016-03-03T11:02:23.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="manual-description"><a href="#manual-description" class="headerlink" title="manual description"></a>manual description</h4><blockquote>
<p>free  displays  the total amount of free and used physical and swap memory in the system, as well as the buffers used bythe kernel.</p>
<p>The shared memory column represents either the MemShared value (2.4 series kernels) or the Shmem value (2.6 series kernels and later) taken from the /proc/meminfo file. The value is zero if none of the entries is exported by the kernel.</p>
</blockquote>
<h4 id="buffers-and-cached"><a href="#buffers-and-cached" class="headerlink" title="buffers and cached"></a>buffers and cached</h4><blockquote>
<p><strong>What is the difference between buffers and Cache?</strong></p>
<p>A buffer is a temporary location to store data for a particular application and this data is not used by any other application. This is similar to bandwidth concept. When you try to send burst of data through network, if your network card is capable of sending less data, it will keep these huge amounts of data in buffer so that it can send data constantly in lesser speeds. In other hand Cache is a memory location to store frequently used data for faster access. Other difference between a buffer and a cache is that cache can be used multiple times where as buffer is used single time. And both are temporary store for your data processing.</p>
</blockquote>
<ul>
<li>A buffer is something that has yet to be “written” to disk.</li>
<li>A cache is something that has been “read” from the disk and stored for later use.</li>
</ul>
<p>buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。   这二者是为了提高IO性能的。为了提高IO read的性能，总是要多cache一些数据，这也就是为什么cached memor比较大，而比较小的原因。</p>
<pre><code>root@Mr-zhao:~# free -m
             total       used       free     shared    buffers     cached
Mem:          2001        979       1021          0         58        774
-/+ buffers/cache:        146       1854
Swap:         4092          0       4092
</code></pre><p>当我们第一次读一个大文件时耗时可能会比第二次长，原因就是第二次读取时已有cache数据。</p>
<ul>
<li><p>-/+ buffers/cache(used): 表示一个应用程序认为系统被用掉多少内存；</p>
<p>  -/+ buffers/cache(used) = Mem(used) – Mem(buffers) – Mem(cached)</p>
</li>
<li><p>-/+ buffers/cache(free)，表示一个应用程序认为系统还有多少内存；</p>
<p>  -/+ buffers/cache(free) = Mem(free) + Mem(buffers) + Mem(cached)</p>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="external">Linux上的free命令详解</a><br><a href="http://www.freelinuxconsole.info/understanding-free-command-in-linuxunix-2/" target="_blank" rel="external">Understanding free command in Linux/Unix</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;free&quot;&gt;&lt;a href=&quot;#free&quot; class=&quot;headerlink&quot; title=&quot;free&quot;&gt;&lt;/a&gt;free&lt;/h3&gt;&lt;h4 id=&quot;manual-description&quot;&gt;&lt;a href=&quot;#manual-description&quot; class=&quot;
    
    </summary>
    
      <category term="Cmd" scheme="http://yoursite.com/categories/Cmd/"/>
    
    
      <category term="free" scheme="http://yoursite.com/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>minicom的使用</title>
    <link href="http://yoursite.com/2016/02/28/minicom/"/>
    <id>http://yoursite.com/2016/02/28/minicom/</id>
    <published>2016-02-28T13:21:34.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="minicom的介绍"><a href="#minicom的介绍" class="headerlink" title="minicom的介绍"></a>minicom的介绍</h3><p>Linux下的Minicom的功能与Windows下的超级终端功能相似，<strong>可以通过串口控制外部的硬件设备</strong>，适于在linux通过超级终端对嵌入式设备行管理。</p>
<h3 id="minicom的安装配置和使用"><a href="#minicom的安装配置和使用" class="headerlink" title="minicom的安装配置和使用"></a>minicom的安装配置和使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code># apt-get install minicom
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p> 实际案例：交换机的consle转usb口连接到服务器，通过minicom对交换机进行配置</p>
<pre><code># lsusb   //查看USB的状态
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse
Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 002 Device 004: ID 0e0f:0008 VMware, Inc.
Bus 002 Device 005: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port

# dmesg |grep ttyUSB  //USB已经连接
[11991.918691] usb 2-2.2: pl2303 converter now attached to ttyUSB0

# minicom -s   //进行配置

+-----[configuration]------+
| Filenames and paths      |
| File transfer protocols  |
| Serial port setup        |
| Modem and dialing        |
| Screen and keyboard      |
| Save setup as dfl        |
| Save setup as..          |
| Exit                     |
| Exit from Minicom        |
+--------------------------+

#选择进入Serial port setup，按照之前查看的信息进行配置

+-----------------------------------------------------------------------+
| A -    Serial Device      : /dev/ttyUSB0                              |
| B - Lockfile Location     : /var/lock                                 |
| C -   Callin Program      :                                           |
| D -  Callout Program      :                                           |
| E -    Bps/Par/Bits       : 115200 8N1                                |
| F - Hardware Flow Control : Yes                                       |
| G - Software Flow Control : No                                        |
|                                                                       |
|    Change which setting?                                              |
+-----------------------------------------------------------------------+
    | Screen and keyboard      |
    | Save setup as dfl        |
    | Save setup as..          |
    | Exit                     |
    | Exit from Minicom        |
    +--------------------------+

#Enter退出，选择Save setup as dfl  保存为默认配置
</code></pre><p>  然后进入终端输入minicom 就能连接进入交换机配置</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;minicom的介绍&quot;&gt;&lt;a href=&quot;#minicom的介绍&quot; class=&quot;headerlink&quot; title=&quot;minicom的介绍&quot;&gt;&lt;/a&gt;minicom的介绍&lt;/h3&gt;&lt;p&gt;Linux下的Minicom的功能与Windows下的超级终端功能相似，&lt;s
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="minicom" scheme="http://yoursite.com/tags/minicom/"/>
    
  </entry>
  
  <entry>
    <title>ulimit小记</title>
    <link href="http://yoursite.com/2016/02/25/ulimit/"/>
    <id>http://yoursite.com/2016/02/25/ulimit/</id>
    <published>2016-02-25T11:11:45.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ulimit简介"><a href="#ulimit简介" class="headerlink" title="ulimit简介"></a>ulimit简介</h3><p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p>
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。</p>
<h3 id="ulimit的设置"><a href="#ulimit的设置" class="headerlink" title="ulimit的设置"></a>ulimit的设置</h3><pre><code>[root@Mr-zhao ~]# ulimit  -a    //查看当前配置文件ulimit全局系数
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7389
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 10240
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 10240
cpu time               (seconds, -t) unlimited
max user processes              (-u) 10240
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</code></pre><p>对于线上环境的机器一般要对<code>open files</code>和<code>max user processes</code>进行修改。</p>
<h4 id="临时性的修改，只对当前shell生效。"><a href="#临时性的修改，只对当前shell生效。" class="headerlink" title="临时性的修改，只对当前shell生效。"></a>临时性的修改，只对当前shell生效。</h4><pre><code>ulimit  -n 65535
ulimit  -u 65535
</code></pre><h4 id="想要ulimit的设置永久性生效，需要修改-etc-security-limits-conf文件。"><a href="#想要ulimit的设置永久性生效，需要修改-etc-security-limits-conf文件。" class="headerlink" title="想要ulimit的设置永久性生效，需要修改/etc/security/limits.conf文件。"></a>想要ulimit的设置永久性生效，需要修改/etc/security/limits.conf文件。</h4><p>对于centos系统/etc/security/limits.d/90-nproc.conf文件的优先级高于/etc/security/limits.conf，所以对全局的设定需修改90-nproc.conf文件。对于单个用户的ulimit的设置并不受etc/security/limits.d/90-nproc.conf影响。</p>
<p>对于ubuntu系统，只需对/etc/security/limits.conf文件进行修改，ubuntu系统没有引入90-nproc.conf文件。但是ubuntux系统也会存在一个问题，就是对全局的设置其实对于root用户是没有效果的。所以ubuntu系统下的设置如下：</p>
<pre><code>root@Mr-zhao:~# grep -Ev &quot;^$|^#&quot; /etc/security/limits.conf
root - nofile 65535
root - nproc  65535
* - nofile 65535
* - nproc 65535
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="external">通过 ulimit 改善系统性能</a><br><a href="http://ss64.com/bash/limits.conf.html" target="_blank" rel="external">limits.conf - configuration file</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ulimit简介&quot;&gt;&lt;a href=&quot;#ulimit简介&quot; class=&quot;headerlink&quot; title=&quot;ulimit简介&quot;&gt;&lt;/a&gt;ulimit简介&lt;/h3&gt;&lt;p&gt;ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内
    
    </summary>
    
      <category term="Ops" scheme="http://yoursite.com/categories/Ops/"/>
    
    
      <category term="ulimit" scheme="http://yoursite.com/tags/ulimit/"/>
    
  </entry>
  
  <entry>
    <title>网络相关命令备忘</title>
    <link href="http://yoursite.com/2016/02/24/network-command/"/>
    <id>http://yoursite.com/2016/02/24/network-command/</id>
    <published>2016-02-24T13:28:28.000Z</published>
    <updated>2016-11-07T05:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看网络连接状态接口等信息。</p>
<h4 id="常用的命令选项："><a href="#常用的命令选项：" class="headerlink" title="常用的命令选项："></a>常用的命令选项：</h4><ul>
<li>a : 显示所有活动连接</li>
<li>n：以数字的形式显示（不使用主机名与服务名称，使用 IP 与 port number ）</li>
<li>p：显示进程名和PID</li>
<li>t：查看TCP协议相关信息</li>
<li>u：查看UDP协议相关信息</li>
<li>l：显示正在监听的进程</li>
</ul>
<p>netstat 的输出主要分为两大部分，分别是 TCP/IP 的网络接口部分，以及传统的 Unix socket 部分:</p>
<pre><code>[root@Mr-zhao ~]# netstat -ntpl
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 0.0.0.0:8080                0.0.0.0:*                   LISTEN      9356/nginx
tcp        0      0 0.0.0.0:80                  0.0.0.0:*                   LISTEN      9356/nginx
tcp        0      0 0.0.0.0:8081                0.0.0.0:*                   LISTEN      9356/nginx
tcp        0      0 10.48.156.8:60020           0.0.0.0:*                   LISTEN      12371/./gseAgent
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      16594/sshd
tcp        0      0 :::22                       :::*                        LISTEN      16594/sshd
</code></pre><p><strong>字段含义：</strong></p>
<ul>
<li>proto  协议</li>
<li>Recv-Q 接受数据</li>
<li>Send-Q 发送数据</li>
<li>Local Address 本地地址和端口号</li>
<li>Foreign Addredd  外部地址和端口号</li>
<li>State 状态</li>
<li>PID/Program name  PID和进程名称</li>
</ul>
<p>在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就等同于 0.0.0.0:22</p>
<p><strong> State状态（tcp三次握手）：</strong></p>
<ul>
<li>ESTABLISED：已建立连接的状态；</li>
<li>SYN_SENT：发出主动连接 (SYN 标志) 的连接封包；</li>
<li>SYN_RECV：接收到一个要求连接的主动连接封包；</li>
<li>FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；</li>
<li>FIN_WAIT2：该连接已挂断，但正在等待对方主机响应断线确认的封包；</li>
<li>TIME_WAIT：该连接已挂断，但 socket 还在网络上等待结束；</li>
<li>LISTEN：通常用在服务的监听 port ！可使用『 -l 』参数查阅。</li>
</ul>
<p>查看目前已经启动的网络服务</p>
<pre><code>netstat -tupln
</code></pre><p>查看本机上所有的网络连接状态</p>
<pre><code>netstat -atunp
</code></pre><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>网络端口扫描命令</p>
<h4 id="常用的扫描类型："><a href="#常用的扫描类型：" class="headerlink" title="常用的扫描类型："></a>常用的扫描类型：</h4><ul>
<li>-sT : TCP连接扫描</li>
<li>-sU：UDP扫描</li>
<li>-sP：ICMP扫描</li>
<li>-A：扫描操作系统类型</li>
<li>-p: 扫描端口</li>
<li>-n ：禁止反向解析</li>
</ul>
<p>检测10.0.2.0/16 网段有那些存活的主机</p>
<pre><code>nmap -n -sP 10.0.2.0/16
</code></pre><p>检测ip地址 10.0.2.100-200 间的存活的主机</p>
<pre><code>nmap -n -sP 10.0.2.100-200
</code></pre><p>检测主机10.0.2.253的tcp连接情况</p>
<pre><code>nmap -n  -sT 10.0.2.253
</code></pre><p> 检测所用操作系统和主机的基本信息</p>
<pre><code>nmap -A  www.baidu.com
nmap -A  10.0.2.253
</code></pre><h3 id="tcpdump-命令行抓包工具"><a href="#tcpdump-命令行抓包工具" class="headerlink" title="tcpdump 命令行抓包工具"></a>tcpdump 命令行抓包工具</h3><p>用途：不间断监控网络通信数据包</p>
<h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul>
<li><p>-qnn 可简化输出</p>
</li>
<li><p>-v -vv -vvv  指显示信息的详细程度</p>
</li>
</ul>
<h4 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h4><p>过滤主机</p>
<ul>
<li><p>host 源ip或者目标ip</p>
</li>
<li><p>src host 源ip</p>
</li>
<li><p>dst host 目标ip</p>
</li>
<li><p>ether host 源或者目标MAC地址</p>
</li>
</ul>
<p>过滤端口</p>
<ul>
<li>port 源端口或者目标端口，同样可以搭配 src、dst</li>
</ul>
<p>过滤协议</p>
<ul>
<li>arp | tcp | udp | icmp</li>
</ul>
<p>过滤网络</p>
<ul>
<li>net 网络地址，同样可以搭配 src、dst</li>
</ul>
<h4 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h4><p>and（&amp;&amp;）、or （||）、not（!）</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code>tcpdump -i eth0 -nn prot 22 and src host 192.168.1.6

tcpdump -i eth0 icmp and ether dst host 00:11:22:33:44:55

tcpdump -i eth0 tcp and dst net 172.18 and not dst host 192.168.1.100

tcpdump -i eth0 -nn -vv port 67 and udp

tcpdump -i eth0 -q -n arp         //监控eth0 的arp 协议 （ping）

tcpdump -i eth0 -v -n icmp and host 10.0.2.232

tcpdump -i eth0 -q -n arp -w /tmp/arp   //将结果输入到文本

tcpdump -r /tmp/arp   // 读出结果
</code></pre><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口。</p>
<p><strong>直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了.</strong>可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。</p>
<h4 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h4><pre><code>[root@localhost ~]# route -n  // -n 表示不解析名字,列出速度会比route 快
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.120.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0
10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0
0.0.0.0         192.168.120.240 0.0.0.0         UG    0      0        0 eth0
</code></pre><ul>
<li><p>第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;</p>
</li>
<li><p>第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240</p>
</li>
<li><p>其中Flags为路由标志，标记当前网络节点的状态。</p>
<p>  Flags标志说明：</p>
<ul>
<li><p>U Up表示此路由当前为启动状态</p>
</li>
<li><p>H Host，表示此网关为一主机</p>
</li>
<li><p>G Gateway，表示此网关为一路由器</p>
</li>
<li><p>R Reinstate Route，使用动态路由重新初始化的路由</p>
</li>
<li><p>D Dynamically,此路由是动态性地写入</p>
</li>
<li><p>M Modified，此路由是由路由守护程序或导向器动态修改</p>
</li>
<li><p>! 表示此路由当前为关闭状态</p>
</li>
</ul>
</li>
</ul>
<h4 id="添加和删除路由："><a href="#添加和删除路由：" class="headerlink" title="添加和删除路由："></a>添加和删除路由：</h4><pre><code>route add -net 10.10.0.0 netmask 255.255.0.0 gw 10.10.3.1

route add -net 10.20.0.0 netmask 255.255.0.0 gw 10.10.3.1

route add -net 10.249.0.0 netmask 255.255.0.0 gw 10.10.3.1

route add -net 192.168.0.0 netmask 255.255.0.0 gw 10.10.3.1

route add default gw 10.10.3.252      //添加默认网关，默认网关只能有一条！多块网卡默认网关也只能有一个！

route del default gw 10.10.3.1   // 删除默认网关
</code></pre><p><strong>指定网卡</strong></p>
<pre><code>route add -net 10.249.0.0 netmask 255.255.0.0 gw 10.10.3.1 dev eth0
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;netstat&quot;&gt;&lt;a href=&quot;#netstat&quot; class=&quot;headerlink&quot; title=&quot;netstat&quot;&gt;&lt;/a&gt;netstat&lt;/h3&gt;&lt;p&gt;查看网络连接状态接口等信息。&lt;/p&gt;
&lt;h4 id=&quot;常用的命令选项：&quot;&gt;&lt;a href=&quot;#常用的
    
    </summary>
    
      <category term="Cmd" scheme="http://yoursite.com/categories/Cmd/"/>
    
    
      <category term="网络命令" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
