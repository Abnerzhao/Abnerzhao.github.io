<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Abnerzhao"><meta name="description" content="DevOps"><title>Abner</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/"><link rel="alternate" href="/atom.xml" title="Abner"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5832f612aff8681e2ee213a3b8d9548b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Abner</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/04/小试Ansible-Python-API/" class="post-link">小试Ansible Python API</a></h2><span class="post-time">Nov 4, 2016</span><div class="post-content"><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ping 模块</div><div class="line">$ ansible localhost -m ping</div><div class="line">localhost | success &gt;&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line">// shell 模块</div><div class="line">$ ansible localhost -m shell -a &apos;uptime&apos;</div><div class="line">localhost | success | rc=0 &gt;&gt;</div><div class="line">11:00:11 up 66 days, 23:34,  1 user,  load average: 0.00, 0.01, 0.05</div></pre></td></tr></table></figure>
<h3 id="Python-API"><a href="#Python-API" class="headerlink" title="Python API"></a>Python API</h3><p>通过ansible.runner模块来实现</p>
<h4 id="使用API实现ping模块功能："><a href="#使用API实现ping模块功能：" class="headerlink" title="使用API实现ping模块功能："></a>使用API实现ping模块功能：</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">runner = ansible.runner.Runner(</div><div class="line">    module_name=<span class="string">'ping'</span>,  //模块名</div><div class="line">    module_args=<span class="string">''</span>,  //模块参数</div><div class="line">    pattern=<span class="string">'localhost'</span>,  //匹配主机或主机组</div><div class="line">    forks=<span class="number">2</span> //多线程</div><div class="line">)</div><div class="line">data = runner.run()</div><div class="line"><span class="keyword">print</span> data  //打印输出结果默认json格式</div><div class="line"></div><div class="line">//stdout</div><div class="line">&#123;<span class="string">'dark'</span>: &#123;&#125;, <span class="string">'contacted'</span>: &#123;<span class="string">'localhost'</span>: &#123;<span class="string">'invocation'</span>: &#123;<span class="string">'module_name'</span>: <span class="string">'ping'</span>, <span class="string">'module_args'</span>: <span class="string">''</span>&#125;, <span class="string">u'changed'</span>: <span class="keyword">False</span>, <span class="string">u'ping'</span>: <span class="string">u'pong'</span>&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<p>由于输出结果默认是json格式，那么我们可以格式化一下，让它更美观</p>
<blockquote>
<p>sort_keys  <code>按key排序</code><br>indent <code>缩进</code><br>separators <code>指定分隔符(默认分隔符&#39;, &#39;,使用&#39;,&#39;,&#39;: &#39; 避免尾部空格)</code></p>
</blockquote>
<p>上例中的输出格式化：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">print</span> json.dumps(data, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>)) //对json格式化输出</div><div class="line">//stdout</div><div class="line">&#123;</div><div class="line">    <span class="string">"contacted"</span>: &#123;</div><div class="line">        <span class="string">"localhost"</span>: &#123;</div><div class="line">            <span class="string">"changed"</span>: false,</div><div class="line">            <span class="string">"invocation"</span>: &#123;</div><div class="line">                <span class="string">"module_args"</span>: <span class="string">""</span>,</div><div class="line">                <span class="string">"module_name"</span>: <span class="string">"ping"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"ping"</span>: <span class="string">"pong"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"dark"</span>: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用API实现shell模块功能"><a href="#使用API实现shell模块功能" class="headerlink" title="使用API实现shell模块功能"></a>使用API实现shell模块功能</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">runner = ansible.runner.Runner(</div><div class="line">   module_name=<span class="string">'shell'</span>,</div><div class="line">   module_args=<span class="string">'uptime'</span>,</div><div class="line">   pattern=<span class="string">'localhost'</span>,</div><div class="line">   forks=<span class="number">2</span></div><div class="line">)</div><div class="line">data = runner.run()</div><div class="line"><span class="keyword">print</span> json.dumps(data, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</div><div class="line"></div><div class="line">//stdout</div><div class="line">&#123;</div><div class="line">    <span class="string">"contacted"</span>: &#123;</div><div class="line">        <span class="string">"localhost"</span>: &#123;</div><div class="line">            <span class="string">"changed"</span>: true,</div><div class="line">            <span class="string">"cmd"</span>: <span class="string">"uptime"</span>,</div><div class="line">            <span class="string">"delta"</span>: <span class="string">"0:00:00.002573"</span>,</div><div class="line">            <span class="string">"end"</span>: <span class="string">"2016-11-04 14:57:26.549208"</span>,</div><div class="line">            <span class="string">"invocation"</span>: &#123;</div><div class="line">                <span class="string">"module_args"</span>: <span class="string">"uptime"</span>,</div><div class="line">                <span class="string">"module_name"</span>: <span class="string">"shell"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"rc"</span>: <span class="number">0</span>,</div><div class="line">            <span class="string">"start"</span>: <span class="string">"2016-11-04 14:57:26.546635"</span>,</div><div class="line">            <span class="string">"stderr"</span>: <span class="string">""</span>,</div><div class="line">            <span class="string">"stdout"</span>: <span class="string">" 14:57:26 up 67 days,  3:31,  1 user,  load average: 0.00, 0.06, 0.07"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"dark"</span>: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="打印stdout"><a href="#打印stdout" class="headerlink" title="打印stdout"></a>打印stdout</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(contacted)</span>:</span></div><div class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> contacted.items():</div><div class="line">        <span class="keyword">if</span> k == <span class="string">'stdout'</span>:</div><div class="line">            <span class="keyword">print</span> v</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping_module</span><span class="params">()</span>:</span></div><div class="line">    runner = ansible.runner.Runner(</div><div class="line">        module_name=<span class="string">'ping'</span>,</div><div class="line">        module_args=<span class="string">''</span>,</div><div class="line">        pattern=<span class="string">'localhost'</span>,</div><div class="line">        forks=<span class="number">2</span></div><div class="line">        )</div><div class="line">    data = runner.run()</div><div class="line">    <span class="keyword">print</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_module</span><span class="params">()</span>:</span></div><div class="line">    runner = ansible.runner.Runner(</div><div class="line">        module_name=<span class="string">'shell'</span>,</div><div class="line">        module_args=<span class="string">'uptime'</span>,</div><div class="line">        pattern=<span class="string">'localhost'</span>,</div><div class="line">        forks=<span class="number">2</span></div><div class="line">        )</div><div class="line">    data = runner.run()</div><div class="line">    result(data[<span class="string">'contacted'</span>][<span class="string">'localhost'</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    shell_module()</div><div class="line">    </div><div class="line">//stdout</div><div class="line"><span class="number">15</span>:<span class="number">34</span>:<span class="number">09</span> up <span class="number">67</span> days,  <span class="number">4</span>:<span class="number">07</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></div></pre></td></tr></table></figure>
<h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>playbook描述了在远程主机上执行的策略或一组任务</p>
<p>一个playbook文件由一个或多个play组成，每个play定义了一系列的task，每个task通过ansible的模块来实现特定的功能</p>
<p>exp.yml (<code>playbook使用YAML语言编写，文件名以.yaml或.yml结尾</code>)</p>
<pre><code>- hosts: localhost_group   //主机组
   tasks:
    - name: kernel release info  //task1
      command: uname -a

    - name: memory info  //task2
      shell: free -m
</code></pre><p>这个playbook可以查看远程主机的内核版本信息和内存信息</p>
<h3 id="ansible-playbook命令"><a href="#ansible-playbook命令" class="headerlink" title="ansible-playbook命令"></a>ansible-playbook命令</h3><p>命令行执行playbook</p>
<pre><code>$ ansible-playbook  -i /etc/ansible/hosts  test.yml

PLAY [localhost_group] ********************************************************

GATHERING FACTS ***************************************************************
ok: [localhost]

TASK: [kernel info] ***********************************************************
changed: [localhost]

TASK: [memory info] ***********************************************************
changed: [localhost]

PLAY RECAP ********************************************************************
localhost                  : ok=3    changed=2    unreachable=0    failed=0
</code></pre><h3 id="Python-API-1"><a href="#Python-API-1" class="headerlink" title="Python API"></a>Python API</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># encoding=utf8</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> ansible.runner</div><div class="line"><span class="keyword">import</span> ansible.playbook</div><div class="line"><span class="keyword">import</span> ansible.inventory</div><div class="line"><span class="keyword">from</span> ansible <span class="keyword">import</span> callbacks</div><div class="line"><span class="keyword">from</span> ansible <span class="keyword">import</span> utils</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">playbook_path = <span class="string">"/home/ubuntu/scripts/exp.yml"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##添加主机信息</span></div><div class="line">host = ansible.inventory.host.Host(</div><div class="line">    name = <span class="string">'localhost'</span></div><div class="line">    )</div><div class="line"></div><div class="line"><span class="comment">##设置主机组并添加主机</span></div><div class="line">group = ansible.inventory.group.Group(</div><div class="line">    name = <span class="string">'localhost_group'</span></div><div class="line">    )</div><div class="line">group.add_host(host)</div><div class="line"></div><div class="line"><span class="comment">##主机列表</span></div><div class="line">example_inventory = ansible.inventory.Inventory()</div><div class="line">example_inventory.add_group(group)</div><div class="line"></div><div class="line"><span class="comment">#回调信息</span></div><div class="line">stats = callbacks.AggregateStats()</div><div class="line">playbook_cb = callbacks.PlaybookCallbacks(verbose=utils.VERBOSITY)</div><div class="line">runner_cb = callbacks.PlaybookRunnerCallbacks(stats, verbose=utils.VERBOSITY)</div><div class="line"></div><div class="line"><span class="comment">#创建实例，playbook位于playbook_path</span></div><div class="line">pb = ansible.playbook.PlayBook(</div><div class="line">    playbook = playbook_path,</div><div class="line">    stats = stats,</div><div class="line">    callbacks = playbook_cb,</div><div class="line">    runner_callbacks = runner_cb,</div><div class="line">    inventory = example_inventory,</div><div class="line">    subset = <span class="string">'all'</span>,</div><div class="line">    )</div><div class="line"></div><div class="line"><span class="comment">#运行playbook</span></div><div class="line">pr = pb.run()</div><div class="line"></div><div class="line"><span class="comment">#打印结果</span></div><div class="line"><span class="keyword">print</span> json.dumps(pr, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))</div></pre></td></tr></table></figure>
<p>//stdout</p>
<pre><code>PLAY [localhost_group] ********************************************************

GATHERING FACTS ***************************************************************
ok: [localhost]

TASK: [kernel info] ***********************************************************
changed: [localhost]

TASK: [memory info] ***********************************************************
changed: [localhost]
{
    &quot;localhost&quot;: {
    &quot;changed&quot;: 2,
    &quot;failures&quot;: 0,
    &quot;ok&quot;: 3,
    &quot;skipped&quot;: 0,
    &quot;unreachable&quot;: 0
    }
}
</code></pre><h4 id="ansible-runner更多信息"><a href="#ansible-runner更多信息" class="headerlink" title="ansible.runner更多信息"></a>ansible.runner更多信息</h4><pre><code>&gt;&gt;&gt; import ansible.runner
&gt;&gt;&gt; dir(ansible.runner)
[&apos;C&apos;, &apos;DefaultRunnerCallbacks&apos;, &apos;HAS_ATFORK&apos;, &apos;HostVars&apos;, &apos;ModuleReplacer&apos;, &apos;OUTPUT_LOCKFILE&apos;, &apos;PROCESS_LOCKFILE&apos;, &apos;Queue&apos;, &apos;ReturnData&apos;, &apos;Runner&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;_executor_hook&apos;, &apos;ansible&apos;, &apos;atfork&apos;, &apos;base64&apos;, &apos;check_conditional&apos;, &apos;collections&apos;, &apos;connection&apos;, &apos;errors&apos;, &apos;getpass&apos;, &apos;jinja2&apos;, &apos;module_common&apos;, &apos;module_replacer&apos;, &apos;multiprocessing&apos;, &apos;multiprocessing_runner&apos;, &apos;os&apos;, &apos;pipes&apos;, &apos;poller&apos;, &apos;pwd&apos;, &apos;random&apos;, &apos;return_data&apos;, &apos;signal&apos;, &apos;socket&apos;, &apos;split_args&apos;, &apos;string_functions&apos;, &apos;subprocess&apos;, &apos;sys&apos;, &apos;tempfile&apos;, &apos;template&apos;, &apos;time&apos;, &apos;traceback&apos;, &apos;utils&apos;, &apos;vv&apos;]
&gt;&gt;&gt; help(ansible.runner.Runner)    
</code></pre><h4 id="Python-yaml-模块自定义playbook"><a href="#Python-yaml-模块自定义playbook" class="headerlink" title="Python yaml 模块自定义playbook"></a>Python yaml 模块自定义playbook</h4><p>define_yaml.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> yaml</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">playbook_path = <span class="string">'/home/ubuntu/scripts'</span></div><div class="line"></div><div class="line">Yml_args = &#123;&#125;</div><div class="line">Yml = []</div><div class="line">Yml_args[<span class="string">"gather_facts"</span>] = <span class="keyword">False</span></div><div class="line">Yml_args[<span class="string">"hosts"</span>] = <span class="string">"localhost_group"</span></div><div class="line">Yml_args[<span class="string">"remote_user"</span>] = <span class="string">"ubuntu"</span></div><div class="line">Yml_task = []</div><div class="line">Yml_task.append(&#123;<span class="string">'shell'</span>: <span class="string">'uptime'</span>, <span class="string">'name'</span>: <span class="string">'uptime info'</span>&#125;)</div><div class="line">Yml_task.append(&#123;<span class="string">'shell'</span>: <span class="string">'free -m'</span>, <span class="string">'name'</span>: <span class="string">'memory info'</span>&#125;)</div><div class="line">Yml_args[<span class="string">"tasks"</span>] = Yml_task</div><div class="line">Yml.append(Yml_args)</div><div class="line">Yml = yaml.dump(Yml)</div><div class="line">Yml_path = os.path.join(playbook_path, <span class="string">"exp.yml"</span>)</div><div class="line"><span class="keyword">with</span> open(Yml_path, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(Yml)</div></pre></td></tr></table></figure></p>
<p>运行并检测：</p>
<pre><code>$ python define_yaml.py

$ ansible-playbook  -i /etc/ansible/hosts  exp.yml

PLAY [localhost_group] ********************************************************

TASK: [uptime info] ***********************************************************
changed: [localhost]

TASK: [memory info] ***********************************************************
changed: [localhost]

PLAY RECAP ********************************************************************
localhost                  : ok=2    changed=2    unreachable=0    failed=0

$ cat exp.yml
- gather_facts: false
  hosts: localhost_group
  remote_user: ubuntu
  tasks:
  - {name: uptime info, shell: uptime}
  - {name: memory info, shell: free -m}
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.ansible.com/ansible/dev_guide/developing_api.html" target="_blank" rel="external">Ansible Python API</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/11/01/跨仓库转移SVN代码目录/" class="post-link">跨仓库转移SVN代码目录</a></h2><span class="post-time">Nov 1, 2016</span><div class="post-content"><p>由于公司先前代码管理比较混乱，不同部门之间的代码有放在同一个仓库的，抽空转移了部分并记录备忘。</p>
<h4 id="project项目位于dev仓库的主分支，现需要将他转移到ops仓库主分支"><a href="#project项目位于dev仓库的主分支，现需要将他转移到ops仓库主分支" class="headerlink" title="project项目位于dev仓库的主分支，现需要将他转移到ops仓库主分支"></a>project项目位于dev仓库的主分支，现需要将他转移到ops仓库主分支</h4><blockquote>
<p>old svn: <a href="http://svnserver/svn/dev/trunk/project/" target="_blank" rel="external">http://svnserver/svn/dev/trunk/project/</a></p>
<p>new svn:<a href="http://svnserver/svn/ops/trunk/" target="_blank" rel="external">http://svnserver/svn/ops/trunk/</a></p>
</blockquote>
<p><strong>直接svn move 报错：</strong></p>
<pre><code>$ svn move  http://svnserver/svn/dev/trunk/project/  http://svnserver/svn/ops/trunk/
svn: E200007: Source and destination URLs appear not to point to the same repository.
</code></pre><blockquote>
<p>svn: E200007: Source and destination URLs appear not to point to the same repository. </p>
<p>不同的仓库之间无法直接move或cp项目代码</p>
</blockquote>
<h3 id="转移方法："><a href="#转移方法：" class="headerlink" title="转移方法："></a>转移方法：</h3><p><strong>方法一：</strong></p>
<p>先将old svn项目代码check到本地然后import到new svn中</p>
<ul>
<li><p>缺点：old svn的代码的历史记录都会清空</p>
</li>
<li><p>优点：在客户端本地就能完成</p>
</li>
</ul>
<p>操作如下：</p>
<pre><code>$ svn --username=abner.zhao checkout http://svnserver/svn/dev/trunk/project/ project
$ svn import project  svn:http://svnserver/svn/ops/trunk/  -m &apos;import project to trunk&apos;
</code></pre><p><strong>方法二：</strong></p>
<p>将old svn中要迁移的项目代码dump出来，然后load 到new svn中</p>
<ul>
<li><p>优点：保留历史记录</p>
</li>
<li><p>缺点：要到svn服务端上操作</p>
</li>
</ul>
<p>操作如下：</p>
<pre><code>$ svnadmin dump dev | svndumpfilter include /trunk/UDPServer/ --drop-empty-revs --renumber-revs --preserve-revprops &gt; /tmp/project.dump
$ svnadmin load ops &lt; /tmp/project.dump
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://falstaff.agner.ch/2011/11/12/subversion-move-folder-from-one-repository-to-another/" target="_blank" rel="external">subversion-move-folder-from-one-repository-to-another</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/10/29/Python编码风格/" class="post-link">Python编码风格</a></h2><span class="post-time">Oct 29, 2016</span><div class="post-content"><h3 id="标记"><a href="#标记" class="headerlink" title="#!标记"></a>#!标记</h3><blockquote>
<p>大部分.py文件不必以#!作为文件的开始。 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始。 (<code>#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略。因此只有被直接执行的文件中才有必要加入#!</code>)</p>
</blockquote>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><blockquote>
<p>不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
</blockquote>
<h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><blockquote>
<p>每行不超过80个字符</p>
</blockquote>
<h4 id="例外："><a href="#例外：" class="headerlink" title="例外："></a>例外：</h4><ul>
<li>长的导入模块语句</li>
<li>注释里的URL</li>
</ul>
<p>Python会将<code>圆括号、中括号和花括号</code>中的行隐式的连接起来，不要使用反斜杠连接行</p>
<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<pre><code>long_str = (&apos;This will build a very long long&apos;
            &apos;long long long long long long string&apos;)                                 
</code></pre><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><blockquote>
<p>尽量少使用括号，除非实现隐式行，不要在返回语句或条件语句中使用括号，在元组两边可以使用括号</p>
</blockquote>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote>
<p>用4个空格来缩进代码</p>
</blockquote>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>顶级定义（类和函数）之间空两行, 方法定义之间空一行</li>
<li>括号内不要有空格</li>
<li>逗号, 分号, 冒号前面不要加空格，应该在它们后面加(除了在行尾)</li>
<li>参数列表, 索引或切片的左括号前不应加空格</li>
<li>在二元操作符两边都加上一个空格, 比如赋值<code>(=，==， &lt;， &gt;， !=， &lt;&gt;， &lt;=， &gt;=，in， not in， is， is not)， 布尔(and， or， not)</code></li>
<li>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格</li>
<li>不要用空格来垂直对齐多行间的标记，这会成为维护的负担(适用于:, #, =等)</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>文档字符串</li>
</ul>
<blockquote>
<p>使用三重双引号”””(一个文档字符串应该这样组织: 首先是一行以句号，问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行)接着是一个空行。接着是文档字符串剩下的部分， 它应该与文档字符串的第一行的第一个引号对齐 )</p>
</blockquote>
<ul>
<li>函数和方法</li>
</ul>
<blockquote>
<p>函数必须要有文档字符串，除非它外部不可见、非常短小、简单明了。文档字符串应该包含函数做什么, 以及输入和输出的详细描述</p>
</blockquote>
<p><strong>Args:</strong></p>
<p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.描述应该包括所需的类型和含义，如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)</p>
<p><strong>Returns: (或者 Yields: 用于生成器)</strong></p>
<p>描述返回值的类型和语义。如果函数返回None, 这一部分可以省略</p>
<p><strong>Raises:</strong></p>
<p>列出与接口有关的所有异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></div><div class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></div><div class="line"></div><div class="line">    Retrieves rows pertaining to the given keys from the Table instance</div><div class="line">    represented by big_table.  Silly things may happen if</div><div class="line">    other_silly_variable is not None.</div><div class="line"></div><div class="line">    Args:</div><div class="line">        big_table: An open Bigtable Table instance.</div><div class="line">        keys: A sequence of strings representing the key of each table row</div><div class="line">        to fetch.</div><div class="line">        other_silly_variable: Another optional variable, that has a much</div><div class="line">        longer name than the other args, and which does nothing.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        A dict mapping keys to the corresponding table row data</div><div class="line">        fetched. Each row is represented as a tuple of strings. For</div><div class="line">        example:</div><div class="line"></div><div class="line">        &#123;'Serak': ('Rigel VII', 'Preparer'),</div><div class="line">        'Zim': ('Irk', 'Invader'),</div><div class="line">        'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</div><div class="line"></div><div class="line">        If a key from the keys argument is missing from the dictionary,</div><div class="line">        then that row was not found in the table.</div><div class="line"></div><div class="line">    Raises:</div><div class="line">        IOError: An error occurred accessing the bigtable.Table object.</div><div class="line">    """</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段。并且应该遵守和函数参数相同的格式</p>
<pre><code class="python">
<span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span>
    <span class="string">"""Summary of class here.

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    """</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span>
        <span class="string">"""Inits SampleClass with blah."""</span>
        self.likes_spam = likes_spam
        self.eggs = <span class="number">0</span>

    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span>
        <span class="string">"""Performs operation blah."""</span>
</code></pre>
<blockquote>
<p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串</li>
</ul>
<blockquote>
<p>避免在循环中用+和+=操作符来累加字符串，字符串是不可变的，这样做会创建不必要的临时对象。作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表</p>
</blockquote>
<ul>
<li><p>在同一个文件中, 保持使用字符串引号的一致性(使用单引号’或者双引号”)</p>
</li>
<li><p>为多行字符串使用三重双引号”“”</p>
</li>
</ul>
<h3 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h3><blockquote>
<p>在文件和sockets结束时, 显式的关闭它，文件使用<code>with</code></p>
</blockquote>
<h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><blockquote>
<p>为临时代码使用TODO注释</p>
</blockquote>
<p>TODO注释应该在所有开头处包含”TODO”字符串，紧跟着是用括号括起来的你的名字，email地址或其它标识符。然后是一个可选的冒号。接着必须有一行注释，解释要做什么.</p>
<pre><code># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.
# TODO(Zeke) Change this to use relations.
</code></pre><h3 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h3><blockquote>
<p>每个导入应该独占一行</p>
</blockquote>
<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p>
<pre><code>1.标准库导入
2.第三方库导入
3.应用程序指定导入
</code></pre><p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<pre><code>import foo
from foo import bar
from foo.bar import baz
from foo.bar import Quux
from Foob import ar
</code></pre><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><blockquote>
<p>通常每个语句应该独占一行</p>
</blockquote>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>
<p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><blockquote>
<p>`module_name, package_name, ClassName, method_name, ExceptionName, function_name,</p>
<p> GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.`</p>
</blockquote>
<p>应该避免的名称</p>
<ul>
<li>单字符名称, 除了计数器和迭代器</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ul>
<p>命名约定</p>
<ul>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含)</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有</li>
<li>将相关的类和顶级函数放在同一个模块里</li>
<li>对类名使用大写字母开头的单词(如CapWords), 但是模块名应该用小写加下划线的方式(如lower_with_under.py)</li>
</ul>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code></p>
<pre><code>def main():
  ...

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="external">Google 开源项目风格指南</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/06/16/ss/" class="post-link">ss获取内核状态信息</a></h2><span class="post-time">Jun 16, 2016</span><div class="post-content"><h2 id="一、ss-简介"><a href="#一、ss-简介" class="headerlink" title="一、ss 简介"></a>一、ss 简介</h2><blockquote>
<p>ss  is  used to dump socket statistics. It allows showing information similar to netstat.  It can dis‐<br>       play more TCP and state informations than other tools.</p>
<p>The ss command is capable of showing more information than the netstat and is faster. The netstat command reads various /proc files to gather information. However this approach falls weak when there are lots of connections to display. This makes it slower.</p>
<p>The ss command gets its information directly from kernel space. The options used with the ss commands are very similar to netstat making it an easy replacement.</p>
</blockquote>
<p>ss 命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但 ss 的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p>
<p>ss 利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。</p>
<h3 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1 选项"></a>1.1 选项</h3><pre><code>Usage: ss [ OPTIONS ]
    ss [ OPTIONS ] [ FILTER ]
-h, --help      this message
-V, --version   output version information
-n, --numeric   don&apos;t resolve service names  #不解析服务名称，以数字方式显示
-a, --all       display all sockets #显示所有的套接字
-l, --listening display listening sockets #显示处于监听状态的套接字
-o, --options       show timer information #显示计时器信息
-m, --memory        show socket memory usage #显示套接字的内存使用情况
-p, --processes show process using socket #显示使用套接字的进程信息
-i, --info      show internal TCP information #显示内部TCP信息
-t, --tcp       display only TCP sockets #只显示TCP套接字
-u, --udp       display only UDP sockets #只显示UDP套接字
-d, --dccp      display only DCCP sockets #只显示DCCP套接字
-w, --raw       display only RAW sockets #只显示RAW套接字
-x, --unix      display only Unix domain sockets #只显示UNIX域套接字
</code></pre><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><h3 id="2-1-显示所有的连接"><a href="#2-1-显示所有的连接" class="headerlink" title="2.1 显示所有的连接"></a>2.1 显示所有的连接</h3><pre><code># ss | more
Netid  State      Recv-Q Send-Q   Local Address:Port       Peer Address:Port
u_str  ESTAB      0      0      /var/run/dbus/system_bus_socket 24643                 * 39740
u_str  ESTAB      0      0                    * 26693                 * 26694
u_str  ESTAB      0      0                    * 26683                 * 39746
u_str  ESTAB      0      0      @/com/ubuntu/upstart 16419                 * 101
u_str  ESTAB      0      0      /var/run/mysqld/mysqld.sock 23234                 * 8691
......
</code></pre><h3 id="2-2-过滤TCP、UDP和UNIX域套接字"><a href="#2-2-过滤TCP、UDP和UNIX域套接字" class="headerlink" title="2.2 过滤TCP、UDP和UNIX域套接字"></a>2.2 过滤TCP、UDP和UNIX域套接字</h3><pre><code># ss -t  //仅显示建立的tcp连接
State      Recv-Q Send-Q                      Local Address:Port                          Peer Address:Port
ESTAB      0      0                               127.0.0.1:59954                            127.0.0.1:2633
ESTAB      0      0                               127.0.0.1:2633                             127.0.0.1:59954
ESTAB      0      148                          10.249.7.247:ssh                          10.249.23.101:50285
# ss -ta //显示tcp连接的所有状态
State      Recv-Q Send-Q                      Local Address:Port                          Peer Address:Port
LISTEN     0      128                                     *:40861                                    *:*
LISTEN     0      15                                      *:2633                                     *:*
LISTEN     0      50                              127.0.0.1:mysql                                    *:*
ESTAB      0      0                               127.0.0.1:59956                            127.0.0.1:2633
TIME-WAIT  0      0                               127.0.0.1:2633                             127.0.0.1:59951
# ss -u
# ss -ua
# ss -x
# ss -ltu //查看处于监听状态的tcp和udp连接
</code></pre><h3 id="2-3-显示-Sockets-摘要"><a href="#2-3-显示-Sockets-摘要" class="headerlink" title="2.3 显示 Sockets 摘要"></a>2.3 显示 Sockets 摘要</h3><pre><code># ss -s
Total: 168 (kernel 1734)
TCP:   22 (estab 1, closed 9, orphaned 0, synrecv 0, timewait 8/0), ports 0

Transport Total     IP        IPv6
*     1734      -         -
RAW   0         0         0
UDP   10        7         3
TCP   13        10        3
INET      23        17        6
FRAG      0         0         0
</code></pre><h3 id="2-4-查看进程使用的Socket"><a href="#2-4-查看进程使用的Socket" class="headerlink" title="2.4 查看进程使用的Socket"></a>2.4 查看进程使用的Socket</h3><pre><code># ss -plt
State      Recv-Q Send-Q                      Local Address:Port                          Peer Address:Port
LISTEN     0      128                                     *:40861                                    *:*        users:((&quot;rpc.statd&quot;,1325,9))
LISTEN     0      15                                      *:2633                                     *:*        users:((&quot;oned&quot;,2204,26))
LISTEN     0      50                              127.0.0.1:mysql                                    *:*        users:((&quot;mysqld&quot;,1525,10))
LISTEN     0      100                          10.249.7.247:9869                                     *:*        users:((&quot;ruby&quot;,2070,8))
LISTEN     0      128                                     *:sunrpc                                   *:*        users:((&quot;rpcbind&quot;,1319,8))
LISTEN     0      100                                     *:29876                                    *:*        users:((&quot;python&quot;,2054,0))
</code></pre><h3 id="2-5-根据TCP状态过滤连接"><a href="#2-5-根据TCP状态过滤连接" class="headerlink" title="2.5 根据TCP状态过滤连接"></a>2.5 根据TCP状态过滤连接</h3><pre><code># ss [ OPTIONS ] [ STATE-FILTER ] [ ADDRESS-FILTER ]
# ss -t4 state established
Recv-Q Send-Q                           Local Address:Port                               Peer Address:Port
0      148                               10.249.7.247:ssh                               10.249.23.101:50285
0      0                                    127.0.0.1:60035                                 127.0.0.1:2633
0      0                                    127.0.0.1:2633                                  127.0.0.1:60035
# ss -t4 state time-wait
Recv-Q Send-Q                           Local Address:Port                               Peer Address:Port
0      0                                    127.0.0.1:2633                                  127.0.0.1:60033
0      0                                 10.249.7.247:9869                              10.249.23.101:60243
0      0                                 10.249.7.247:9869                              10.249.23.101:60248
0      0                                 10.249.7.247:9869                              10.249.23.101:60239
0      0                                 10.249.7.247:9869                              10.249.23.101:60245
</code></pre><p>状态如下：</p>
<blockquote>
<p>1.established</p>
<p>2.syn-sent </p>
<p>3.syn-recv </p>
<p>4.fin-wait-1  </p>
<p>5.fin-wait-2 </p>
<p>6.time-wait </p>
<p>7.closed </p>
<p>8.close-wait </p>
<p>9.last-ack </p>
<p>10.closing </p>
<p>11.all - All of the above states </p>
<p>12.connected - All the states except for listen and closed </p>
<p>13.synchronized - All the connected states except for syn-sent </p>
<p>14.bucket - Show states, which are maintained as minisockets, i.e. time-wait and syn-recv. </p>
<p>15.big - Opposite to bucket state.</p>
</blockquote>
<h3 id="2-6-根据IP地址和端口过滤连接"><a href="#2-6-根据IP地址和端口过滤连接" class="headerlink" title="2.6 根据IP地址和端口过滤连接"></a>2.6 根据IP地址和端口过滤连接</h3><pre><code># ss -at &apos;( dport = :ssh or sport = :ssh )&apos;
# ss -nt  dst :443 or dst :80 
# ss -nt dst 74.125.236.178
</code></pre><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="http://www.binarytides.com/linux-ss-command/" target="_blank" rel="external">10 examples of Linux ss command to monitor network connections</a><br><a href="http://man.linuxde.net/ss" target="_blank" rel="external">ss 命令详解</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/06/12/raid_states/" class="post-link">raid磁盘状态备忘</a></h2><span class="post-time">Jun 12, 2016</span><div class="post-content"><h3 id="Physical-Drive-States"><a href="#Physical-Drive-States" class="headerlink" title="Physical Drive States"></a>Physical Drive States</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/54211F71-8626-4FEE-A37D-91E5F1464B74.png" alt=""></p>
<p>Unconfigured Good：表示该硬盘为空闲硬盘,没有加入到raid阵列中也没有设置为热备盘</p>
<p>Unconfigured Bad：表示该硬盘为空闲硬盘且硬盘有损坏</p>
<p>Rebuild:表示该盘正在重建数据</p>
<p>Foreign:表示该盘有外来的阵列信息，需要清除原来的阵列信息才能配置</p>
<p>readly –&gt; online  [ foreign –&gt; readly –&gt; online ]</p>
<h3 id="Virtual-Disk-States"><a href="#Virtual-Disk-States" class="headerlink" title="Virtual Disk States"></a>Virtual Disk States</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/AB6872BA-666F-4EEE-A33C-4B0FE067ED95.png" alt=""></p>
<p>Virtual Disk States：指的是由物理硬盘做完raid后的虚拟磁盘（逻辑磁盘）</p>
<p>Optimal:表示整个raid的状态正常</p>
<p>Degraded:表示有一块物理硬盘出错或下线，导致raid进入降级模式</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="ftp://ftp.sgi.com/public/Technical%20Support/Pdf%20files/LSI/84016E_mr_sas_sw_ug.pdf" target="_blank" rel="external">megacli_user_guide.pdf</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/06/07/cpuinfo/" class="post-link">cpuinfo</a></h2><span class="post-time">Jun 7, 2016</span><div class="post-content"><h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h3><blockquote>
<p> Information about the processor, such as its type, make, model, and performance.</p>
</blockquote>
<h3 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h3><h4 id="CPU型号"><a href="#CPU型号" class="headerlink" title="CPU型号"></a>CPU型号</h4><pre><code># cat /proc/cpuinfo | grep vendor | uniq
vendor_id   : GenuineIntel
#  cat /proc/cpuinfo | grep &apos;model name&apos; | uniq
model name  : Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz
</code></pre><h4 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h4><pre><code># lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
......
</code></pre><h4 id="物理CPU个数"><a href="#物理CPU个数" class="headerlink" title="物理CPU个数"></a>物理CPU个数</h4><pre><code># cat /proc/cpuinfo | grep &quot;physical id&quot; | sort -u | wc -l
2
</code></pre><h4 id="单个物理CPU中Core个数"><a href="#单个物理CPU中Core个数" class="headerlink" title="单个物理CPU中Core个数"></a>单个物理CPU中Core个数</h4><pre><code># cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq
cpu cores   : 8
</code></pre><h4 id="所有物理CPU上的Core个数（core-id-数量）"><a href="#所有物理CPU上的Core个数（core-id-数量）" class="headerlink" title="所有物理CPU上的Core个数（core id 数量）"></a>所有物理CPU上的Core个数（core id 数量）</h4><pre><code># cat /proc/cpuinfo | grep &quot;core id&quot; | uniq |  wc -l
32
</code></pre><h4 id="逻辑CPU个数"><a href="#逻辑CPU个数" class="headerlink" title="逻辑CPU个数"></a>逻辑CPU个数</h4><pre><code># cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l
32
</code></pre><h4 id="超线程（HT）技术"><a href="#超线程（HT）技术" class="headerlink" title="超线程（HT）技术"></a>超线程（HT）技术</h4><blockquote>
<p>number of processing units = number of cores [ no hyper threading ] </p>
<p>number of processing units = number of cores * 2 [ hyper threading present ]</p>
</blockquote>
<pre><code># cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq
cpu cores   : 8
# cat /proc/cpuinfo | grep &quot;siblings&quot; | sort -u
siblings    : 16
# lscpu | grep Thread
Thread(s) per core:    2
</code></pre><h4 id="重要字段含义"><a href="#重要字段含义" class="headerlink" title="重要字段含义"></a>重要字段含义</h4><ul>
<li>processor 逻辑处理器的唯一标识符</li>
<li>physical id 每个物理封装的唯一标识符</li>
<li>core id 每个内核的唯一标识符</li>
<li>siblings 位于相同物理封装中的逻辑处理器的数量</li>
<li>cpu cores 位于相同物理封装中的内核数量</li>
</ul>
<p>各字段关系如下图所示：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/5793DDE2-40C0-4147-AD14-C85C1574C2DE.png" alt=""> </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.binarytides.com/linux-check-processor/" target="_blank" rel="external">How to check processor and cpu details on Linux</a><br><a href="https://www.centos.org/docs/5/html/5.1/Deployment_Guide/s2-proc-cpuinfo.html" target="_blank" rel="external">Deployment_Guide/s2-proc-cpuinfo</a><br><a href="http://blog.csdn.net/sycflash/article/details/6643492" target="_blank" rel="external">CPU信息/proc/cpuinfo</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/27/iostat/" class="post-link">iostat查看磁盘IO信息</a></h2><span class="post-time">May 27, 2016</span><div class="post-content"><h3 id="一、iostat简介"><a href="#一、iostat简介" class="headerlink" title="一、iostat简介"></a>一、iostat简介</h3><blockquote>
<p>iostat - Report Central Processing Unit (CPU) statistics and input/out-put statistics for devices and partitions.</p>
</blockquote>
<p>iostat 用于输出CPU和磁盘I/O相关的统计信息。</p>
<p>选项如下：</p>
<pre><code>-c     The  -c  option  is exclusive of the -d option and displays only
       the CPU usage report.  //仅显示CPU统计信息，与-d选项互斥

-d     The -d option is exclusive of the -c option  and  displays  only
       the device utilization report. //仅显示磁盘统计信息，与-c选项互斥

-k     Display statistics in kilobytes per second instead of blocks per
       second.  Data displayed are valid  only  with  kernels  2.4  and
       newer. // 以KB为单位显示每秒的磁盘请求数，默认单位块

 -p device | ALL
       The -p option is exclusive of the -x option and displays statis-
       tics for block devices and all their partitions that are used by
       the  system.   If  a device name is entered on the command line,
       then statistics for it and all  its  partitions  are  displayed.
       Last,  the ALL keyword indicates that statistics have to be dis-
       played for all the block devices and partitions defined  by  the
       system,  including  those  that have never been used.  Note that
       this option works only with post 2.5 kernels. 
       // 用于显示块设备及系统分区的统计信息，与-x选项互斥

-t     Print the time for each report displayed.

-V     Print version number and usage then exit.

-x     Display extended statistics.  This option is exclusive of the -p
       one,   and   works   with   post  2.5  kernels  since  it  needs
       /proc/diskstats file or a mounted sysfs to get  the  statistics.
       This  option may also work with older kernels (e.g. 2.4) only if
       extended statistics are available in /proc/partitions (the  ker-
       nel needs to be patched for that).
</code></pre><h3 id="二、iostat的简单使用"><a href="#二、iostat的简单使用" class="headerlink" title="二、iostat的简单使用"></a>二、iostat的简单使用</h3><pre><code># iostat  // 显示CPU和设备吞吐率的统计信息
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
            0.05    0.00    0.07    0.01    0.00   99.87

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               0.76         3.69        12.60   60628026  206899224
</code></pre><p>输出项说明：</p>
<p>%user:  在用户级别运行所使用的 CPU 的百分比。</p>
<p>%nice:  nice 操作所使用的 CPU 的百分比。</p>
<p>%system:    在核心级别（kernel）运行所使用 CPU 的百分比。</p>
<p>%iowait:    CPU 等待硬件 I/O 所占用 CPU 的百分比。</p>
<p>%steal: 当管理程序（hypervisor）为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比。</p>
<p>%idle:  CPU 空闲时间的百分比。</p>
<p>tps:    每秒钟物理设备的 I/O 传输总量。</p>
<p>[MB/KB/B]lk_read:   读入的数据总量，单位为MB/KB/块。</p>
<p>[MB/KB/B]lk_wrtn    :写入的数据总量，单位为MB/KB/块。</p>
<p>[MB/KB/B]lk_read/s: 每秒从驱动器读入的数据量，单位为MB/KB/块。</p>
<p>[MB/KB/B]lk_wrtn/s: 每秒向驱动器写入的数据量，单位为MB/KB/块。</p>
<pre><code># iostat -d 2  //每隔2秒显示一次设备吞吐率的统计信息（单位为 块/s）
# iostat -dk 2 //每隔2秒显示一次设备吞吐率的统计信息（单位为 KB/s）
# iostat -dk 2 3 // 每隔2秒显示一次，共显示3次

# iostat -x sda  //显示 sda 设备扩展统计信息
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
            0.05    0.00    0.07    0.01    0.00   99.87

Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.00     0.86    0.05    0.72     3.69    12.60    21.36     0.00    1.83   0.75   0.06
# iostat -p sda  //显示sda 及上面所有分区的统计信息
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
            0.05    0.00    0.07    0.01    0.00   99.87

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               0.76         3.69        12.60   60628026  206904888
sda1              0.00         0.00         0.00       4994        512
sda2              0.04         3.52         2.22   57853834   36386304
sda3              0.72         0.17        10.38    2763066  170501848
sda4              0.00         0.00         0.00         20          0
sda5              0.00         0.00         0.00       4816      16224
</code></pre><p>输出项说明：</p>
<p>rrqm/s: 将读入请求合并后，每秒发送到设备的读入请求数。</p>
<p>wrqm/s: 将写入请求合并后，每秒发送到设备的写入请求数。</p>
<p>r/s:    每秒发送到设备的读入请求数。</p>
<p>w/s:    每秒发送到设备的写入请求数。</p>
<p>rsec/s: 每秒从设备读入的扇区数。</p>
<p>wsec/s: 每秒向设备写入的扇区数。</p>
<p>rkB/s:  每秒从设备读入的数据量，单位为 KB/s。</p>
<p>wkB/s:  每秒向设备写入的数据量，单位为 KB/s。</p>
<p>rMB/s:  每秒从设备读入的数据量，单位为 MB/s。</p>
<p>wMB/s:  每秒向设备写入的数据量，单位为 MB/s。</p>
<p>avgrq-sz:   发送到设备的请求的平均大小，单位为扇区。</p>
<p>avgqu-sz:   发送到设备的请求的平均队列长度。</p>
<p>await:  I/O请求平均执行时间。包括发送请求和执行的时间。单位为毫秒。</p>
<p>svctm:  发送到设备的I/O请求的平均执行时间。单位为毫秒。</p>
<p>%util:  在I/O请求发送到设备期间，占用CPU时间的百分比。用于显示设备的带宽利用率。当这个值接近100%时，表示设备带宽已经占满。</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/26/sar/" class="post-link">sar系统状态信息统计</a></h2><span class="post-time">May 26, 2016</span><div class="post-content"><h3 id="一、sar-简介"><a href="#一、sar-简介" class="headerlink" title="一、sar 简介"></a>一、sar 简介</h3><blockquote>
<p>sar - Collect, report, or save system activity information.</p>
<p>Usage: sar [ options ] [ interval  count  ]    </p>
<p> sar 选项 [输出间隔时间] [输出次数(默认为1)]</p>
</blockquote>
<p>sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。</p>
<p>sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</p>
<pre><code># cat /etc/cron.d/sysstat
# Run system activity accounting tool every 10 minutes
*/10 * * * * root /usr/lib64/sa/sa1 1 1
# Generate a daily summary of process accounting at 23:53
53 23 * * * root /usr/lib64/sa/sa2 -A   //将当天的汇总信息写入文件 /var/log/sa/saDD

sa1: stores system activities in binary data file. sa1 depends on sadc for this purpose. sa1 runs from cron.
sa2: creates daily summary of the collected statistics. sa2 runs from cron.
</code></pre><h3 id="二、sar-常用命令"><a href="#二、sar-常用命令" class="headerlink" title="二、sar 常用命令"></a>二、sar 常用命令</h3><h4 id="2-1-CPU-Usage"><a href="#2-1-CPU-Usage" class="headerlink" title="2.1 CPU Usage"></a>2.1 CPU Usage</h4><blockquote>
<p>sar -u:   Displays CPU usage for the current day that was collected until that point.</p>
<p>sar -u ALL:  Same as “sar -u” but displays additional fields.</p>
<p>sar -P ALL:  indicates that it should displays statistics for ALL the individual Cores.</p>
<p>sar -u -f /var/log/sa/sa10:  Displays CPU usage for the 10day of the month from the sa10 file.</p>
</blockquote>
<pre><code># sar -u  1 3
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/24/2016  _x86_64_    (2 CPU)

06:23:59 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
06:24:00 PM     all      0.00      0.00      0.00      0.00      0.00    100.00
06:24:01 PM     all      0.00      0.00      0.50      0.00      0.00     99.50
06:24:02 PM     all      0.50      0.00      0.50      0.00      0.00     99.00
Average:        all      0.17      0.00      0.33      0.00      0.00     99.50

# sar -P ALL 1 1
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/24/2016  _x86_64_    (2 CPU)

06:28:13 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
06:28:14 PM     all      0.00      0.00      0.00      0.00      0.00    100.00
06:28:14 PM       0      0.00      0.00      0.00      0.00      0.00    100.00
06:28:14 PM       1      0.00      0.00      0.00      0.00      0.00    100.00

Average:        CPU     %user     %nice   %system   %iowait    %steal     %idle
Average:        all      0.00      0.00      0.00      0.00      0.00    100.00
Average:          0      0.00      0.00      0.00      0.00      0.00    100.00
Average:          1      0.00      0.00      0.00      0.00      0.00    100.00

%iowait: Percentage of time that the CPU or CPUs were idle during which the  system  had an outstanding disk I/O request.
         显示用于等待I/O操作占用 CPU 总时间的百分比，若该值过高则表示硬盘存在I/O瓶颈
%idle: Percentage of time that the CPU or CPUs were idle and the system did  not  have an outstanding disk I/O request.
         显示 CPU 空闲时间占用 CPU 总时间的百分比。
</code></pre><h4 id="2-2-Memory-Free-and-Used"><a href="#2-2-Memory-Free-and-Used" class="headerlink" title="2.2 Memory Free and Used"></a>2.2 Memory Free and Used</h4><blockquote>
<p> sar -r : Report memory utilization statistics.</p>
</blockquote>
<pre><code># sar -r 1 3
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/25/2016  _x86_64_    (2 CPU)

10:20:16 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
10:20:17 AM    157356   1764852     91.81    207948   1288836    791016      7.82
10:20:18 AM    157356   1764852     91.81    207948   1288836    791016      7.82
10:20:19 AM    157356   1764852     91.81    207948   1288836    791016      7.82
Average:       157356   1764852     91.81    207948   1288836    791016      7.82
</code></pre><h4 id="2-3-Swap-Space-Used"><a href="#2-3-Swap-Space-Used" class="headerlink" title="2.3 Swap Space Used"></a>2.3 Swap Space Used</h4><blockquote>
<p>sar -S: Reports  swap statistics.</p>
</blockquote>
<pre><code># sar -S 1 3
Linux 2.6.32-573.el6.x86_64 (Mr-zhao)   05/26/2016  _x86_64_    (2 CPU)

10:05:34 AM kbswpfree kbswpused  %swpused  kbswpcad   %swpcad
10:05:35 AM   8183488      7484      0.09       532      7.11
10:05:36 AM   8183488      7484      0.09       532      7.11
10:05:37 AM   8183488      7484      0.09       532      7.11
Average:      8183488      7484      0.09       532      7.11
</code></pre><h4 id="2-4-Overall-I-O-Activities"><a href="#2-4-Overall-I-O-Activities" class="headerlink" title="2.4 Overall I/O Activities"></a>2.4 Overall I/O Activities</h4><blockquote>
<p>sar -b: reports I/O statistics.</p>
</blockquote>
<pre><code># sar -b 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:12:27 AM       tps      rtps      wtps   bread/s   bwrtn/s
10:12:28 AM     49.49      0.00     49.49      0.00    412.12
10:12:29 AM      0.00      0.00      0.00      0.00      0.00
10:12:30 AM      0.00      0.00      0.00      0.00      0.00
Average:        16.39      0.00     16.39      0.00    136.45
</code></pre><h4 id="2-5-Individual-Block-Device-I-O-Activities"><a href="#2-5-Individual-Block-Device-I-O-Activities" class="headerlink" title="2.5 Individual Block Device I/O Activities"></a>2.5 Individual Block Device I/O Activities</h4><blockquote>
<p>sar -d: To identify the activities by the individual block devices </p>
<p> -p: Pretty-print  device names</p>
</blockquote>
<pre><code># sar -d 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:17:42 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:17:43 AM    dev8-0      1.98      0.00    847.52    428.00      0.01      3.00      1.50      0.30

10:17:43 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:17:44 AM    dev8-0      3.00      0.00     96.00     32.00      0.00      0.00      0.00      0.00

10:17:44 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:17:45 AM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average:       dev8-0      1.67      0.00    317.33    190.40      0.00      1.20      0.60      0.10
# sar -dp 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:21:36 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:21:37 AM       sda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

10:21:37 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:21:38 AM       sda     10.00      0.00    184.00     18.40      0.00      0.30      0.30      0.30

10:21:38 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:21:39 AM       sda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average:          sda      3.36      0.00     61.74     18.40      0.00      0.30      0.30      0.10
</code></pre><h4 id="2-6-Display-context-switch-per-second"><a href="#2-6-Display-context-switch-per-second" class="headerlink" title="2.6 Display context switch per second"></a>2.6 Display context switch per second</h4><blockquote>
<p>sar -w: Reports the total number of processes created per second, and total number of context switches per second.    </p>
</blockquote>
<pre><code># sar -w 1 3
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

10:33:49 AM    proc/s   cswch/s
10:33:50 AM      8.08    732.32
10:33:51 AM     10.00    964.00
10:33:52 AM      8.08    686.87
Average:         8.72    794.97
</code></pre><h4 id="2-7-Reports-run-queue-and-load-average"><a href="#2-7-Reports-run-queue-and-load-average" class="headerlink" title="2.7 Reports run queue and load average"></a>2.7 Reports run queue and load average</h4><blockquote>
<p>sar -q: Reports the run queue size and load average of last 1 minute, 5 minutes, and 15 minutes.</p>
</blockquote>
<pre><code># sar -q 1 3
Linux 2.6.32-504.el6.x86_64 (tjtx-83-97.58os.org)   05/26/2016  _x86_64_    (32 CPU)

10:58:55 AM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15
10:58:56 AM         4       874      0.79      0.58      0.51
10:58:57 AM         0       873      0.79      0.58      0.51
10:58:58 AM         0       865      0.79      0.58      0.51
Average:            1       871      0.79      0.58      0.51
</code></pre><h4 id="2-8-Report-network-statistics"><a href="#2-8-Report-network-statistics" class="headerlink" title="2.8 Report network statistics"></a>2.8 Report network statistics</h4><blockquote>
<p>sar  -n { keyword [,…] | ALL } : Report network statistics.</p>
<p>Possible  keywords  are  DEV,  EDEV, NFS, NFSD, SOCK, IP, EIP, ICMP, EICMP, TCP, ETCP,<br>              UDP, SOCK6, IP6, EIP6, ICMP6, EICMP6 and UDP6.</p>
<p>   DEV – Displays network devices vital statistics for eth0, eth1, etc.</p>
</blockquote>
<pre><code># sar -n DEV 1 1
Linux 2.6.32-504.23.4.el6.x86_64 (tjtx-93-96.58os.org)  05/26/2016  _x86_64_    (24 CPU)

11:06:32 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
11:06:33 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:06:33 AM      eth0    175.76    173.74     27.92     31.94      0.00      0.00      0.00
11:06:33 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:06:33 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:06:33 AM      eth3      0.00      0.00      0.00      0.00      0.00      0.00      0.00


Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth0    175.76    173.74     27.92     31.94      0.00      0.00      0.00
Average:         eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth3      0.00      0.00      0.00      0.00      0.00      0.00      0.00
# sar -n DEV  | grep eth0
</code></pre><h4 id="2-9-Report-Sar-Data-Using-Start-Time"><a href="#2-9-Report-Sar-Data-Using-Start-Time" class="headerlink" title="2.9 Report Sar Data Using Start Time"></a>2.9 Report Sar Data Using Start Time</h4><blockquote>
<p>-s [ hh:mm:ss ]</p>
<p>   Set  the  starting  time of the data, causing the sar command to extract records time-<br>              tagged at, or following, the time specified.</p>
<p>When you view historic sar data from the /var/log/sa/saXX file using “sar -f” option, it displays all the sar data for that specific day starting from 12:00 a.m for that day.</p>
<p>Using “-s hh:mi:ss” option, you can specify the start time. For example, if you specify “sar -s 10:00:00”, it will display the sar data starting from 10 a.m (instead of starting from midnight) as shown below.</p>
</blockquote>
<pre><code># sar -q -f /var/log/sa/sa23 -s 10:00:01
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.thegeekstuff.com/2011/03/sar-examples/" target="_blank" rel="external">10 Useful Sar (Sysstat) Examples for UNIX / Linux Performance Monitoring</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/23/screen/" class="post-link">Screen会话管理</a></h2><span class="post-time">May 23, 2016</span><div class="post-content"><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<p><a href="http://www.gnu.org/software/screen/" target="_blank" rel="external">GNU’s Screen 官方站点</a></p>
<h3 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h3><h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。对于远程登录的用户即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。</p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p>
<h4 id="会话共享"><a href="#会话共享" class="headerlink" title="会话共享"></a>会话共享</h4><p>Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。</p>
<h3 id="三、常用参数"><a href="#三、常用参数" class="headerlink" title="三、常用参数"></a>三、常用参数</h3><pre><code>screen -S yourname   //新建一个叫yourname的session
screen -ls（或者screen -list） //列出当前所有的session
screen -r yourname  //回到yourname这个session
screen -d yourname   //远程detach某个session，转移到当前终端
screen -d -r yourname  //结束当前session并回到yourname这个session

ctrl+a x -&gt; 锁住当前的 window，需用用户密码解锁
ctrl-a k -&gt; kill window，强行关闭当前的 window
ctrl+a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响
</code></pre><h3 id="四、使用实例"><a href="#四、使用实例" class="headerlink" title="四、使用实例"></a>四、使用实例</h3><h4 id="创建新窗口"><a href="#创建新窗口" class="headerlink" title="创建新窗口"></a>创建新窗口</h4><pre><code># screen  -S text   // 创建一个名字为text的会话，会打开一个默认的shell环境（一般都是bash shell）
# vi file.txt
</code></pre><p>或</p>
<pre><code># screen vi file.txt   //退出vi将退出该会话
</code></pre><h3 id="会话分离与恢复"><a href="#会话分离与恢复" class="headerlink" title="会话分离与恢复"></a>会话分离与恢复</h3><p>在screen窗口键入C-a d，Screen会给出detached，暂时中断会话。</p>
<p>找到并恢复会话：</p>
<pre><code># screen -ls    //查看当前会话
There is a screen on:
10526.test  (05/23/2016 07:48:58 PM)    (Detached)
1 Socket in /var/run/screen/S-root. 

# screen -r  test  // 进入被中断的会话，screen的名字和编号都行
</code></pre><h4 id="清除-dead会话"><a href="#清除-dead会话" class="headerlink" title="清除 dead会话"></a>清除 dead会话</h4><pre><code># screen -wipe
</code></pre><h4 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h4><pre><code>Ctrl-a k  // kill会话，同时kill会话里的进程
Ctrl-a :   // 然后输入quit命令退出Screen会话,会杀死所有窗口并退出其中运行的所有程序
</code></pre><h3 id="会话共享-1"><a href="#会话共享-1" class="headerlink" title="会话共享"></a>会话共享</h3><pre><code># screen -x  screenname

-x  Attach to a not detached screen. (Multi display mode).
</code></pre></div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/20/opennebula-life-cycle/" class="post-link">OpenNebula life-cycle</a></h2><span class="post-time">May 20, 2016</span><div class="post-content"><h3 id="OpenNebula-Virtual-Machine-Life-cycle"><a href="#OpenNebula-Virtual-Machine-Life-cycle" class="headerlink" title="OpenNebula Virtual Machine Life-cycle"></a>OpenNebula Virtual Machine Life-cycle</h3><p><img src="http://docs.opennebula.org/4.14/_images/states-simple.png" alt=""></p>
<p>具体状态详情请参考：<a href="http://docs.opennebula.org/4.14/user/virtual_resource_management/vm_guide_2.html" target="_blank" rel="external">vm_guide_2</a></p>
<h3 id="OpenNebula-Host-Life-cycle"><a href="#OpenNebula-Host-Life-cycle" class="headerlink" title="OpenNebula Host Life-cycle"></a>OpenNebula Host Life-cycle</h3><table>
<thead>
<tr>
<th>state</th>
<th>State</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>INIT</td>
<td>Initial state for enabled hosts.</td>
</tr>
<tr>
<td>update</td>
<td>MONITORING_MONITORED</td>
<td>Monitoring a healthy Host.</td>
</tr>
<tr>
<td>on</td>
<td>MONITORED</td>
<td>The host has been successfully monitored.</td>
</tr>
<tr>
<td>err</td>
<td>ERROR</td>
<td>An error occurred while monitoring the host. See the Host information with <code>onehost show</code> for an error message.</td>
</tr>
<tr>
<td>off</td>
<td>DISABLED</td>
<td>The host is disabled, and won’t be monitored. The scheduler ignores Hosts in this state.</td>
</tr>
<tr>
<td>retry</td>
<td>MONITORING_ERROR</td>
<td>Monitoring a host in error state.</td>
</tr>
</tbody>
</table>
<p>当 host 节点状态为error时，执行 onehost show 命令获取错误信息或是在web上查看日志。<br>当节点文件丢失时，host状态就是变成error，host上面的vm状态则会为unknown。此时可用以下命令修复：</p>
<pre><code>onehost sync --force 
</code></pre><p>更多host管理信息请参考：<a href="http://docs.opennebula.org/4.14/administration/hosts_and_clusters/host_guide.html#sync" target="_blank" rel="external">host_guide</a></p>
</div></article></li></ul><div class="paginator"><a href="/page/2/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="https://github.com/Abnerzhao" title="github" class="iconfont icon-github"></a><a href="mailto:opsabnerzhao@gmail.com" title="email" class="iconfont icon-email"></a><a href="http://weibo.com/2863179107/profile?topnav=1&amp;wvr=6&amp;is_all=1" title="weibo" class="iconfont icon-weibo"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2015-2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Abnerzhao</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>