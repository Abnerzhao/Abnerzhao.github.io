<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Abnerzhao"><meta name="description" content="DevOps"><title>Abner</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/page/2/"><link rel="alternate" href="/atom.xml" title="Abner"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5832f612aff8681e2ee213a3b8d9548b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Abner</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/06/12/raid_states/" class="post-link">raid磁盘状态备忘</a></h2><span class="post-time">Jun 12, 2016</span><div class="post-content"><h3 id="Physical-Drive-States"><a href="#Physical-Drive-States" class="headerlink" title="Physical Drive States"></a>Physical Drive States</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/54211F71-8626-4FEE-A37D-91E5F1464B74.png" alt=""></p></div><a href="/2016/06/12/raid_states/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/06/07/cpuinfo/" class="post-link">cpuinfo</a></h2><span class="post-time">Jun 7, 2016</span><div class="post-content"><h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h3><blockquote>
<p> Information about the processor, such as its type, make, model, and performance.</p>
</blockquote>
<h3 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h3><h4 id="CPU型号"><a href="#CPU型号" class="headerlink" title="CPU型号"></a>CPU型号</h4><pre><code># cat /proc/cpuinfo | grep vendor | uniq
vendor_id   : GenuineIntel
#  cat /proc/cpuinfo | grep &apos;model name&apos; | uniq
model name  : Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz
</code></pre><h4 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h4><pre><code># lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
......
</code></pre></div><a href="/2016/06/07/cpuinfo/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/27/iostat/" class="post-link">iostat查看磁盘IO信息</a></h2><span class="post-time">May 27, 2016</span><div class="post-content"><h3 id="一、iostat简介"><a href="#一、iostat简介" class="headerlink" title="一、iostat简介"></a>一、iostat简介</h3><blockquote>
<p>iostat - Report Central Processing Unit (CPU) statistics and input/out-put statistics for devices and partitions.</p>
</blockquote>
<p>iostat 用于输出CPU和磁盘I/O相关的统计信息。</p></div><a href="/2016/05/27/iostat/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/26/sar/" class="post-link">sar系统状态信息统计</a></h2><span class="post-time">May 26, 2016</span><div class="post-content"><h3 id="一、sar-简介"><a href="#一、sar-简介" class="headerlink" title="一、sar 简介"></a>一、sar 简介</h3><blockquote>
<p>sar - Collect, report, or save system activity information.</p>
<p>Usage: sar [ options ] [ interval  count  ]    </p>
<p> sar 选项 [输出间隔时间] [输出次数(默认为1)]</p>
</blockquote>
<p>sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。</p>
<p>sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</p></div><a href="/2016/05/26/sar/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/23/screen/" class="post-link">Screen会话管理</a></h2><span class="post-time">May 23, 2016</span><div class="post-content"><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<p><a href="http://www.gnu.org/software/screen/">GNU’s Screen 官方站点</a></p>
<h3 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h3><h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。对于远程登录的用户即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。</p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p></div><a href="/2016/05/23/screen/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/20/ansible/" class="post-link">Ansible基础知识备忘</a></h2><span class="post-time">May 20, 2016</span><div class="post-content"><h3 id="一、体系结构"><a href="#一、体系结构" class="headerlink" title="一、体系结构"></a>一、体系结构</h3><p>ansible是一款基于python开发，揉合了众多自动化运维工具功能的轻量级自动化运维工具，目前实现了除系统安装以外的批量系统配置、批量任务执行及批量程序部署等功能。</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/25.png" alt=""></p>
<ul>
<li>Inventory：主机库，定义可控制的主机</li>
<li>Modules：基于模块化设计，通过模块来实现批量部署</li>
<li>playbook：剧本，使用YAML编写的声明性的配置文件</li>
<li>plugins: 插件，完成日志记录、邮件等功能</li>
</ul>
<h3 id="二、-特点"><a href="#二、-特点" class="headerlink" title="二、 特点"></a>二、 特点</h3><ul>
<li>高度模块化，借助模块完成各种任务</li>
<li>agentless，无需在被控制端安装agent</li>
<li>默认基于ssh协议向被控制端发送操作指令<ul>
<li>基于密钥认证</li>
<li>在inventory文件中指定账号和密码</li>
</ul>
</li>
<li>批量任务执行可写成剧本playbook</li>
<li>幂等性：不会重复执行相同操作</li>
</ul>
<h3 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h3><h4 id="3-1-ssh免密钥登录"><a href="#3-1-ssh免密钥登录" class="headerlink" title="3.1 ssh免密钥登录"></a>3.1 ssh免密钥登录</h4><pre><code># ssh-keygen -t rsa -P &apos;&apos;  
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.249.6.64
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.48.156.8
</code></pre><h4 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h4><p>ansible-doc</p>
<pre><code>Options:

-l, --list            List available modules  //列出所有模块
-s, --snippet         Show playbook snippet for specified module(s) //查看指定模块用法

更多信息请参考manual手册
</code></pre><p>ansible</p>
<p> ansible <host-pattern>  [-f forks][-m module_name] [-a args] [options]</host-pattern></p>
<pre><code>Options:

  -a MODULE_ARGS, --args=MODULE_ARGS
                    module arguments   // 传递模块参数
  -f FORKS, --forks=FORKS  // 指定并发数
                    specify number of parallel processes to use
                    (default=5)
  -i INVENTORY, --inventory-file=INVENTORY 
                    specify inventory host file
                    (default=/etc/ansible/hosts)    
  -m MODULE_NAME, --module-name=MODULE_NAME
                    module name to execute (default=command)   

 更多信息请参考manual手册        
</code></pre><p>ansible-playbook  </p>
<p>ansible-playbook <filename.yml> … [options]             </filename.yml></p>
<h3 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h3><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>命令模块: ansible默认模块，用于在远程执行命令，command模块并不支持shell变量和管道等，若想使用shell来执行，应使用shell模块。</p>
<pre><code># ansible-doc -l | grep ^command
command              Executes a command on a remote node                        

# ansible 10.249.6.64 -m command -a &quot;date&quot;
10.249.6.64 | success | rc=0 &gt;&gt;
Wed May 11 21:21:35 CST 2016                        
</code></pre><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping模块：测试指定主机是否能连接</p>
<pre><code># ansible-doc -l | grep  -w ^ping
ping                 Try to connect to host and return `pong&apos; on success.                  

# ansible 10.249.6.64 -m ping
10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
</code></pre><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>计划任务模块 ：管理计划任务</p>
<pre><code># ansible-doc -l | grep  ^cron
cron                 Manage cron.d and crontab entries.

# ansible-doc  -s cron
- name: Manage cron.d and crontab entries.
action: cron
  backup                 # If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup&apos; variable by this module.
  cron_file              # If specified, uses this file in cron.d instead of an individual user&apos;s crontab.
  day                    # Day of the month the job should run ( 1-31, *, */2, etc )
  hour                   # Hour when the job should run ( 0-23, *, */2, etc )
  job                    # The command to execute. Required if state=present.
  minute                 # Minute when the job should run ( 0-59, *, */2, etc )
  month                  # Month of the year the job should run ( 1-12, *, */2, etc )
  name                   # Description of a crontab entry.
  reboot                 # If the job should be run at reboot. This option is deprecated. Users should use special_time.
  special_time           # Special time specification nickname.
  state                  # Whether to ensure the job is present or absent.
  user                   # The specific user who&apos;s crontab should be modified.
  weekday                # Day of the week that the job should run ( 0-7 for Sunday - Saturday, *, etc )        

# ansible 10.249.6.64 -m cron -a &apos;name=&quot;sync time&quot; minute=&quot;*/10&quot; \ 
job=&quot;/usr/sbin/ntpdate 0.centos.pool.ntp.org &amp;&amp; hwclock -w&quot; &apos;

10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: true,
    &quot;jobs&quot;: [
    &quot;sync time&quot;
    ]
}                   
</code></pre><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>用户模块：管理用户账户</p>
<pre><code># ansible-doc -l | grep ^user
user                 Manage user accounts  

# ansible 10.249.6.64 -m user -a &apos;name=work shell=/bin/bash home=/home/www&apos;   //添加用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;comment&quot;: &quot;&quot;,
&quot;createhome&quot;: true,
&quot;group&quot;: 500,
&quot;home&quot;: &quot;/home/www&quot;,
&quot;name&quot;: &quot;work&quot;,
&quot;shell&quot;: &quot;/bin/bash&quot;,
&quot;state&quot;: &quot;present&quot;,
&quot;system&quot;: false,
&quot;uid&quot;: 500
}        

# ansible 10.249.6.64 -m user -a &apos;name=work state=absent&apos;  // 删除用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;force&quot;: false,
&quot;name&quot;: &quot;work&quot;,
&quot;remove&quot;: false,
&quot;state&quot;: &quot;absent&quot;
}             
</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy模块：文件复制</p>
<pre><code>#  ansible-doc -l | grep ^copy
copy                 Copies files to remote locations. 

# ansible-doc -s copy
- name: Copies files to remote locations.
action: copy
  backup                 # Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
  content                # When used instead of &apos;src&apos;, sets the contents of a file directly to the specified value.
  dest=                  # Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.
  directory_mode         # When doing a recursive copy set the mode for the directories. If this is not set we will default the system defaults.
  force                  # the default is `yes&apos;, which will replace the remote file when contents are different than the source.  If `no&apos;, the file will only be transferred if the destination does not exist.
  src                    # Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with &quot;/&quot;, only inside contents of that directory are copied to destination. Otherwise, if it does not end with &quot;/&quot;, the directory itself with all contents is copied. This behavior is similar to Rsync.
  validate               # The validation command to run before copying into place.  The path to the file to validate is passed in via &apos;%s&apos; which must be present as in the visudo example below. The command is passed securely so shell features like expansion and pipes won&apos;t work.

# ansible 10.249.6.64 -m copy -a &quot;src=/root/test.txt dest=/tmp/&quot;
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;dest&quot;: &quot;/tmp/test.txt&quot;,
&quot;gid&quot;: 0,
&quot;group&quot;: &quot;root&quot;,
&quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;,
&quot;mode&quot;: &quot;0644&quot;,
&quot;owner&quot;: &quot;root&quot;,
&quot;size&quot;: 0,
&quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1463662606.99-26627840524349/source&quot;,
&quot;state&quot;: &quot;file&quot;,
&quot;uid&quot;: 0
}   
# ansible 10.249.6.64 -m copy -a &quot;content=&apos;hello world&apos; dest=/tmp/test.txt&quot;
# ansible 10.249.6.64 -m copy -a &apos;src=/root/test.txt dest=/tmp/test.txt owner=evans group=evans mode=600 backup=yes&apos;
</code></pre><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file模块：文件模块，设置文件属性</p>
<pre><code># ansible-doc -l | grep -w ^file
file                 Sets attributes of files   
# ansible 10.249.6.64 -m file -a &quot;src=/tmp/test.txt path=/tmp/test.link state=link&quot;
# ansible 10.249.6.64 -m file -a &quot;owner=evans group=evans mode=600 path=/tmp/test.txt&quot;
</code></pre><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service模块： 服务模块，管理系统服务</p>
<pre><code># ansible-doc -l | grep ^service
service              Manage services.
# ansible-doc -s service
 - name: Manage services.
 action: service
  arguments              # Additional arguments provided on the command line
  enabled                # Whether the service should start on boot. *At least one of state and enabled are required.*
  name=                  # Name of the service.
  pattern                # If the service does not respond to the status command, name a substring to look for as would be found in the output of the `ps&apos; command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.
  runlevel               # For OpenRC init scripts (ex: Gentoo) only.  The runlevel that this service belongs to.
  sleep                  # If the service is being `restarted&apos; then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.
  state                  # `started&apos;/`stopped&apos; are idempotent actions that will not run commands unless necessary.  `restarted&apos; will always bounce the service.  `reloaded&apos; will always reload. *At least one of state and enabled are required.*
  # ansible 10.249.6.64 -m service -a &quot;name=mysqld state=restarted enabled=true&quot;  //重启mysql服务并设置开机自启动
</code></pre><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell模块：远程执行命令</p>
<pre><code># ansible 10.249.6.64 -m shell -a &apos;date&apos;
10.249.6.64 | success | rc=0 &gt;&gt;
Thu May 19 21:20:51 CST 2016    
</code></pre><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>script模块：脚本模块，远程主机运行脚本</p>
<pre><code># ansible-doc  -l | grep ^script
script               Runs a local script on a remote node after transferring it..
# ansible 10.249.6.64 -m script -a &apos;/root/test.sh&apos;  //在远程主机上运行脚本，并没有拷贝到指定目录
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;rc&quot;: 0,
&quot;stderr&quot;: &quot;&quot;,
&quot;stdout&quot;: &quot;&quot;
}   
</code></pre><h4 id="yum、apt"><a href="#yum、apt" class="headerlink" title="yum、apt"></a>yum、apt</h4><p>yum模块和apt模块：包管理模块</p>
<pre><code>yum                  Manages packages with the `yum&apos; package manager
apt                  Manages apt-packages
# ansible 10.249.6.64 -m yum -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=absent&quot;
</code></pre><blockquote>
<p> state<br> Whether to install (<code>present&#39;,</code>latest’), or remove (`absent’) a package.</p>
</blockquote>
<h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup模块：收集主机信息，playbook运行时，会自动调用setup模块收集远程主机的相关信息（称为facts，如操作系统版本、ip地址、cpu数量等），这些信息保存于变量中，可在playbook中引用</p>
<pre><code># ansible-doc -l | grep  setup
setup                Gathers facts about remote hosts
# ansible-doc -s setup
- name: Gathers facts about remote hosts
 action: setup
  fact_path              # path used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. File/results format can be json or ini-format
  filter                 # if supplied, only return facts that match this shell-style (fnmatch) wildcard.
# ansible 10.249.6.43 -m setup
# ansible 10.249.6.43 -m setup -a &apos;filter=ansible_eth0&apos;   //过滤信息
# ansible 10.249.6.64 -m setup --tree /tmp/test.txt  //将收集的信息输出到本地文件
</code></pre><p>更多模块信息请查看：<a href="http://docs.ansible.com/ansible/list_of_all_modules.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="五、playbook"><a href="#五、playbook" class="headerlink" title="五、playbook"></a>五、playbook</h3><h4 id="5-1-YAML"><a href="#5-1-YAML" class="headerlink" title="5.1 YAML"></a>5.1 YAML</h4><p>YAML是一种可读性高的用来表达资料序列的语言，其语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。</p>
<p>所有的yaml文件都以”—“开头表示开始一个document，所有的列表元素以”-“开头，键值对用”:”，后面必须有空格。YAML文件扩展名通常为.yaml或.yml</p>
<h4 id="5-2-playbook简介"><a href="#5-2-playbook简介" class="headerlink" title="5.2 playbook简介"></a>5.2 playbook简介</h4><p>playbook是ansible管理配置、部署应用和编排的文件，可用来描述在远程主机上执行的策略或一组任务。</p>
<p>一个playbook文件由一个或多个play组成，每个play定义了在一个或多个远程主机上执行的一系列的task，其中每个task一般就是调用一个ansible的模块。</p>
<p>playbook使用YAML语言编写，文件名以.yaml或.yml结尾。此外playbook和模板文件（template）还可使用jinja2语法语法实现高级功能。</p>
<p>5.2.1 playbook的基本组成</p>
<ul>
<li>targets：指定要执行playbook的远程主机组</li>
<li>variables：定义playbook运行时需要使用的变量</li>
<li>tasks：要执行的任务</li>
<li>handlers：处理器，在某些条件下被触发的操作</li>
</ul>
<p>简单playbook示例：</p>
<pre><code># cat nginx.yml
---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started

  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
# ansible-playbook  nginx.yml   // 执行playbook
</code></pre><ul>
<li>hosts、user</li>
</ul>
<p>hosts用于指定要执行指定任务的主机，其可以是一个或多个由逗号分隔主机组；user则用于指定远程主机上的执行任务的用户，还能使用sudo</p>
<ul>
<li>task list、action</li>
</ul>
<p>task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可。</p>
<p> task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致。</p>
<p> 每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出。</p>
<p>定义task的可以使用“action: module options”或“module: options”的格式，推荐使用后者以实现向后兼容例如：</p>
<pre><code>tasks:
- name: make sure apache is running
  service: name=httpd state=running
</code></pre><p> 在众多模块中，只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式，例如：</p>
<pre><code>tasks:
- name: disable selinux
  command: /sbin/setenforce 0
</code></pre><p>shell模块执行多条命令       </p>
<pre><code>---
- name: update zabbix agent conf
shell: |     
   sed  -i &quot;/Hostname/d&quot; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf
   wget -O /tmp/hostinfo.txt http://10.126.93.2/bak/hostinfo.txt
   IP=`ifconfig | egrep -A1 eth[0-9] | egrep  -o  addr:[0-9]+.[0-9]+.[0-9]+.[0-9]+ | awk -F: &apos;{print $2}&apos;`
   USE=`egrep -w  $IP /tmp/hostinfo.txt | awk &apos;{print $2}&apos;| uniq`
   HOST=`hostname | awk -F . &apos;{print $1}&apos;`
   echo &quot;Hostname=${USE}${HOST}&quot; &gt;&gt; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf   
</code></pre><p>如果模块执行返回值不为零，即表示执行失败，任务会立即中止，后续任务不再执行。可以使用ignore_errors来忽略错误信息确保后续任务的执行。</p>
<pre><code>tasks:
   - name: run this command and ignore the result
     shell: /usr/bin/somecommand
     ignore_errors: yes
</code></pre><ul>
<li>handlers</li>
</ul>
<p>当关注的资源发生变化时触发一定的操作。handler是task列表，这些task与前述的task并没有本质上的不同。</p>
<p>“notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，取而代之，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。       </p>
<pre><code>- name: template configuration file
  template: src=/root/template.conf dest=/etc/template.conf

notify:
  - restart memcached
  - restart apache

handlers:
- name: restart memcached
  service: name=memcached state=restarted
- name: restart apache
  service: name=apache state=restarted
</code></pre><ul>
<li>vars</li>
</ul>
<p>变量名仅能由字母、数字和下划线组成，且只能以字母开头  </p>
<ul>
<li>when </li>
</ul>
<p>条件判断：如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提，这时就要用到条件判断。</p>
<pre><code>when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;

when: ansible_distribution == &apos;CentOS&apos; or ansible_distribution == &apos;RedHat&apos; and ansible_distribution_version|int &gt;=6
</code></pre><p>忽略此前某语句的错误并基于其结果（failed或者sucess）运行后面指定的语句:</p>
<pre><code>---
- hosts: 10.249.6.64
  user: root
  tasks:
    - name: false test
      command: /bin/false
      register: result
      ignore_errors: yes
    - name: when false  to do
      command: touch /tmp/1.txt
      when: result | failed
    - name: when success to do
      command: touch /tmp/2.txt
      when: result | success
    - name: when skip to do
      command: touch /tmp/3.txt
      when: result | skipped
</code></pre><ul>
<li>item</li>
</ul>
<p>item 迭代：当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可</p>
<pre><code>- name: install base software
  apt: pkg={{ item }} state=present force=yes
  with_items:
    - gcc
    - g++
    - mysql-client-5.5
    - libmcrypt-dev
    - libmysqlclient-dev
    - libgmp10
    - vim
    - openssh-client
    - ethtool
when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;
</code></pre><ul>
<li>tag</li>
</ul>
<p>tag标签：让用户选择运行playbook中的某个或某些任务。虽然ansible具有幂等性，会跳过没有变化的部分，有些代码为测试其确实没有发生变化，也会耗费很长时间。我们将playbook中的指定任务打上标签，在运行playbook时指定标签名称，这样就不用运行全部代码了。</p>
<pre><code>---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started
  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
    # ansible-playbook nginx.yml -t conf   // 只执行tags部分
</code></pre><h3 id="六、roles"><a href="#六、roles" class="headerlink" title="六、roles"></a>六、roles</h3><p>roles 用于层次性、结构化地组织playbook。</p>
<p>roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p>
<pre><code># ls
deploy_hosts  deploy.yml  roles  run.sh
# cat deploy_hosts   //主机或主机组列表
[web]
10.126.83.30
10.126.93.83
[db]
10.126.87.150
10.126.92.89
# cat deploy.yml  // 总的playbook 调用roles
---
- name: init for os
  hosts: web
  user: root
  gather_facts: True
  roles:
    - init
    - raid
- name: init for os
  hosts: db
  user: root
  gather_facts: True
  roles:
    - init
    - raid
    - db_init

# cat run.sh  // 运行playbook脚本
#!/bin/bash
/usr/bin/ansible-playbook -i ./deploy_hosts deploy.yml
# ls roles/
db_init   init    raid 
</code></pre><p>在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录，用不到的目录可以创建为空目录，也可以不创建。</p>
<p>role内各目录中可用的文件:</p>
<ul>
<li><p>tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件</p>
</li>
<li><p>files目录：存放由copy或script等模块调用的静态文件</p>
</li>
<li><p>templates目录：template模块会自动在此目录中寻找Jinja2模板文件</p>
</li>
<li><p>handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；此文件可以使用include包含其它的位于此目录中的handler文件</p>
</li>
<li><p>vars目录：至少有一个main.yml文件，用于定义此角色用到的变量</p>
</li>
<li><p>meta目录：至少有一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持</p>
</li>
<li><p>default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件</p>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://9124573.blog.51cto.com/9114573/1769887" target="_blank" rel="external">轻量级自动化运维工具ansible</a></p>
<p><a href="http://docs.ansible.com/ansible/intro.html" target="_blank" rel="external">ansible doc</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/18/zabbix-agent/" class="post-link">Zabbix工作模式</a></h2><span class="post-time">May 18, 2016</span><div class="post-content"><blockquote>
<p>Zabbix uses a JSON based communication protocol for communicating with Zabbix agent.</p>
</blockquote>
<p>zabbix agent通信过程中的协议均基于json格式。主动模式和被动模式是相对于agent来说的。agent主动发送数据给server即为主动模式。</p>
<h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h3><p>server向agent请求获取监控项的数据，agent返回数据。</p>
<blockquote>
<p>A passive check is a simple data request. Zabbix server or proxy asks for some data (for example, CPU load) and Zabbix agent sends back the result to the server.</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Server 发起请求：</p>
<pre><code>&lt;item key&gt;\n
</code></pre><p>Agent 返回响应数据：</p>
<pre><code>&lt;HEADER&gt;&lt;DATALEN&gt;&lt;DATA&gt;
</code></pre><p>server发送request给agent，agent收到request后本地执行相关检测收集到数据之后，发送数据到server端， 以agent.ping key 值为例具体工作流程如下：</p>
<p>1.Server opens a TCP connection</p>
<p>2.Server sends agent.ping\n</p>
<p>3.Agent reads the request and responds with <header><datalen></datalen></header></p>
<p>4.Server processes data to get the value, ‘1’ in our case</p>
<p>5.TCP connection is closed</p>
<h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h3><blockquote>
<p>Active checks require more complex processing. The agent must first retrieve from the server(s) a list of items for independent processing.</p>
<p>The servers to get the active checks from are listed in the ‘ServerActive’ parameter of the agent configuration file. The frequency of asking for these checks is set by the ‘RefreshActiveChecks’ parameter in the same configuration file. However, if refreshing active checks fails, it is retried after hardcoded 60 seconds. The agent then periodically sends the new values to the server(s).</p>
</blockquote>
<p>主动模式的工作流程要比被动模式的复杂一些，zabbix客户端代理（Agent）首先必须从服务器获取监控项列表来进行独立处理，然后它将定期发送新数据给服务器。</p>
<p>Part1: Getting the list of items</p>
<ol>
<li><p>Agent opens a TCP connection</p>
</li>
<li><p>Agent asks for the list of checks</p>
</li>
<li><p>Server responds with a list of items (item key, delay)</p>
</li>
<li><p>Agent parses the response</p>
</li>
<li><p>TCP connection is closed</p>
</li>
<li><p>Agent starts periodical collection of data</p>
</li>
</ol>
<p>Part2: agent send values</p>
<ol>
<li>Agent opens a TCP connection</li>
<li>Agent sends a list of values</li>
<li>Server processes the data and sends the status back</li>
<li>TCP connection is closed</li>
</ol>
<p>当使用被动式的时候，server和agent之间需要对每个item的检测建立一次tcp连接。 如果检测的item和agent过多的时候，对server端的性能是一个很大的考验，所以当agent 和items 数量增多时可以根据实际情况设置工作模式。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zabbix.com/documentation/2.2/manual/appendix/items/activepassive#passive_checks" target="_blank" rel="external">zabbix doc </a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/05/nc/" class="post-link">nc小知识</a></h2><span class="post-time">May 5, 2016</span><div class="post-content"><h3 id="远程拷贝文件"><a href="#远程拷贝文件" class="headerlink" title="远程拷贝文件"></a>远程拷贝文件</h3><p>server1: 10.48.156.8</p>
<p>server2: 10.249.6.43</p>
<p><strong>从server1拷贝文件到server2</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -lp 1234 &gt; file.txt
</code></pre><blockquote>
<p>-l：使用监听模式，监控传入的资料</p>
<p>-p &lt;通信端口&gt;：设置本地主机使用的通信端口</p>
</blockquote>
<p>然后server1上运行：</p>
<pre><code># ll file.txt
-rw-r--r-- 1 root root 35 May  5 20:43 file.txt
# nc 10.249.6.43  1234 &lt; file.txt
</code></pre><h3 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h3><p><strong>从server1拷贝MySQL-python-1.2.3目录内容到server2上</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -l 1234 | tar xzvf -
</code></pre><p>然后server1上运行：</p>
<pre><code># ll -d MySQL-python-1.2.3
drwxrwxr-x 3 500 500 4096 Jan  3 18:13 MySQL-python-1.2.3
# tar czvf - MySQL-python-1.2.3 | nc 10.249.6.43 1234
</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><pre><code># nc localhost -z 22   //扫描本机端口
Connection to localhost 22 port [tcp/ssh] succeeded!
# nc 10.126.93.2 -z 80  //扫描远程机器端口
Connection to 10.126.93.2 80 port [tcp/http] succeeded!
# nc -v 10.126.93.2 -z 1-100  //指示扫描过程    
</code></pre><blockquote>
<p>-v：显示指令执行过程</p>
<p>-z：使用0输入/输出模式，只在扫描通信端口时使用</p>
<p>-w &lt;超时秒数&gt;：设置等待连线的时间</p>
</blockquote>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/08/Create-A-deb-Package-Repository/" class="post-link">Create A .deb Package Repository</a></h2><span class="post-time">Mar 8, 2016</span><div class="post-content"><h3 id="Install-Reprepro-and-Generate-Key"><a href="#Install-Reprepro-and-Generate-Key" class="headerlink" title="Install Reprepro and Generate Key"></a>Install Reprepro and Generate Key</h3><p>安装软件包并生成密钥</p>
<pre><code># sudo apt-get  install reprepro gnupg -y
</code></pre><p>创建gpg key需要大量的随机操作，使用rng-tools产生大量随机操作    </p>
<pre><code># apt-get install rng-tools -y

# vim /etc/default/rng-tools   

[...]

HRNGDEVICE=/dev/urandom

[...]

# /etc/init.d/rng-tools start
</code></pre><p>Generate a gpg key using gnupg  </p>
<pre><code># gpg --gen-key
......
Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
Your selection? 4
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
        0 = key does not expire
    &lt;n&gt;  = key expires in n days
    &lt;n&gt;w = key expires in n weeks
    &lt;n&gt;m = key expires in n months
    &lt;n&gt;y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
 &quot;Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;&quot;

Real name: Mr-zhao
Email address: zhifanzhao@gmail.com
Comment: ops deb
Enter passphrase:****
You selected this USER-ID:
    &quot;Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;&quot;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
You need a Passphrase to protect your secret key.

You don&apos;t want a passphrase - this is probably a *bad* idea!
I will do it anyway.  You can change your passphrase at any time,
using this program with the option &quot;--edit-key&quot;.

We need to generate a lot of random bytes.
 It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy.

......
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key D94F748F marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   4096R/D94F748F 2016-03-08
    Key fingerprint = 7D96 2419 19C6 B7C3 7F97  F4BB 63BF 6A4F D94F 748F
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

Note that this key cannot be used for encryption.  You may want to use
the command &quot;--edit-key&quot; to generate a subkey for this purpose. 
</code></pre><p>查看和修改 gpg key</p>
<pre><code># gpg --list-keys
/root/.gnupg/pubring.gpg
------------------------
pub   4096R/D94F748F 2016-03-08
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

# gpg --edit-key
usage: gpg [options] --edit-key user-id [commands]
</code></pre><h3 id="Create-a-Package-Repository-and-Export-Key"><a href="#Create-a-Package-Repository-and-Export-Key" class="headerlink" title="Create a Package Repository and Export Key"></a>Create a Package Repository and Export Key</h3><pre><code># cd /data
# mkdir apt
# mkdir -p ./apt/conf

#vim  ./apt/conf/distributions
Origin:        ops-ubuntu
Label:         ops-ubuntu
Suite:         trusty
Codename:      trusty
Version:       14.04
Architectures: amd64 i386
Components:    main restricted multiverse universe
Description:   private main deb repository for trusty
SignWith: yes

#vim ./apt/conf/options   //reprepro --options命令的集合
verbose
basedir  .
ask-passphrase
distdir  /data/apt/repos/dists   //dist文件的输出位置
outdir   /data/apt/repos    //pool输出的位置
</code></pre><p>Create the repository tree</p>
<pre><code># reprepro --ask-passphrase -Vb /data/apt/ export
</code></pre><p>Export Key</p>
<pre><code># gpg --armor --export Mr-zhao zhifanzhao@gmail.com &gt;&gt; ./repos/public.key
</code></pre><h3 id="Add-Packages-to-Newly-Created-Repository"><a href="#Add-Packages-to-Newly-Created-Repository" class="headerlink" title="Add Packages to Newly Created Repository"></a>Add Packages to Newly Created Repository</h3><pre><code>#reprepro -b . -C main includedeb trusty /tmp/packages.deb  //add

#reprepro remove trusty packages   //remove 
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.tecmint.com/create-deb-pacakge-repository-in-ubuntu/" target="_blank" rel="external">Create A .deb Package Repository</a><br><a href="https://wikitech.wikimedia.org/wiki/Reprepro" target="_blank" rel="external">wiki reprepro</a><br><a href="https://wiki.debian.org/SecureApt" target="_blank" rel="external">SecureApt)</a><br><a href="http://irtfweb.ifa.hawaii.edu/~lockhart/gpg/" target="_blank" rel="external">gpg-cheat</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="external">gpg</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/03/free/" class="post-link">free查看内存相关信息</a></h2><span class="post-time">Mar 3, 2016</span><div class="post-content"><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="manual-description"><a href="#manual-description" class="headerlink" title="manual description"></a>manual description</h4><blockquote>
<p>free  displays  the total amount of free and used physical and swap memory in the system, as well as the buffers used bythe kernel.</p>
<p>The shared memory column represents either the MemShared value (2.4 series kernels) or the Shmem value (2.6 series kernels and later) taken from the /proc/meminfo file. The value is zero if none of the entries is exported by the kernel.</p>
</blockquote>
<h4 id="buffers-and-cached"><a href="#buffers-and-cached" class="headerlink" title="buffers and cached"></a>buffers and cached</h4><blockquote>
<p><strong>What is the difference between buffers and Cache?</strong></p>
<p>A buffer is a temporary location to store data for a particular application and this data is not used by any other application. This is similar to bandwidth concept. When you try to send burst of data through network, if your network card is capable of sending less data, it will keep these huge amounts of data in buffer so that it can send data constantly in lesser speeds. In other hand Cache is a memory location to store frequently used data for faster access. Other difference between a buffer and a cache is that cache can be used multiple times where as buffer is used single time. And both are temporary store for your data processing.</p>
</blockquote>
<ul>
<li>A buffer is something that has yet to be “written” to disk.</li>
<li>A cache is something that has been “read” from the disk and stored for later use.</li>
</ul>
<p>buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。   这二者是为了提高IO性能的。为了提高IO read的性能，总是要多cache一些数据，这也就是为什么cached memor比较大，而比较小的原因。</p>
<pre><code>root@Mr-zhao:~# free -m
             total       used       free     shared    buffers     cached
Mem:          2001        979       1021          0         58        774
-/+ buffers/cache:        146       1854
Swap:         4092          0       4092
</code></pre><p>当我们第一次读一个大文件时耗时可能会比第二次长，原因就是第二次读取时已有cache数据。</p>
<ul>
<li><p>-/+ buffers/cache(used): 表示一个应用程序认为系统被用掉多少内存；</p>
<p>  -/+ buffers/cache(used) = Mem(used) – Mem(buffers) – Mem(cached)</p>
</li>
<li><p>-/+ buffers/cache(free)，表示一个应用程序认为系统还有多少内存；</p>
<p>  -/+ buffers/cache(free) = Mem(free) + Mem(buffers) + Mem(cached)</p>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="external">Linux上的free命令详解</a><br><a href="http://www.freelinuxconsole.info/understanding-free-command-in-linuxunix-2/" target="_blank" rel="external">Understanding free command in Linux/Unix</a></p>
</div></article></li></ul><div class="paginator"><a href="/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/page/3/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="https://github.com/Abnerzhao" title="github" class="iconfont icon-github"></a><a href="mailto:opsabnerzhao@gmail.com" title="email" class="iconfont icon-email"></a><a href="http://weibo.com/2863179107/profile?topnav=1&amp;wvr=6&amp;is_all=1" title="weibo" class="iconfont icon-weibo"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2015-2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Abnerzhao</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>