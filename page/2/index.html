<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Abnerzhao"><meta name="description" content="DevOps"><title>Abner</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/page/2/"><link rel="alternate" href="/atom.xml" title="Abner"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5832f612aff8681e2ee213a3b8d9548b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Abner</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/27/iostat/" class="post-link">iostat查看磁盘IO信息</a></h2><span class="post-time">May 27, 2016</span><div class="post-content"><h3 id="一、iostat简介"><a href="#一、iostat简介" class="headerlink" title="一、iostat简介"></a>一、iostat简介</h3><blockquote>
<p>iostat - Report Central Processing Unit (CPU) statistics and input/out-put statistics for devices and partitions.</p>
</blockquote>
<p>iostat 用于输出CPU和磁盘I/O相关的统计信息。</p></div><a href="/2016/05/27/iostat/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/23/screen/" class="post-link">Screen会话管理</a></h2><span class="post-time">May 23, 2016</span><div class="post-content"><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<p><a href="http://www.gnu.org/software/screen/">GNU’s Screen 官方站点</a></p>
<h3 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h3><h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。对于远程登录的用户即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。</p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p></div><a href="/2016/05/23/screen/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/20/ansible/" class="post-link">Ansible基础知识备忘</a></h2><span class="post-time">May 20, 2016</span><div class="post-content"><h3 id="一、体系结构"><a href="#一、体系结构" class="headerlink" title="一、体系结构"></a>一、体系结构</h3><p>ansible是一款基于python开发，揉合了众多自动化运维工具功能的轻量级自动化运维工具，目前实现了除系统安装以外的批量系统配置、批量任务执行及批量程序部署等功能。</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/25.png" alt=""></p>
<ul>
<li>Inventory：主机库，定义可控制的主机</li>
<li>Modules：基于模块化设计，通过模块来实现批量部署</li>
<li>playbook：剧本，使用YAML编写的声明性的配置文件</li>
<li>plugins: 插件，完成日志记录、邮件等功能</li>
</ul>
<h3 id="二、-特点"><a href="#二、-特点" class="headerlink" title="二、 特点"></a>二、 特点</h3><ul>
<li>高度模块化，借助模块完成各种任务</li>
<li>agentless，无需在被控制端安装agent</li>
<li>默认基于ssh协议向被控制端发送操作指令<ul>
<li>基于密钥认证</li>
<li>在inventory文件中指定账号和密码</li>
</ul>
</li>
<li>批量任务执行可写成剧本playbook</li>
<li>幂等性：不会重复执行相同操作</li>
</ul>
<h3 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h3><h4 id="3-1-ssh免密钥登录"><a href="#3-1-ssh免密钥登录" class="headerlink" title="3.1 ssh免密钥登录"></a>3.1 ssh免密钥登录</h4><pre><code># ssh-keygen -t rsa -P &apos;&apos;  
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.249.6.64
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.48.156.8
</code></pre><h4 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h4><p>ansible-doc</p>
<pre><code>Options:

-l, --list            List available modules  //列出所有模块
-s, --snippet         Show playbook snippet for specified module(s) //查看指定模块用法

更多信息请参考manual手册
</code></pre><p>ansible</p>
<p> ansible <host-pattern>  [-f forks][-m module_name] [-a args] [options]</host-pattern></p>
<pre><code>Options:

  -a MODULE_ARGS, --args=MODULE_ARGS
                    module arguments   // 传递模块参数
  -f FORKS, --forks=FORKS  // 指定并发数
                    specify number of parallel processes to use
                    (default=5)
  -i INVENTORY, --inventory-file=INVENTORY 
                    specify inventory host file
                    (default=/etc/ansible/hosts)    
  -m MODULE_NAME, --module-name=MODULE_NAME
                    module name to execute (default=command)   

 更多信息请参考manual手册        
</code></pre><p>ansible-playbook  </p>
<p>ansible-playbook <filename.yml> … [options]             </filename.yml></p>
<h3 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h3><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>命令模块: ansible默认模块，用于在远程执行命令，command模块并不支持shell变量和管道等，若想使用shell来执行，应使用shell模块。</p>
<pre><code># ansible-doc -l | grep ^command
command              Executes a command on a remote node                        

# ansible 10.249.6.64 -m command -a &quot;date&quot;
10.249.6.64 | success | rc=0 &gt;&gt;
Wed May 11 21:21:35 CST 2016                        
</code></pre><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping模块：测试指定主机是否能连接</p>
<pre><code># ansible-doc -l | grep  -w ^ping
ping                 Try to connect to host and return `pong&apos; on success.                  

# ansible 10.249.6.64 -m ping
10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
</code></pre><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>计划任务模块 ：管理计划任务</p>
<pre><code># ansible-doc -l | grep  ^cron
cron                 Manage cron.d and crontab entries.

# ansible-doc  -s cron
- name: Manage cron.d and crontab entries.
action: cron
  backup                 # If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup&apos; variable by this module.
  cron_file              # If specified, uses this file in cron.d instead of an individual user&apos;s crontab.
  day                    # Day of the month the job should run ( 1-31, *, */2, etc )
  hour                   # Hour when the job should run ( 0-23, *, */2, etc )
  job                    # The command to execute. Required if state=present.
  minute                 # Minute when the job should run ( 0-59, *, */2, etc )
  month                  # Month of the year the job should run ( 1-12, *, */2, etc )
  name                   # Description of a crontab entry.
  reboot                 # If the job should be run at reboot. This option is deprecated. Users should use special_time.
  special_time           # Special time specification nickname.
  state                  # Whether to ensure the job is present or absent.
  user                   # The specific user who&apos;s crontab should be modified.
  weekday                # Day of the week that the job should run ( 0-7 for Sunday - Saturday, *, etc )        

# ansible 10.249.6.64 -m cron -a &apos;name=&quot;sync time&quot; minute=&quot;*/10&quot; \ 
job=&quot;/usr/sbin/ntpdate 0.centos.pool.ntp.org &amp;&amp; hwclock -w&quot; &apos;

10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: true,
    &quot;jobs&quot;: [
    &quot;sync time&quot;
    ]
}                   
</code></pre><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>用户模块：管理用户账户</p>
<pre><code># ansible-doc -l | grep ^user
user                 Manage user accounts  

# ansible 10.249.6.64 -m user -a &apos;name=work shell=/bin/bash home=/home/www&apos;   //添加用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;comment&quot;: &quot;&quot;,
&quot;createhome&quot;: true,
&quot;group&quot;: 500,
&quot;home&quot;: &quot;/home/www&quot;,
&quot;name&quot;: &quot;work&quot;,
&quot;shell&quot;: &quot;/bin/bash&quot;,
&quot;state&quot;: &quot;present&quot;,
&quot;system&quot;: false,
&quot;uid&quot;: 500
}        

# ansible 10.249.6.64 -m user -a &apos;name=work state=absent&apos;  // 删除用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;force&quot;: false,
&quot;name&quot;: &quot;work&quot;,
&quot;remove&quot;: false,
&quot;state&quot;: &quot;absent&quot;
}             
</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy模块：文件复制</p>
<pre><code>#  ansible-doc -l | grep ^copy
copy                 Copies files to remote locations. 

# ansible-doc -s copy
- name: Copies files to remote locations.
action: copy
  backup                 # Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
  content                # When used instead of &apos;src&apos;, sets the contents of a file directly to the specified value.
  dest=                  # Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.
  directory_mode         # When doing a recursive copy set the mode for the directories. If this is not set we will default the system defaults.
  force                  # the default is `yes&apos;, which will replace the remote file when contents are different than the source.  If `no&apos;, the file will only be transferred if the destination does not exist.
  src                    # Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with &quot;/&quot;, only inside contents of that directory are copied to destination. Otherwise, if it does not end with &quot;/&quot;, the directory itself with all contents is copied. This behavior is similar to Rsync.
  validate               # The validation command to run before copying into place.  The path to the file to validate is passed in via &apos;%s&apos; which must be present as in the visudo example below. The command is passed securely so shell features like expansion and pipes won&apos;t work.

# ansible 10.249.6.64 -m copy -a &quot;src=/root/test.txt dest=/tmp/&quot;
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;dest&quot;: &quot;/tmp/test.txt&quot;,
&quot;gid&quot;: 0,
&quot;group&quot;: &quot;root&quot;,
&quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;,
&quot;mode&quot;: &quot;0644&quot;,
&quot;owner&quot;: &quot;root&quot;,
&quot;size&quot;: 0,
&quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1463662606.99-26627840524349/source&quot;,
&quot;state&quot;: &quot;file&quot;,
&quot;uid&quot;: 0
}   
# ansible 10.249.6.64 -m copy -a &quot;content=&apos;hello world&apos; dest=/tmp/test.txt&quot;
# ansible 10.249.6.64 -m copy -a &apos;src=/root/test.txt dest=/tmp/test.txt owner=evans group=evans mode=600 backup=yes&apos;
</code></pre><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file模块：文件模块，设置文件属性</p>
<pre><code># ansible-doc -l | grep -w ^file
file                 Sets attributes of files   
# ansible 10.249.6.64 -m file -a &quot;src=/tmp/test.txt path=/tmp/test.link state=link&quot;
# ansible 10.249.6.64 -m file -a &quot;owner=evans group=evans mode=600 path=/tmp/test.txt&quot;
</code></pre><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service模块： 服务模块，管理系统服务</p>
<pre><code># ansible-doc -l | grep ^service
service              Manage services.
# ansible-doc -s service
 - name: Manage services.
 action: service
  arguments              # Additional arguments provided on the command line
  enabled                # Whether the service should start on boot. *At least one of state and enabled are required.*
  name=                  # Name of the service.
  pattern                # If the service does not respond to the status command, name a substring to look for as would be found in the output of the `ps&apos; command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.
  runlevel               # For OpenRC init scripts (ex: Gentoo) only.  The runlevel that this service belongs to.
  sleep                  # If the service is being `restarted&apos; then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.
  state                  # `started&apos;/`stopped&apos; are idempotent actions that will not run commands unless necessary.  `restarted&apos; will always bounce the service.  `reloaded&apos; will always reload. *At least one of state and enabled are required.*
  # ansible 10.249.6.64 -m service -a &quot;name=mysqld state=restarted enabled=true&quot;  //重启mysql服务并设置开机自启动
</code></pre><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell模块：远程执行命令</p>
<pre><code># ansible 10.249.6.64 -m shell -a &apos;date&apos;
10.249.6.64 | success | rc=0 &gt;&gt;
Thu May 19 21:20:51 CST 2016    
</code></pre><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>script模块：脚本模块，远程主机运行脚本</p>
<pre><code># ansible-doc  -l | grep ^script
script               Runs a local script on a remote node after transferring it..
# ansible 10.249.6.64 -m script -a &apos;/root/test.sh&apos;  //在远程主机上运行脚本，并没有拷贝到指定目录
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;rc&quot;: 0,
&quot;stderr&quot;: &quot;&quot;,
&quot;stdout&quot;: &quot;&quot;
}   
</code></pre><h4 id="yum、apt"><a href="#yum、apt" class="headerlink" title="yum、apt"></a>yum、apt</h4><p>yum模块和apt模块：包管理模块</p>
<pre><code>yum                  Manages packages with the `yum&apos; package manager
apt                  Manages apt-packages
# ansible 10.249.6.64 -m yum -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=absent&quot;
</code></pre><blockquote>
<p> state<br> Whether to install (<code>present&#39;,</code>latest’), or remove (`absent’) a package.</p>
</blockquote>
<h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup模块：收集主机信息，playbook运行时，会自动调用setup模块收集远程主机的相关信息（称为facts，如操作系统版本、ip地址、cpu数量等），这些信息保存于变量中，可在playbook中引用</p>
<pre><code># ansible-doc -l | grep  setup
setup                Gathers facts about remote hosts
# ansible-doc -s setup
- name: Gathers facts about remote hosts
 action: setup
  fact_path              # path used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. File/results format can be json or ini-format
  filter                 # if supplied, only return facts that match this shell-style (fnmatch) wildcard.
# ansible 10.249.6.43 -m setup
# ansible 10.249.6.43 -m setup -a &apos;filter=ansible_eth0&apos;   //过滤信息
# ansible 10.249.6.64 -m setup --tree /tmp/test.txt  //将收集的信息输出到本地文件
</code></pre><p>更多模块信息请查看：<a href="http://docs.ansible.com/ansible/list_of_all_modules.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="五、playbook"><a href="#五、playbook" class="headerlink" title="五、playbook"></a>五、playbook</h3><h4 id="5-1-YAML"><a href="#5-1-YAML" class="headerlink" title="5.1 YAML"></a>5.1 YAML</h4><p>YAML是一种可读性高的用来表达资料序列的语言，其语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。</p>
<p>所有的yaml文件都以”—“开头表示开始一个document，所有的列表元素以”-“开头，键值对用”:”，后面必须有空格。YAML文件扩展名通常为.yaml或.yml</p>
<h4 id="5-2-playbook简介"><a href="#5-2-playbook简介" class="headerlink" title="5.2 playbook简介"></a>5.2 playbook简介</h4><p>playbook是ansible管理配置、部署应用和编排的文件，可用来描述在远程主机上执行的策略或一组任务。</p>
<p>一个playbook文件由一个或多个play组成，每个play定义了在一个或多个远程主机上执行的一系列的task，其中每个task一般就是调用一个ansible的模块。</p>
<p>playbook使用YAML语言编写，文件名以.yaml或.yml结尾。此外playbook和模板文件（template）还可使用jinja2语法语法实现高级功能。</p>
<p>5.2.1 playbook的基本组成</p>
<ul>
<li>targets：指定要执行playbook的远程主机组</li>
<li>variables：定义playbook运行时需要使用的变量</li>
<li>tasks：要执行的任务</li>
<li>handlers：处理器，在某些条件下被触发的操作</li>
</ul>
<p>简单playbook示例：</p>
<pre><code># cat nginx.yml
---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started

  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
# ansible-playbook  nginx.yml   // 执行playbook
</code></pre><ul>
<li>hosts、user</li>
</ul>
<p>hosts用于指定要执行指定任务的主机，其可以是一个或多个由逗号分隔主机组；user则用于指定远程主机上的执行任务的用户，还能使用sudo</p>
<ul>
<li>task list、action</li>
</ul>
<p>task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可。</p>
<p> task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致。</p>
<p> 每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出。</p>
<p>定义task的可以使用“action: module options”或“module: options”的格式，推荐使用后者以实现向后兼容例如：</p>
<pre><code>tasks:
- name: make sure apache is running
  service: name=httpd state=running
</code></pre><p> 在众多模块中，只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式，例如：</p>
<pre><code>tasks:
- name: disable selinux
  command: /sbin/setenforce 0
</code></pre><p>shell模块执行多条命令       </p>
<pre><code>---
- name: update zabbix agent conf
shell: |     
   sed  -i &quot;/Hostname/d&quot; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf
   wget -O /tmp/hostinfo.txt http://10.126.93.2/bak/hostinfo.txt
   IP=`ifconfig | egrep -A1 eth[0-9] | egrep  -o  addr:[0-9]+.[0-9]+.[0-9]+.[0-9]+ | awk -F: &apos;{print $2}&apos;`
   USE=`egrep -w  $IP /tmp/hostinfo.txt | awk &apos;{print $2}&apos;| uniq`
   HOST=`hostname | awk -F . &apos;{print $1}&apos;`
   echo &quot;Hostname=${USE}${HOST}&quot; &gt;&gt; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf   
</code></pre><p>如果模块执行返回值不为零，即表示执行失败，任务会立即中止，后续任务不再执行。可以使用ignore_errors来忽略错误信息确保后续任务的执行。</p>
<pre><code>tasks:
   - name: run this command and ignore the result
     shell: /usr/bin/somecommand
     ignore_errors: yes
</code></pre><ul>
<li>handlers</li>
</ul>
<p>当关注的资源发生变化时触发一定的操作。handler是task列表，这些task与前述的task并没有本质上的不同。</p>
<p>“notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，取而代之，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。       </p>
<pre><code>- name: template configuration file
  template: src=/root/template.conf dest=/etc/template.conf

notify:
  - restart memcached
  - restart apache

handlers:
- name: restart memcached
  service: name=memcached state=restarted
- name: restart apache
  service: name=apache state=restarted
</code></pre><ul>
<li>vars</li>
</ul>
<p>变量名仅能由字母、数字和下划线组成，且只能以字母开头  </p>
<ul>
<li>when </li>
</ul>
<p>条件判断：如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提，这时就要用到条件判断。</p>
<pre><code>when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;

when: ansible_distribution == &apos;CentOS&apos; or ansible_distribution == &apos;RedHat&apos; and ansible_distribution_version|int &gt;=6
</code></pre><p>忽略此前某语句的错误并基于其结果（failed或者sucess）运行后面指定的语句:</p>
<pre><code>---
- hosts: 10.249.6.64
  user: root
  tasks:
    - name: false test
      command: /bin/false
      register: result
      ignore_errors: yes
    - name: when false  to do
      command: touch /tmp/1.txt
      when: result | failed
    - name: when success to do
      command: touch /tmp/2.txt
      when: result | success
    - name: when skip to do
      command: touch /tmp/3.txt
      when: result | skipped
</code></pre><ul>
<li>item</li>
</ul>
<p>item 迭代：当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可</p>
<pre><code>- name: install base software
  apt: pkg={{ item }} state=present force=yes
  with_items:
    - gcc
    - g++
    - mysql-client-5.5
    - libmcrypt-dev
    - libmysqlclient-dev
    - libgmp10
    - vim
    - openssh-client
    - ethtool
when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;
</code></pre><ul>
<li>tag</li>
</ul>
<p>tag标签：让用户选择运行playbook中的某个或某些任务。虽然ansible具有幂等性，会跳过没有变化的部分，有些代码为测试其确实没有发生变化，也会耗费很长时间。我们将playbook中的指定任务打上标签，在运行playbook时指定标签名称，这样就不用运行全部代码了。</p>
<pre><code>---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started
  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
    # ansible-playbook nginx.yml -t conf   // 只执行tags部分
</code></pre><h3 id="六、roles"><a href="#六、roles" class="headerlink" title="六、roles"></a>六、roles</h3><p>roles 用于层次性、结构化地组织playbook。</p>
<p>roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p>
<pre><code># ls
deploy_hosts  deploy.yml  roles  run.sh
# cat deploy_hosts   //主机或主机组列表
[web]
10.126.83.30
10.126.93.83
[db]
10.126.87.150
10.126.92.89
# cat deploy.yml  // 总的playbook 调用roles
---
- name: init for os
  hosts: web
  user: root
  gather_facts: True
  roles:
    - init
    - raid
- name: init for os
  hosts: db
  user: root
  gather_facts: True
  roles:
    - init
    - raid
    - db_init

# cat run.sh  // 运行playbook脚本
#!/bin/bash
/usr/bin/ansible-playbook -i ./deploy_hosts deploy.yml
# ls roles/
db_init   init    raid 
</code></pre><p>在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录，用不到的目录可以创建为空目录，也可以不创建。</p>
<p>role内各目录中可用的文件:</p>
<ul>
<li><p>tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件</p>
</li>
<li><p>files目录：存放由copy或script等模块调用的静态文件</p>
</li>
<li><p>templates目录：template模块会自动在此目录中寻找Jinja2模板文件</p>
</li>
<li><p>handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；此文件可以使用include包含其它的位于此目录中的handler文件</p>
</li>
<li><p>vars目录：至少有一个main.yml文件，用于定义此角色用到的变量</p>
</li>
<li><p>meta目录：至少有一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持</p>
</li>
<li><p>default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件</p>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://9124573.blog.51cto.com/9114573/1769887" target="_blank" rel="external">轻量级自动化运维工具ansible</a></p>
<p><a href="http://docs.ansible.com/ansible/intro.html" target="_blank" rel="external">ansible doc</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/05/nc/" class="post-link">nc小知识</a></h2><span class="post-time">May 5, 2016</span><div class="post-content"><h3 id="远程拷贝文件"><a href="#远程拷贝文件" class="headerlink" title="远程拷贝文件"></a>远程拷贝文件</h3><p>server1: 10.48.156.8</p>
<p>server2: 10.249.6.43</p>
<p><strong>从server1拷贝文件到server2</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -lp 1234 &gt; file.txt
</code></pre><blockquote>
<p>-l：使用监听模式，监控传入的资料</p>
<p>-p &lt;通信端口&gt;：设置本地主机使用的通信端口</p>
</blockquote>
<p>然后server1上运行：</p>
<pre><code># ll file.txt
-rw-r--r-- 1 root root 35 May  5 20:43 file.txt
# nc 10.249.6.43  1234 &lt; file.txt
</code></pre><h3 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h3><p><strong>从server1拷贝MySQL-python-1.2.3目录内容到server2上</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -l 1234 | tar xzvf -
</code></pre><p>然后server1上运行：</p>
<pre><code># ll -d MySQL-python-1.2.3
drwxrwxr-x 3 500 500 4096 Jan  3 18:13 MySQL-python-1.2.3
# tar czvf - MySQL-python-1.2.3 | nc 10.249.6.43 1234
</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><pre><code># nc localhost -z 22   //扫描本机端口
Connection to localhost 22 port [tcp/ssh] succeeded!
# nc 10.126.93.2 -z 80  //扫描远程机器端口
Connection to 10.126.93.2 80 port [tcp/http] succeeded!
# nc -v 10.126.93.2 -z 1-100  //指示扫描过程    
</code></pre><blockquote>
<p>-v：显示指令执行过程</p>
<p>-z：使用0输入/输出模式，只在扫描通信端口时使用</p>
<p>-w &lt;超时秒数&gt;：设置等待连线的时间</p>
</blockquote>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/08/Create-A-deb-Package-Repository/" class="post-link">Create A .deb Package Repository</a></h2><span class="post-time">Mar 8, 2016</span><div class="post-content"><h3 id="Install-Reprepro-and-Generate-Key"><a href="#Install-Reprepro-and-Generate-Key" class="headerlink" title="Install Reprepro and Generate Key"></a>Install Reprepro and Generate Key</h3><p>安装软件包并生成密钥</p>
<pre><code># sudo apt-get  install reprepro gnupg -y
</code></pre><p>创建gpg key需要大量的随机操作，使用rng-tools产生大量随机操作    </p>
<pre><code># apt-get install rng-tools -y

# vim /etc/default/rng-tools   

[...]

HRNGDEVICE=/dev/urandom

[...]

# /etc/init.d/rng-tools start
</code></pre><p>Generate a gpg key using gnupg  </p>
<pre><code># gpg --gen-key
......
Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
Your selection? 4
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
        0 = key does not expire
    &lt;n&gt;  = key expires in n days
    &lt;n&gt;w = key expires in n weeks
    &lt;n&gt;m = key expires in n months
    &lt;n&gt;y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
 &quot;Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;&quot;

Real name: Mr-zhao
Email address: zhifanzhao@gmail.com
Comment: ops deb
Enter passphrase:****
You selected this USER-ID:
    &quot;Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;&quot;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
You need a Passphrase to protect your secret key.

You don&apos;t want a passphrase - this is probably a *bad* idea!
I will do it anyway.  You can change your passphrase at any time,
using this program with the option &quot;--edit-key&quot;.

We need to generate a lot of random bytes.
 It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy.

......
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key D94F748F marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   4096R/D94F748F 2016-03-08
    Key fingerprint = 7D96 2419 19C6 B7C3 7F97  F4BB 63BF 6A4F D94F 748F
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

Note that this key cannot be used for encryption.  You may want to use
the command &quot;--edit-key&quot; to generate a subkey for this purpose. 
</code></pre><p>查看和修改 gpg key</p>
<pre><code># gpg --list-keys
/root/.gnupg/pubring.gpg
------------------------
pub   4096R/D94F748F 2016-03-08
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

# gpg --edit-key
usage: gpg [options] --edit-key user-id [commands]
</code></pre><h3 id="Create-a-Package-Repository-and-Export-Key"><a href="#Create-a-Package-Repository-and-Export-Key" class="headerlink" title="Create a Package Repository and Export Key"></a>Create a Package Repository and Export Key</h3><pre><code># cd /data
# mkdir apt
# mkdir -p ./apt/conf

#vim  ./apt/conf/distributions
Origin:        ops-ubuntu
Label:         ops-ubuntu
Suite:         trusty
Codename:      trusty
Version:       14.04
Architectures: amd64 i386
Components:    main restricted multiverse universe
Description:   private main deb repository for trusty
SignWith: yes

#vim ./apt/conf/options   //reprepro --options命令的集合
verbose
basedir  .
ask-passphrase
distdir  /data/apt/repos/dists   //dist文件的输出位置
outdir   /data/apt/repos    //pool输出的位置
</code></pre><p>Create the repository tree</p>
<pre><code># reprepro --ask-passphrase -Vb /data/apt/ export
</code></pre><p>Export Key</p>
<pre><code># gpg --armor --export Mr-zhao zhifanzhao@gmail.com &gt;&gt; ./repos/public.key
</code></pre><h3 id="Add-Packages-to-Newly-Created-Repository"><a href="#Add-Packages-to-Newly-Created-Repository" class="headerlink" title="Add Packages to Newly Created Repository"></a>Add Packages to Newly Created Repository</h3><pre><code>#reprepro -b . -C main includedeb trusty /tmp/packages.deb  //add

#reprepro remove trusty packages   //remove 
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.tecmint.com/create-deb-pacakge-repository-in-ubuntu/" target="_blank" rel="external">Create A .deb Package Repository</a><br><a href="https://wikitech.wikimedia.org/wiki/Reprepro" target="_blank" rel="external">wiki reprepro</a><br><a href="https://wiki.debian.org/SecureApt" target="_blank" rel="external">SecureApt)</a><br><a href="http://irtfweb.ifa.hawaii.edu/~lockhart/gpg/" target="_blank" rel="external">gpg-cheat</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="external">gpg</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/03/free/" class="post-link">free查看内存相关信息</a></h2><span class="post-time">Mar 3, 2016</span><div class="post-content"><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="manual-description"><a href="#manual-description" class="headerlink" title="manual description"></a>manual description</h4><blockquote>
<p>free  displays  the total amount of free and used physical and swap memory in the system, as well as the buffers used bythe kernel.</p>
<p>The shared memory column represents either the MemShared value (2.4 series kernels) or the Shmem value (2.6 series kernels and later) taken from the /proc/meminfo file. The value is zero if none of the entries is exported by the kernel.</p>
</blockquote>
<h4 id="buffers-and-cached"><a href="#buffers-and-cached" class="headerlink" title="buffers and cached"></a>buffers and cached</h4><blockquote>
<p><strong>What is the difference between buffers and Cache?</strong></p>
<p>A buffer is a temporary location to store data for a particular application and this data is not used by any other application. This is similar to bandwidth concept. When you try to send burst of data through network, if your network card is capable of sending less data, it will keep these huge amounts of data in buffer so that it can send data constantly in lesser speeds. In other hand Cache is a memory location to store frequently used data for faster access. Other difference between a buffer and a cache is that cache can be used multiple times where as buffer is used single time. And both are temporary store for your data processing.</p>
</blockquote>
<ul>
<li>A buffer is something that has yet to be “written” to disk.</li>
<li>A cache is something that has been “read” from the disk and stored for later use.</li>
</ul>
<p>buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。   这二者是为了提高IO性能的。为了提高IO read的性能，总是要多cache一些数据，这也就是为什么cached memor比较大，而比较小的原因。</p>
<pre><code>root@Mr-zhao:~# free -m
             total       used       free     shared    buffers     cached
Mem:          2001        979       1021          0         58        774
-/+ buffers/cache:        146       1854
Swap:         4092          0       4092
</code></pre><p>当我们第一次读一个大文件时耗时可能会比第二次长，原因就是第二次读取时已有cache数据。</p>
<ul>
<li><p>-/+ buffers/cache(used): 表示一个应用程序认为系统被用掉多少内存；</p>
<p>  -/+ buffers/cache(used) = Mem(used) – Mem(buffers) – Mem(cached)</p>
</li>
<li><p>-/+ buffers/cache(free)，表示一个应用程序认为系统还有多少内存；</p>
<p>  -/+ buffers/cache(free) = Mem(free) + Mem(buffers) + Mem(cached)</p>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="external">Linux上的free命令详解</a><br><a href="http://www.freelinuxconsole.info/understanding-free-command-in-linuxunix-2/" target="_blank" rel="external">Understanding free command in Linux/Unix</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/02/28/minicom/" class="post-link">minicom的使用</a></h2><span class="post-time">Feb 28, 2016</span><div class="post-content"><h3 id="minicom的介绍"><a href="#minicom的介绍" class="headerlink" title="minicom的介绍"></a>minicom的介绍</h3><p>Linux下的Minicom的功能与Windows下的超级终端功能相似，<strong>可以通过串口控制外部的硬件设备</strong>，适于在linux通过超级终端对嵌入式设备行管理。</p>
<h3 id="minicom的安装配置和使用"><a href="#minicom的安装配置和使用" class="headerlink" title="minicom的安装配置和使用"></a>minicom的安装配置和使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code># apt-get install minicom
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p> 实际案例：交换机的consle转usb口连接到服务器，通过minicom对交换机进行配置</p>
<pre><code># lsusb   //查看USB的状态
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse
Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 002 Device 004: ID 0e0f:0008 VMware, Inc.
Bus 002 Device 005: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port

# dmesg |grep ttyUSB  //USB已经连接
[11991.918691] usb 2-2.2: pl2303 converter now attached to ttyUSB0

# minicom -s   //进行配置

+-----[configuration]------+
| Filenames and paths      |
| File transfer protocols  |
| Serial port setup        |
| Modem and dialing        |
| Screen and keyboard      |
| Save setup as dfl        |
| Save setup as..          |
| Exit                     |
| Exit from Minicom        |
+--------------------------+

#选择进入Serial port setup，按照之前查看的信息进行配置

+-----------------------------------------------------------------------+
| A -    Serial Device      : /dev/ttyUSB0                              |
| B - Lockfile Location     : /var/lock                                 |
| C -   Callin Program      :                                           |
| D -  Callout Program      :                                           |
| E -    Bps/Par/Bits       : 115200 8N1                                |
| F - Hardware Flow Control : Yes                                       |
| G - Software Flow Control : No                                        |
|                                                                       |
|    Change which setting?                                              |
+-----------------------------------------------------------------------+
    | Screen and keyboard      |
    | Save setup as dfl        |
    | Save setup as..          |
    | Exit                     |
    | Exit from Minicom        |
    +--------------------------+

#Enter退出，选择Save setup as dfl  保存为默认配置
</code></pre><p>  然后进入终端输入minicom 就能连接进入交换机配置</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/02/25/ulimit/" class="post-link">ulimit小记</a></h2><span class="post-time">Feb 25, 2016</span><div class="post-content"><h3 id="ulimit简介"><a href="#ulimit简介" class="headerlink" title="ulimit简介"></a>ulimit简介</h3><p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p>
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。</p>
<h3 id="ulimit的设置"><a href="#ulimit的设置" class="headerlink" title="ulimit的设置"></a>ulimit的设置</h3><pre><code>[root@Mr-zhao ~]# ulimit  -a    //查看当前配置文件ulimit全局系数
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7389
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 10240
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 10240
cpu time               (seconds, -t) unlimited
max user processes              (-u) 10240
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</code></pre><p>对于线上环境的机器一般要对<code>open files</code>和<code>max user processes</code>进行修改。</p>
<h4 id="临时性的修改，只对当前shell生效。"><a href="#临时性的修改，只对当前shell生效。" class="headerlink" title="临时性的修改，只对当前shell生效。"></a>临时性的修改，只对当前shell生效。</h4><pre><code>ulimit  -n 65535
ulimit  -u 65535
</code></pre><h4 id="想要ulimit的设置永久性生效，需要修改-etc-security-limits-conf文件。"><a href="#想要ulimit的设置永久性生效，需要修改-etc-security-limits-conf文件。" class="headerlink" title="想要ulimit的设置永久性生效，需要修改/etc/security/limits.conf文件。"></a>想要ulimit的设置永久性生效，需要修改/etc/security/limits.conf文件。</h4><p>对于centos系统/etc/security/limits.d/90-nproc.conf文件的优先级高于/etc/security/limits.conf，所以对全局的设定需修改90-nproc.conf文件。对于单个用户的ulimit的设置并不受etc/security/limits.d/90-nproc.conf影响。</p>
<p>对于ubuntu系统，只需对/etc/security/limits.conf文件进行修改，ubuntu系统没有引入90-nproc.conf文件。但是ubuntux系统也会存在一个问题，就是对全局的设置其实对于root用户是没有效果的。所以ubuntu系统下的设置如下：</p>
<pre><code>root@Mr-zhao:~# grep -Ev &quot;^$|^#&quot; /etc/security/limits.conf
root - nofile 65535
root - nproc  65535
* - nofile 65535
* - nproc 65535
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="external">通过 ulimit 改善系统性能</a><br><a href="http://ss64.com/bash/limits.conf.html" target="_blank" rel="external">limits.conf - configuration file</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/01/15/mysql-duplicate/" class="post-link">MySQL主从复制备忘</a></h2><span class="post-time">Jan 15, 2016</span><div class="post-content"><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li><p>Master:10.249.17.38</p>
</li>
<li><p>Slave:10.249.17.45</p>
</li>
</ul>
<h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><ul>
<li>主从复制的步骤</li>
</ul>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/94D51A80-A0DB-4189-8F30-673260AC6FCC.png" alt=""></p>
<p>1.master将改变记录到二进制日志(binary log)</p>
<p>2.slave将master的binary log events(二进制日志事件)拷贝到它的中继日志(relay log)</p>
<p>3.slave重做中继日志中的事件，将改变反映它自己的数据。</p>
<h3 id="主从复制类型"><a href="#主从复制类型" class="headerlink" title="主从复制类型"></a>主从复制类型</h3><ul>
<li>基于语句的复制：</li>
</ul>
<p>在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。</p>
<ul>
<li>基于行的复制：</li>
</ul>
<p>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持。</p>
<ul>
<li>混合类型的复制:</li>
</ul>
<p>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p>
<h3 id="配置Master和Slave"><a href="#配置Master和Slave" class="headerlink" title="配置Master和Slave"></a>配置Master和Slave</h3><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><pre><code>mysqladmin -u root -p password 123  // 修改密码
mysql&gt; grant replication slave,replication client on *.* to  zzf@10.249.17.45 identified by &quot;zzf&quot;;  //建立内部复制用户

编辑/etc/my.cnf 文件
server_id=1
log-bin=mysql-bin

重启服务
</code></pre><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/BAC-9068-D8174D803F18.png" alt=""></p>
<h4 id="Slave"><a href="#Slave" class="headerlink" title="Slave"></a>Slave</h4><pre><code>mysqladmin -u root -p password 123  // 修改密码
编辑/etc/my.cnf 文件
server_id=2
log-bin=mysql-bin
log_slave_updates=1

mysql&gt; change master to master_host=&apos;10.249.17.38&apos;,master_user=&apos;zzf&apos;,master_password=&apos;zzf&apos;,master_log_file=&apos;mysql-bin.000002&apos;,master_log_pos=106;
mysql&gt; start slave;
</code></pre><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/F2D3964D-8081-4F27-ACFF-39ADF603CCDB.png" alt=""></p>
<p>Slave_IO_Running: Yes</p>
<p>Slave_SQL_Running: Yes</p>
<h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><h4 id="Master-1"><a href="#Master-1" class="headerlink" title="Master"></a>Master</h4><pre><code>mysql&gt;
mysql&gt; create database zzf;
Query OK, 1 row affected (0.01 sec)
mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| test               |
| zzf                |
+--------------------+
4 rows in set (0.00 sec)
</code></pre><h4 id="Slave-1"><a href="#Slave-1" class="headerlink" title="Slave"></a>Slave</h4><pre><code>mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| test               |
| zzf                |
+--------------------+
4 rows in set (0.00 sec)
</code></pre><p>已经同步成功</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/01/09/Create-A-Local-Debian-Ubuntu-Mirror-With-apt-mirror/" class="post-link">Create A Local Debian/Ubuntu Mirror With apt-mirror</a></h2><span class="post-time">Jan 9, 2016</span><div class="post-content"><h3 id="Install-and-Configure-apt-mirror"><a href="#Install-and-Configure-apt-mirror" class="headerlink" title="Install and Configure apt-mirror"></a>Install and Configure apt-mirror</h3><p>Install apt-mirror</p>
<pre><code>$ sudo apt-get install apt-mirror
</code></pre><p>Configure apt-mirror</p>
<p>编辑配置文件/etc/apt/mirror.list，以ubuntu 14.04 为例：</p>
<pre><code>############# config ##################

#

set base_path      /var/spool/apt-mirror

#

set mirror_path    /data/mirror

set skel_path   $base_path/skel

set var_path   $base_path/var

set cleanscript  $var_path/clean.sh      #这个脚本会记录每次同步后那些需要删除的文件

# set defaultarch

# set postmirror_script $var_path/postmirror.sh

# set run_postmirror 0

set nthreads20#用20个线程去wget镜像

set _tilde 0

#

############# end config ##############

deb http://cn.archive.ubuntu.com/ubuntu trusty main restricted universe multiverse

deb http://cn.archive.ubuntu.com/ubuntu trusty-security main restricted universe multiverse

deb http://cn.archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb http://cn.archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse

deb http://cn.archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiverse

deb-i386 http://cn.archive.ubuntu.com/ubuntu trusty main restricted universe multiverse

deb-i386 http://cn.archive.ubuntu.com/ubuntu trusty-security main restricted universe multiverse

deb-i386 http://cn.archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb-i386 http://cn.archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse

deb-i386 http://cn.archive.ubuntu.com/ubun trustytu-backports main restricted universe multiverse

# 如果这个源是要用来做pxe启动的话需要添加(因为默认没有将这几个文件同步过来)

deb http://cn.archive.ubuntu.com/ubuntu trusty main/debian-installer restricted/debian-installer universe/debian-installer multiverse/debian-installer

deb-i386 ttp://cn.archive.ubuntu.com/ubuntu trusty main/debian-installer restricted/debian-installer universe/debian-installer multiverse/debian-installer
</code></pre><p>镜像官方仓库所有软件</p>
<pre><code>$ sudo apt-mirror          
//apt-mirror成功后会执行/var/spool/apt-mirror/var/clean.sh完成同步后的清理工作
</code></pre><h3 id="源的升级与更新"><a href="#源的升级与更新" class="headerlink" title="源的升级与更新"></a>源的升级与更新</h3><p>日常升级</p>
<pre><code>$ sudo apt-mirror
</code></pre><p>计划任务自动更新</p>
<pre><code>0 4 * * * /usr/bin/apt-mirror &gt;&gt; /var/spool/apt-mirror/var/cron.log
</code></pre><h3 id="使用nginx搭建本地镜像源"><a href="#使用nginx搭建本地镜像源" class="headerlink" title="使用nginx搭建本地镜像源"></a>使用nginx搭建本地镜像源</h3><h4 id="nginx-安装配置"><a href="#nginx-安装配置" class="headerlink" title="nginx 安装配置"></a>nginx 安装配置</h4><p>nginx 安装</p>
<p>参考：<a href="http://nginx.org/en/docs/install.html" target="_blank" rel="external">官方文档</a></p>
<p>nginx 基本配置</p>
<p>编辑配置文件 /usr/local/nginx/conf/sites-enabled/mirror.conf</p>
<pre><code>server {
listen       80;
server_name  _;
root         /data/mirror/web;
autoindex    on;
}
</code></pre><p>在<code>/data/mirror/web</code>目录做一个镜像目录的软连接</p>
<pre><code>$ ln -s /data/mirror/archive.ubuntu.com/ubuntu/ /data/mirror/web/ubuntu
</code></pre><p>启动nginx服务</p>
<pre><code>$ sudo /usr/local/nginx/sbin/nginx -t
$ sudo /usr/local/nginx/sbin/nginx
</code></pre><p>本地测试</p>
<p>在浏览器输入搭建nginx机器IP，也可以配置域名访问</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/26720CDE-B91E-40F3-8D46-CAC92FAE90F2.png" alt=""></p>
<h3 id="客户端使用测试"><a href="#客户端使用测试" class="headerlink" title="客户端使用测试"></a>客户端使用测试</h3><p>编辑配置文件 /etc/apt/sources.list 或在/etc/apt/sources.list.d/ 目录下新建文件，并在文件最前面写入如下字段：</p>
<pre><code>deb http://10.249.17.26/ubuntu precise main universe
</code></pre><p>使用</p>
<pre><code>$ apt-get update
$ apt-get install (packagename)
</code></pre></div></article></li></ul><div class="paginator"><a href="/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/page/3/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="https://github.com/Abnerzhao" title="github" class="iconfont icon-github"></a><a href="mailto:opsabnerzhao@gmail.com" title="email" class="iconfont icon-email"></a><a href="http://weibo.com/2863179107/profile?topnav=1&amp;wvr=6&amp;is_all=1" title="weibo" class="iconfont icon-weibo"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2015-2017<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Abnerzhao</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>