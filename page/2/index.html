<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Abnerzhao"><meta name="description" content="DevOps"><title>Abner</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/page/2/"><link rel="alternate" href="/atom.xml" title="Abner"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5832f612aff8681e2ee213a3b8d9548b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Abner</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/23/screen/" class="post-link">Screen会话管理</a></h2><span class="post-time">May 23, 2016</span><div class="post-content"><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<p><a href="http://www.gnu.org/software/screen/">GNU’s Screen 官方站点</a></p>
<h3 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h3><h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>只要Screen本身没有终止，在其内部运行的会话都可以恢复。对于远程登录的用户即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。</p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p></div><a href="/2016/05/23/screen/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/20/opennebula-life-cycle/" class="post-link">OpenNebula life-cycle</a></h2><span class="post-time">May 20, 2016</span><div class="post-content"><h3 id="OpenNebula-Virtual-Machine-Life-cycle"><a href="#OpenNebula-Virtual-Machine-Life-cycle" class="headerlink" title="OpenNebula Virtual Machine Life-cycle"></a>OpenNebula Virtual Machine Life-cycle</h3><p><img src="http://docs.opennebula.org/4.14/_images/states-simple.png" alt=""></p>
<p>具体状态详情请参考：<a href="http://docs.opennebula.org/4.14/user/virtual_resource_management/vm_guide_2.html">vm_guide_2</a></p></div><a href="/2016/05/20/opennebula-life-cycle/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/20/ansible/" class="post-link">Ansible基础知识备忘</a></h2><span class="post-time">May 20, 2016</span><div class="post-content"><h3 id="一、体系结构"><a href="#一、体系结构" class="headerlink" title="一、体系结构"></a>一、体系结构</h3><p>ansible是一款基于python开发，揉合了众多自动化运维工具功能的轻量级自动化运维工具，目前实现了除系统安装以外的批量系统配置、批量任务执行及批量程序部署等功能。</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/25.png" alt=""></p>
<ul>
<li>Inventory：主机库，定义可控制的主机</li>
<li>Modules：基于模块化设计，通过模块来实现批量部署</li>
<li>playbook：剧本，使用YAML编写的声明性的配置文件</li>
<li>plugins: 插件，完成日志记录、邮件等功能</li>
</ul>
<h3 id="二、-特点"><a href="#二、-特点" class="headerlink" title="二、 特点"></a>二、 特点</h3><ul>
<li>高度模块化，借助模块完成各种任务</li>
<li>agentless，无需在被控制端安装agent</li>
<li>默认基于ssh协议向被控制端发送操作指令<ul>
<li>基于密钥认证</li>
<li>在inventory文件中指定账号和密码</li>
</ul>
</li>
<li>批量任务执行可写成剧本playbook</li>
<li>幂等性：不会重复执行相同操作</li>
</ul>
<h3 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h3><h4 id="3-1-ssh免密钥登录"><a href="#3-1-ssh免密钥登录" class="headerlink" title="3.1 ssh免密钥登录"></a>3.1 ssh免密钥登录</h4><pre><code># ssh-keygen -t rsa -P &apos;&apos;  
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.249.6.64
# ssh-copy-id  -i /root/.ssh/id_rsa.pub  10.48.156.8
</code></pre><h4 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h4><p>ansible-doc</p>
<pre><code>Options:

-l, --list            List available modules  //列出所有模块
-s, --snippet         Show playbook snippet for specified module(s) //查看指定模块用法

更多信息请参考manual手册
</code></pre><p>ansible</p>
<p> ansible <host-pattern>  [-f forks][-m module_name] [-a args] [options]</host-pattern></p>
<pre><code>Options:

  -a MODULE_ARGS, --args=MODULE_ARGS
                    module arguments   // 传递模块参数
  -f FORKS, --forks=FORKS  // 指定并发数
                    specify number of parallel processes to use
                    (default=5)
  -i INVENTORY, --inventory-file=INVENTORY 
                    specify inventory host file
                    (default=/etc/ansible/hosts)    
  -m MODULE_NAME, --module-name=MODULE_NAME
                    module name to execute (default=command)   

 更多信息请参考manual手册        
</code></pre><p>ansible-playbook  </p>
<p>ansible-playbook <filename.yml> … [options]             </filename.yml></p>
<h3 id="四、模块"><a href="#四、模块" class="headerlink" title="四、模块"></a>四、模块</h3><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>命令模块: ansible默认模块，用于在远程执行命令，command模块并不支持shell变量和管道等，若想使用shell来执行，应使用shell模块。</p>
<pre><code># ansible-doc -l | grep ^command
command              Executes a command on a remote node                        

# ansible 10.249.6.64 -m command -a &quot;date&quot;
10.249.6.64 | success | rc=0 &gt;&gt;
Wed May 11 21:21:35 CST 2016                        
</code></pre><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping模块：测试指定主机是否能连接</p>
<pre><code># ansible-doc -l | grep  -w ^ping
ping                 Try to connect to host and return `pong&apos; on success.                  

# ansible 10.249.6.64 -m ping
10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
</code></pre><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>计划任务模块 ：管理计划任务</p>
<pre><code># ansible-doc -l | grep  ^cron
cron                 Manage cron.d and crontab entries.

# ansible-doc  -s cron
- name: Manage cron.d and crontab entries.
action: cron
  backup                 # If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup&apos; variable by this module.
  cron_file              # If specified, uses this file in cron.d instead of an individual user&apos;s crontab.
  day                    # Day of the month the job should run ( 1-31, *, */2, etc )
  hour                   # Hour when the job should run ( 0-23, *, */2, etc )
  job                    # The command to execute. Required if state=present.
  minute                 # Minute when the job should run ( 0-59, *, */2, etc )
  month                  # Month of the year the job should run ( 1-12, *, */2, etc )
  name                   # Description of a crontab entry.
  reboot                 # If the job should be run at reboot. This option is deprecated. Users should use special_time.
  special_time           # Special time specification nickname.
  state                  # Whether to ensure the job is present or absent.
  user                   # The specific user who&apos;s crontab should be modified.
  weekday                # Day of the week that the job should run ( 0-7 for Sunday - Saturday, *, etc )        

# ansible 10.249.6.64 -m cron -a &apos;name=&quot;sync time&quot; minute=&quot;*/10&quot; \ 
job=&quot;/usr/sbin/ntpdate 0.centos.pool.ntp.org &amp;&amp; hwclock -w&quot; &apos;

10.249.6.64 | success &gt;&gt; {
    &quot;changed&quot;: true,
    &quot;jobs&quot;: [
    &quot;sync time&quot;
    ]
}                   
</code></pre><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>用户模块：管理用户账户</p>
<pre><code># ansible-doc -l | grep ^user
user                 Manage user accounts  

# ansible 10.249.6.64 -m user -a &apos;name=work shell=/bin/bash home=/home/www&apos;   //添加用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;comment&quot;: &quot;&quot;,
&quot;createhome&quot;: true,
&quot;group&quot;: 500,
&quot;home&quot;: &quot;/home/www&quot;,
&quot;name&quot;: &quot;work&quot;,
&quot;shell&quot;: &quot;/bin/bash&quot;,
&quot;state&quot;: &quot;present&quot;,
&quot;system&quot;: false,
&quot;uid&quot;: 500
}        

# ansible 10.249.6.64 -m user -a &apos;name=work state=absent&apos;  // 删除用户
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;force&quot;: false,
&quot;name&quot;: &quot;work&quot;,
&quot;remove&quot;: false,
&quot;state&quot;: &quot;absent&quot;
}             
</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy模块：文件复制</p>
<pre><code>#  ansible-doc -l | grep ^copy
copy                 Copies files to remote locations. 

# ansible-doc -s copy
- name: Copies files to remote locations.
action: copy
  backup                 # Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
  content                # When used instead of &apos;src&apos;, sets the contents of a file directly to the specified value.
  dest=                  # Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.
  directory_mode         # When doing a recursive copy set the mode for the directories. If this is not set we will default the system defaults.
  force                  # the default is `yes&apos;, which will replace the remote file when contents are different than the source.  If `no&apos;, the file will only be transferred if the destination does not exist.
  src                    # Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with &quot;/&quot;, only inside contents of that directory are copied to destination. Otherwise, if it does not end with &quot;/&quot;, the directory itself with all contents is copied. This behavior is similar to Rsync.
  validate               # The validation command to run before copying into place.  The path to the file to validate is passed in via &apos;%s&apos; which must be present as in the visudo example below. The command is passed securely so shell features like expansion and pipes won&apos;t work.

# ansible 10.249.6.64 -m copy -a &quot;src=/root/test.txt dest=/tmp/&quot;
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;dest&quot;: &quot;/tmp/test.txt&quot;,
&quot;gid&quot;: 0,
&quot;group&quot;: &quot;root&quot;,
&quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;,
&quot;mode&quot;: &quot;0644&quot;,
&quot;owner&quot;: &quot;root&quot;,
&quot;size&quot;: 0,
&quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1463662606.99-26627840524349/source&quot;,
&quot;state&quot;: &quot;file&quot;,
&quot;uid&quot;: 0
}   
# ansible 10.249.6.64 -m copy -a &quot;content=&apos;hello world&apos; dest=/tmp/test.txt&quot;
# ansible 10.249.6.64 -m copy -a &apos;src=/root/test.txt dest=/tmp/test.txt owner=evans group=evans mode=600 backup=yes&apos;
</code></pre><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file模块：文件模块，设置文件属性</p>
<pre><code># ansible-doc -l | grep -w ^file
file                 Sets attributes of files   
# ansible 10.249.6.64 -m file -a &quot;src=/tmp/test.txt path=/tmp/test.link state=link&quot;
# ansible 10.249.6.64 -m file -a &quot;owner=evans group=evans mode=600 path=/tmp/test.txt&quot;
</code></pre><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service模块： 服务模块，管理系统服务</p>
<pre><code># ansible-doc -l | grep ^service
service              Manage services.
# ansible-doc -s service
 - name: Manage services.
 action: service
  arguments              # Additional arguments provided on the command line
  enabled                # Whether the service should start on boot. *At least one of state and enabled are required.*
  name=                  # Name of the service.
  pattern                # If the service does not respond to the status command, name a substring to look for as would be found in the output of the `ps&apos; command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.
  runlevel               # For OpenRC init scripts (ex: Gentoo) only.  The runlevel that this service belongs to.
  sleep                  # If the service is being `restarted&apos; then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.
  state                  # `started&apos;/`stopped&apos; are idempotent actions that will not run commands unless necessary.  `restarted&apos; will always bounce the service.  `reloaded&apos; will always reload. *At least one of state and enabled are required.*
  # ansible 10.249.6.64 -m service -a &quot;name=mysqld state=restarted enabled=true&quot;  //重启mysql服务并设置开机自启动
</code></pre><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell模块：远程执行命令</p>
<pre><code># ansible 10.249.6.64 -m shell -a &apos;date&apos;
10.249.6.64 | success | rc=0 &gt;&gt;
Thu May 19 21:20:51 CST 2016    
</code></pre><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>script模块：脚本模块，远程主机运行脚本</p>
<pre><code># ansible-doc  -l | grep ^script
script               Runs a local script on a remote node after transferring it..
# ansible 10.249.6.64 -m script -a &apos;/root/test.sh&apos;  //在远程主机上运行脚本，并没有拷贝到指定目录
10.249.6.64 | success &gt;&gt; {
&quot;changed&quot;: true,
&quot;rc&quot;: 0,
&quot;stderr&quot;: &quot;&quot;,
&quot;stdout&quot;: &quot;&quot;
}   
</code></pre><h4 id="yum、apt"><a href="#yum、apt" class="headerlink" title="yum、apt"></a>yum、apt</h4><p>yum模块和apt模块：包管理模块</p>
<pre><code>yum                  Manages packages with the `yum&apos; package manager
apt                  Manages apt-packages
# ansible 10.249.6.64 -m yum -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=present&quot;
# ansible 10.249.6.43 -m apt -a &quot;name=tree state=absent&quot;
</code></pre><blockquote>
<p> state<br> Whether to install (<code>present&#39;,</code>latest’), or remove (`absent’) a package.</p>
</blockquote>
<h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup模块：收集主机信息，playbook运行时，会自动调用setup模块收集远程主机的相关信息（称为facts，如操作系统版本、ip地址、cpu数量等），这些信息保存于变量中，可在playbook中引用</p>
<pre><code># ansible-doc -l | grep  setup
setup                Gathers facts about remote hosts
# ansible-doc -s setup
- name: Gathers facts about remote hosts
 action: setup
  fact_path              # path used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. File/results format can be json or ini-format
  filter                 # if supplied, only return facts that match this shell-style (fnmatch) wildcard.
# ansible 10.249.6.43 -m setup
# ansible 10.249.6.43 -m setup -a &apos;filter=ansible_eth0&apos;   //过滤信息
# ansible 10.249.6.64 -m setup --tree /tmp/test.txt  //将收集的信息输出到本地文件
</code></pre><p>更多模块信息请查看：<a href="http://docs.ansible.com/ansible/list_of_all_modules.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="五、playbook"><a href="#五、playbook" class="headerlink" title="五、playbook"></a>五、playbook</h3><h4 id="5-1-YAML"><a href="#5-1-YAML" class="headerlink" title="5.1 YAML"></a>5.1 YAML</h4><p>YAML是一种可读性高的用来表达资料序列的语言，其语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。</p>
<p>所有的yaml文件都以”—“开头表示开始一个document，所有的列表元素以”-“开头，键值对用”:”，后面必须有空格。YAML文件扩展名通常为.yaml或.yml</p>
<h4 id="5-2-playbook简介"><a href="#5-2-playbook简介" class="headerlink" title="5.2 playbook简介"></a>5.2 playbook简介</h4><p>playbook是ansible管理配置、部署应用和编排的文件，可用来描述在远程主机上执行的策略或一组任务。</p>
<p>一个playbook文件由一个或多个play组成，每个play定义了在一个或多个远程主机上执行的一系列的task，其中每个task一般就是调用一个ansible的模块。</p>
<p>playbook使用YAML语言编写，文件名以.yaml或.yml结尾。此外playbook和模板文件（template）还可使用jinja2语法语法实现高级功能。</p>
<p>5.2.1 playbook的基本组成</p>
<ul>
<li>targets：指定要执行playbook的远程主机组</li>
<li>variables：定义playbook运行时需要使用的变量</li>
<li>tasks：要执行的任务</li>
<li>handlers：处理器，在某些条件下被触发的操作</li>
</ul>
<p>简单playbook示例：</p>
<pre><code># cat nginx.yml
---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started

  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
# ansible-playbook  nginx.yml   // 执行playbook
</code></pre><ul>
<li>hosts、user</li>
</ul>
<p>hosts用于指定要执行指定任务的主机，其可以是一个或多个由逗号分隔主机组；user则用于指定远程主机上的执行任务的用户，还能使用sudo</p>
<ul>
<li>task list、action</li>
</ul>
<p>task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可。</p>
<p> task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致。</p>
<p> 每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出。</p>
<p>定义task的可以使用“action: module options”或“module: options”的格式，推荐使用后者以实现向后兼容例如：</p>
<pre><code>tasks:
- name: make sure apache is running
  service: name=httpd state=running
</code></pre><p> 在众多模块中，只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式，例如：</p>
<pre><code>tasks:
- name: disable selinux
  command: /sbin/setenforce 0
</code></pre><p>shell模块执行多条命令       </p>
<pre><code>---
- name: update zabbix agent conf
shell: |     
   sed  -i &quot;/Hostname/d&quot; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf
   wget -O /tmp/hostinfo.txt http://10.126.93.2/bak/hostinfo.txt
   IP=`ifconfig | egrep -A1 eth[0-9] | egrep  -o  addr:[0-9]+.[0-9]+.[0-9]+.[0-9]+ | awk -F: &apos;{print $2}&apos;`
   USE=`egrep -w  $IP /tmp/hostinfo.txt | awk &apos;{print $2}&apos;| uniq`
   HOST=`hostname | awk -F . &apos;{print $1}&apos;`
   echo &quot;Hostname=${USE}${HOST}&quot; &gt;&gt; /usr/local/zabbix-agent-ops/etc/zabbix_agentd.conf   
</code></pre><p>如果模块执行返回值不为零，即表示执行失败，任务会立即中止，后续任务不再执行。可以使用ignore_errors来忽略错误信息确保后续任务的执行。</p>
<pre><code>tasks:
   - name: run this command and ignore the result
     shell: /usr/bin/somecommand
     ignore_errors: yes
</code></pre><ul>
<li>handlers</li>
</ul>
<p>当关注的资源发生变化时触发一定的操作。handler是task列表，这些task与前述的task并没有本质上的不同。</p>
<p>“notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，取而代之，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。       </p>
<pre><code>- name: template configuration file
  template: src=/root/template.conf dest=/etc/template.conf

notify:
  - restart memcached
  - restart apache

handlers:
- name: restart memcached
  service: name=memcached state=restarted
- name: restart apache
  service: name=apache state=restarted
</code></pre><ul>
<li>vars</li>
</ul>
<p>变量名仅能由字母、数字和下划线组成，且只能以字母开头  </p>
<ul>
<li>when </li>
</ul>
<p>条件判断：如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提，这时就要用到条件判断。</p>
<pre><code>when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;

when: ansible_distribution == &apos;CentOS&apos; or ansible_distribution == &apos;RedHat&apos; and ansible_distribution_version|int &gt;=6
</code></pre><p>忽略此前某语句的错误并基于其结果（failed或者sucess）运行后面指定的语句:</p>
<pre><code>---
- hosts: 10.249.6.64
  user: root
  tasks:
    - name: false test
      command: /bin/false
      register: result
      ignore_errors: yes
    - name: when false  to do
      command: touch /tmp/1.txt
      when: result | failed
    - name: when success to do
      command: touch /tmp/2.txt
      when: result | success
    - name: when skip to do
      command: touch /tmp/3.txt
      when: result | skipped
</code></pre><ul>
<li>item</li>
</ul>
<p>item 迭代：当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可</p>
<pre><code>- name: install base software
  apt: pkg={{ item }} state=present force=yes
  with_items:
    - gcc
    - g++
    - mysql-client-5.5
    - libmcrypt-dev
    - libmysqlclient-dev
    - libgmp10
    - vim
    - openssh-client
    - ethtool
when: ansible_distribution == &apos;Debian&apos; or ansible_distribution == &apos;Ubuntu&apos;
</code></pre><ul>
<li>tag</li>
</ul>
<p>tag标签：让用户选择运行playbook中的某个或某些任务。虽然ansible具有幂等性，会跳过没有变化的部分，有些代码为测试其确实没有发生变化，也会耗费很长时间。我们将playbook中的指定任务打上标签，在运行playbook时指定标签名称，这样就不用运行全部代码了。</p>
<pre><code>---
- hosts: 10.249.6.43
  user: root
  vars:
    remote_conffile_path: /etc/nginx/sites-enabled/mirror.conf
  tasks:
  - name: install nginx
    apt: name=nginx state=latest
    when: ansible_distribution == &apos;Ubuntu&apos;

  - name: configration file
    tags: conf
    copy: src=/root/mirror.conf dest={{remote_conffile_path}}
    notify: restart nginx

  - name: start nginx
    service: name=nginx enabled=yes state=started
  handlers:
  - name: restart nginx
    service: name=nginx state=restarted
    # ansible-playbook nginx.yml -t conf   // 只执行tags部分
</code></pre><h3 id="六、roles"><a href="#六、roles" class="headerlink" title="六、roles"></a>六、roles</h3><p>roles 用于层次性、结构化地组织playbook。</p>
<p>roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p>
<pre><code># ls
deploy_hosts  deploy.yml  roles  run.sh
# cat deploy_hosts   //主机或主机组列表
[web]
10.126.83.30
10.126.93.83
[db]
10.126.87.150
10.126.92.89
# cat deploy.yml  // 总的playbook 调用roles
---
- name: init for os
  hosts: web
  user: root
  gather_facts: True
  roles:
    - init
    - raid
- name: init for os
  hosts: db
  user: root
  gather_facts: True
  roles:
    - init
    - raid
    - db_init

# cat run.sh  // 运行playbook脚本
#!/bin/bash
/usr/bin/ansible-playbook -i ./deploy_hosts deploy.yml
# ls roles/
db_init   init    raid 
</code></pre><p>在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录，用不到的目录可以创建为空目录，也可以不创建。</p>
<p>role内各目录中可用的文件:</p>
<ul>
<li><p>tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件</p>
</li>
<li><p>files目录：存放由copy或script等模块调用的静态文件</p>
</li>
<li><p>templates目录：template模块会自动在此目录中寻找Jinja2模板文件</p>
</li>
<li><p>handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；此文件可以使用include包含其它的位于此目录中的handler文件</p>
</li>
<li><p>vars目录：至少有一个main.yml文件，用于定义此角色用到的变量</p>
</li>
<li><p>meta目录：至少有一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持</p>
</li>
<li><p>default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件</p>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://9124573.blog.51cto.com/9114573/1769887" target="_blank" rel="external">轻量级自动化运维工具ansible</a></p>
<p><a href="http://docs.ansible.com/ansible/intro.html" target="_blank" rel="external">ansible doc</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/18/zabbix-agent/" class="post-link">Zabbix工作模式</a></h2><span class="post-time">May 18, 2016</span><div class="post-content"><blockquote>
<p>Zabbix uses a JSON based communication protocol for communicating with Zabbix agent.</p>
</blockquote>
<p>zabbix agent通信过程中的协议均基于json格式。主动模式和被动模式是相对于agent来说的。agent主动发送数据给server即为主动模式。</p>
<h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h3><p>server向agent请求获取监控项的数据，agent返回数据。</p>
<blockquote>
<p>A passive check is a simple data request. Zabbix server or proxy asks for some data (for example, CPU load) and Zabbix agent sends back the result to the server.</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Server 发起请求：</p>
<pre><code>&lt;item key&gt;\n
</code></pre><p>Agent 返回响应数据：</p>
<pre><code>&lt;HEADER&gt;&lt;DATALEN&gt;&lt;DATA&gt;
</code></pre><p>server发送request给agent，agent收到request后本地执行相关检测收集到数据之后，发送数据到server端， 以agent.ping key 值为例具体工作流程如下：</p>
<p>1.Server opens a TCP connection</p>
<p>2.Server sends agent.ping\n</p>
<p>3.Agent reads the request and responds with <header><datalen></datalen></header></p>
<p>4.Server processes data to get the value, ‘1’ in our case</p>
<p>5.TCP connection is closed</p>
<h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h3><blockquote>
<p>Active checks require more complex processing. The agent must first retrieve from the server(s) a list of items for independent processing.</p>
<p>The servers to get the active checks from are listed in the ‘ServerActive’ parameter of the agent configuration file. The frequency of asking for these checks is set by the ‘RefreshActiveChecks’ parameter in the same configuration file. However, if refreshing active checks fails, it is retried after hardcoded 60 seconds. The agent then periodically sends the new values to the server(s).</p>
</blockquote>
<p>主动模式的工作流程要比被动模式的复杂一些，zabbix客户端代理（Agent）首先必须从服务器获取监控项列表来进行独立处理，然后它将定期发送新数据给服务器。</p>
<p>Part1: Getting the list of items</p>
<ol>
<li><p>Agent opens a TCP connection</p>
</li>
<li><p>Agent asks for the list of checks</p>
</li>
<li><p>Server responds with a list of items (item key, delay)</p>
</li>
<li><p>Agent parses the response</p>
</li>
<li><p>TCP connection is closed</p>
</li>
<li><p>Agent starts periodical collection of data</p>
</li>
</ol>
<p>Part2: agent send values</p>
<ol>
<li>Agent opens a TCP connection</li>
<li>Agent sends a list of values</li>
<li>Server processes the data and sends the status back</li>
<li>TCP connection is closed</li>
</ol>
<p>当使用被动式的时候，server和agent之间需要对每个item的检测建立一次tcp连接。 如果检测的item和agent过多的时候，对server端的性能是一个很大的考验，所以当agent 和items 数量增多时可以根据实际情况设置工作模式。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zabbix.com/documentation/2.2/manual/appendix/items/activepassive#passive_checks" target="_blank" rel="external">zabbix doc </a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/05/05/nc/" class="post-link">nc小知识</a></h2><span class="post-time">May 5, 2016</span><div class="post-content"><h3 id="远程拷贝文件"><a href="#远程拷贝文件" class="headerlink" title="远程拷贝文件"></a>远程拷贝文件</h3><p>server1: 10.48.156.8</p>
<p>server2: 10.249.6.43</p>
<p><strong>从server1拷贝文件到server2</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -lp 1234 &gt; file.txt
</code></pre><blockquote>
<p>-l：使用监听模式，监控传入的资料</p>
<p>-p &lt;通信端口&gt;：设置本地主机使用的通信端口</p>
</blockquote>
<p>然后server1上运行：</p>
<pre><code># ll file.txt
-rw-r--r-- 1 root root 35 May  5 20:43 file.txt
# nc 10.249.6.43  1234 &lt; file.txt
</code></pre><h3 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h3><p><strong>从server1拷贝MySQL-python-1.2.3目录内容到server2上</strong></p>
<p>先在server2上激活监听：</p>
<pre><code># nc -l 1234 | tar xzvf -
</code></pre><p>然后server1上运行：</p>
<pre><code># ll -d MySQL-python-1.2.3
drwxrwxr-x 3 500 500 4096 Jan  3 18:13 MySQL-python-1.2.3
# tar czvf - MySQL-python-1.2.3 | nc 10.249.6.43 1234
</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><pre><code># nc localhost -z 22   //扫描本机端口
Connection to localhost 22 port [tcp/ssh] succeeded!
# nc 10.126.93.2 -z 80  //扫描远程机器端口
Connection to 10.126.93.2 80 port [tcp/http] succeeded!
# nc -v 10.126.93.2 -z 1-100  //指示扫描过程    
</code></pre><blockquote>
<p>-v：显示指令执行过程</p>
<p>-z：使用0输入/输出模式，只在扫描通信端口时使用</p>
<p>-w &lt;超时秒数&gt;：设置等待连线的时间</p>
</blockquote>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/04/23/opennebula/" class="post-link">OpenNebula 4.14 快速入门</a></h2><span class="post-time">Apr 23, 2016</span><div class="post-content"><h3 id="一、OpenNebula简介"><a href="#一、OpenNebula简介" class="headerlink" title="一、OpenNebula简介"></a>一、OpenNebula简介</h3><ul>
<li>1.1 云管理平台的选择</li>
<li>1.2 OpenNebula体系结构</li>
<li>1.3 OpenNebula组件介绍</li>
</ul>
<h3 id="二、OpenNebula安装配置"><a href="#二、OpenNebula安装配置" class="headerlink" title="二、OpenNebula安装配置"></a>二、OpenNebula安装配置</h3><ul>
<li>2.1 环境说明</li>
<li>2.2 软件包组成</li>
<li>2.3 Server端安装和配置</li>
<li>2.4 节点端安装配置</li>
</ul>
<h3 id="三、节点添加"><a href="#三、节点添加" class="headerlink" title="三、节点添加"></a>三、节点添加</h3><ul>
<li>3.1 web界面添加主机</li>
<li>3.2 命令行添加主机<ul>
<li>3.2.1 onehost 命令</li>
</ul>
</li>
</ul>
<h3 id="四、制作系统镜像"><a href="#四、制作系统镜像" class="headerlink" title="四、制作系统镜像"></a>四、制作系统镜像</h3><ul>
<li>4.1 qemu-img命令</li>
<li>4.2 qemu-kvm（ kvm ）命令</li>
<li>4.3 系统优化</li>
</ul>
<h3 id="五、导入镜像"><a href="#五、导入镜像" class="headerlink" title="五、导入镜像"></a>五、导入镜像</h3><ul>
<li>5.1 web界面导入映像</li>
<li>5.2 命令行导入映像<ul>
<li>5.2.1 oneimg 命令</li>
</ul>
</li>
</ul>
<h3 id="六、虚拟网络"><a href="#六、虚拟网络" class="headerlink" title="六、虚拟网络"></a>六、虚拟网络</h3><ul>
<li>6.1 web界面添加虚拟网络</li>
<li>6.2 命令行添加虚拟网络<ul>
<li>6.2.1 onevnet 命令</li>
</ul>
</li>
</ul>
<h3 id="七、制作模板"><a href="#七、制作模板" class="headerlink" title="七、制作模板"></a>七、制作模板</h3><ul>
<li>7.1 web 界面制作模板</li>
<li>7.2 Context初始化功能<ul>
<li>7.2.1 修改母盘镜像</li>
</ul>
</li>
</ul>
<h3 id="八、创建虚拟机"><a href="#八、创建虚拟机" class="headerlink" title="八、创建虚拟机"></a>八、创建虚拟机</h3><ul>
<li>8.1 web界面创建虚拟机 </li>
</ul>
<h2 id="一、OpenNebula简介-1"><a href="#一、OpenNebula简介-1" class="headerlink" title="一、OpenNebula简介"></a>一、OpenNebula简介</h2><h3 id="1-1-云管理平台的选择"><a href="#1-1-云管理平台的选择" class="headerlink" title="1.1 云管理平台的选择"></a>1.1 云管理平台的选择</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/5BA41662-3FBA-42C6-928C-4EB8B665BD4C.png" alt=""></p>
<p><strong>OpenNebula</strong></p>
<p>OpenNebula是一款功能丰富且灵活性非常强的解决方案，用于构建和管理企业云及数据中心虚拟化。OpenNebula支持Xen、KVM、VMware ESX虚拟化引擎，可以一起混合建立和管理私有云，同时还提供了Deltacloud适配器和Amazon EC2的API兼容。官方网站 <a href="http://opennebula.org/。" target="_blank" rel="external">http://opennebula.org/。</a></p>
<h3 id="1-2-OpenNebula体系结构"><a href="#1-2-OpenNebula体系结构" class="headerlink" title="1.2 OpenNebula体系结构"></a>1.2 OpenNebula体系结构</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/039ED6D4-843B-4C7C-827E-88D680082A58.png" alt=""></p>
<h3 id="1-3-OpenNebula组件介绍"><a href="#1-3-OpenNebula组件介绍" class="headerlink" title="1.3 OpenNebula组件介绍"></a>1.3 OpenNebula组件介绍</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C7012638-A918-4D89-815C-15BAEAB2E735.png" alt=""></p>
<p><strong>Front-End（前端）</strong></p>
<p>用于运行OpenNebula服务。包含了诸多功能组件，如OpenNebula管理进程oned、调度器mm_sched、一个Web接口服务sunstone-server。</p>
<p><strong>Host（宿主机）</strong></p>
<p>用于运行所有虚拟机</p>
<p><strong>Datastores（数据存储）</strong></p>
<p>用于实际存放虚拟机的硬盘，可以是任意一种存储介质，NAS（网络附加存储）、SAN（存储区域网络）、直连存储设备（宿主机本地硬盘）。<br>数据存储可以细分为三大类：</p>
<ul>
<li>系统数据存储</li>
<li>镜像数据存储</li>
<li>文件数据存储</li>
</ul>
<p><strong>Network（网络）</strong></p>
<h2 id="二、OpenNebula安装配置-1"><a href="#二、OpenNebula安装配置-1" class="headerlink" title="二、OpenNebula安装配置"></a>二、OpenNebula安装配置</h2><h3 id="2-1-环境说明"><a href="#2-1-环境说明" class="headerlink" title="2.1 环境说明"></a>2.1 环境说明</h3><p>系统环境：ubuntu 14.04</p>
<p>OpenNebula版本：4.14</p>
<h3 id="2-2-软件包组成"><a href="#2-2-软件包组成" class="headerlink" title="2.2 软件包组成"></a>2.2 软件包组成</h3><p>从官网下载源码包或使用OpenNebula源，添加 OpenNebula 源方法如下:</p>
<pre><code># wget -q -O- http://downloads.opennebula.org/repo/Ubuntu/repo.key | apt-key add -
# echo &quot;deb http://downloads.opennebula.org/repo/4.14/Ubuntu/14.04/ stable opennebula&quot; \
&gt; /etc/apt/sources.list.d/opennebula.list
</code></pre><p>OpenNebula主要由以下软件包组成：</p>
<ul>
<li>opennebula-common  Provides the user and common files</li>
<li>ruby-opennebula: All ruby libraries</li>
<li>opennebula-node: Prepares a node as an opennebula-node</li>
<li>opennebula-sunstone: OpenNebula Sunstone Web Interface</li>
<li>opennebula-tools: Command Line interface</li>
<li>opennebula-gate: Gate server that enables communication between VMs and OpenNebula</li>
<li>opennebula-flow: Manages services and elasticity</li>
<li>libopennebula-java: Java Language bindings for OpenNebula API</li>
<li>opennebula: OpenNebula Daemon</li>
<li>libopennebula-java: Java Language bindings for OpenNebula API</li>
</ul>
<h3 id="2-3-Server端安装和配置"><a href="#2-3-Server端安装和配置" class="headerlink" title="2.3 Server端安装和配置"></a>2.3 Server端安装和配置</h3><p>上文已经配置好了OpenNebula 的源,安装方法如下:</p>
<pre><code># apt-get install opennebula opennebula-sunstone -y
</code></pre><p>安装完成之后检查创建的用户以及目录文件：</p>
<pre><code># grep oneadmin /etc/passwd
oneadmin:x:9869:9869::/var/lib/one:/bin/bash
# ls -ld /etc/one/
drwxr-xr-x 8 root root 4096 Apr 23 16:22 /etc/one/
# ls /etc/init.d/opennebula*
/etc/init.d/opennebula        /etc/init.d/opennebula-novnc
/etc/init.d/opennebula-econe  /etc/init.d/opennebula-sunstone
# ls -ld /var/log/one/
drwxr-xr-x 2 oneadmin oneadmin 4096 Apr 23 16:22 /var/log/one/
</code></pre><p>默认 OpenNebula 使用数据库为sqlite,如果需要使用 MySQL,则需要做如下操作:</p>
<p>1.创建opennebula数据库</p>
<pre><code>mysql&gt; create database opennebula;
Query OK, 1 row affected (0.00 sec)

mysql&gt; grant all privileges on opennebula.* to oneadmin@&apos;localhost&apos; identified by &apos;oneadmin&apos;;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)
</code></pre><p>2.修改配置文件</p>
<pre><code># vi /etc/one/oned.conf
......
#DB = [ backend = &quot;sqlite&quot; ]
# Sample configuration for MySQL 

DB = [ backend = &quot;mysql&quot;,
   server  = &quot;localhost&quot;,
   port    = 3306,
   user    = &quot;oneadmin&quot;,
   passwd  = &quot;oneadmin&quot;,
   db_name = &quot;opennebula&quot; ]
......
</code></pre><p>修改 sunstone 默认监听 IP:</p>
<pre><code># grep &apos;:host&apos; /etc/one/sunstone-server.conf
:host: 127.0.0.1
# sed -i &apos;/:host/s/127.0.0.1/10.249.7.247/g&apos; /etc/one/sunstone-server.conf
# grep &apos;:host&apos; /etc/one/sunstone-server.conf
:host: 10.249.7.247
</code></pre><p>启动相关服务:</p>
<pre><code># /etc/init.d/opennebula start
# /etc/init.d/opennebula-sunstone  start
# lsof -i:9869
COMMAND   PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ruby    15387 oneadmin    8u  IPv4  50024      0t0  TCP 10.249.7.247:9869 (LISTEN)
</code></pre><p>修改datastore：</p>
<p>OpenNebula 默认用的是 Shared Transfer Driver,这种模式比较适合快速部署和热迁移,但是要配置网络文件系统。由于我们这里并没有配置网络文件系统,暂时也无法做热迁移,那么可以换成 SSH Transfer Driver 测试部署。</p>
<pre><code># onedatastore list
ID NAME                SIZE AVAIL CLUSTER      IMAGES TYPE DS      TM      STAT
0 system                0M -     -                 0 sys  -       shared  on
1 default             2.6T 95%   -                 0 img  fs      shared  on
2 files               2.6T 95%   -                 0 fil  fs      ssh     on
# onedatastore update 1
BASE_PATH=&quot;/var/lib/one//datastores/&quot;
CLONE_TARGET=&quot;SYSTEM&quot;
DISK_TYPE=&quot;FILE&quot;
DS_MAD=&quot;fs&quot;
LN_TARGET=&quot;SYSTEM&quot;
TM_MAD=&quot;ssh&quot;
TYPE=&quot;IMAGE_DS&quot;
# onedatastore list
ID NAME                SIZE AVAIL CLUSTER      IMAGES TYPE DS      TM      STAT
0 system                0M -     -                 0 sys  -       shared  on
1 default             2.6T 95%   -                 0 img  fs      ssh     on
2 files               2.6T 95%   -                 0 fil  fs      ssh     on
</code></pre><p>浏览器登陆测试: </p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/03030E96-598A-479F-9043-722559F20579.png" alt=""></p>
<p>用户名和密码通过以下方式获得:</p>
<pre><code># cat /var/lib/one/.one/one_auth
oneadmin:EcvubryacOv9
</code></pre><h3 id="2-4-节点端安装配置"><a href="#2-4-节点端安装配置" class="headerlink" title="2.4 节点端安装配置"></a>2.4 节点端安装配置</h3><p>opennebula的源的配置见Server端安装配置章节，节点端软件包安装如下：</p>
<pre><code># apt-get install opennebula-node  bridge-utils -y
</code></pre><p>安装过程同时会安装虚拟化相关组件,包括 bridge-utils、libvirt、 kvm、qemu-img 等。</p>
<p>网络配置：</p>
<p>eth0 为管理网口，eth1 为trunk口用作虚拟机通信，需要创建桥接网口。官方文档中提示需要手动创建桥接网络，但是本人在实际使用中通过web管理平台的虚拟网络可以实现自动绑定br0 到eth1网卡上。</p>
<pre><code># cat /etc/network/interfaces
auto lo
iface lo inet loopback
auto eth0
iface eth0 inet static
address 10.249.7.247
netmask 255.255.255.0
gateway 10.249.7.254
auto eth1
iface eth1 inet manual
# brctl show
bridge name bridge id       STP enabled interfaces
virbr0      8000.000000000000   yes
</code></pre><p>查看qemu的配置：</p>
<pre><code># cat /etc/libvirt/qemu.conf
user  = &quot;oneadmin&quot;
group = &quot;oneadmin&quot;
dynamic_ownership = 0
</code></pre><p>启动libvirt服务：</p>
<pre><code># service libvirt-bin restart
</code></pre><p>ssh 无密码登陆:</p>
<p>管理端：</p>
<pre><code># su - oneadmin
$ cat &lt;&lt; EOT &gt; ~/.ssh/config    //不询问直接添加主机到known_hosts文件
Host *
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
EOT
$ chmod 600 ~/.ssh/config
</code></pre><p>节点端：</p>
<pre><code>￼# su - oneadmin
$ vim  ~/.ssh/authorized_key   //把管理端ssh公钥加入节点.ssh/authorized_keys文件
$ chmod 400 .ssh/authorized_keys
</code></pre><h2 id="三、节点添加-1"><a href="#三、节点添加-1" class="headerlink" title="三、节点添加"></a>三、节点添加</h2><p>节点配置完成之后便可以在 Server 端添加了,可以使用web 添加,也可以在命令行中添加。</p>
<h3 id="3-1-web界面添加主机"><a href="#3-1-web界面添加主机" class="headerlink" title="3.1 web界面添加主机"></a>3.1 web界面添加主机</h3><p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/907F38A5-3CA1-4424-8867-BA815E3EE4D6.png" alt=""></p>
<p>创建主机,主机名一栏可以是IP也可以是可以解析的主机域名,这里使用的是IP</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/7250BDBA-1EAE-4750-9C93-5BD3D29A7263.png" alt=""></p>
<p>如上图选择完之后,点击创建按钮就可以出现如下主机,状态为初始化</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/02DF2945-100E-4846-8D66-297B86D3A8BD.png" alt=""></p>
<p>如果一切正常,等待片刻则状态就会变为开机,也会显示主机CPU和内存信息,如下图:</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/44D05DBE-D2D4-450B-BFC0-61E48606F944.png" alt=""></p>
<p>可以看到当前运行的VM数量是0，点击目标主机，可以查看主机的详细信息，如下图：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/826BEA35-1853-4B62-A1B6-61F082DAD23F.png" alt=""></p>
<h3 id="3-2-命令行添加主机"><a href="#3-2-命令行添加主机" class="headerlink" title="3.2 命令行添加主机"></a>3.2 命令行添加主机</h3><h4 id="3-2-1-onehost-命令"><a href="#3-2-1-onehost-命令" class="headerlink" title="3.2.1  onehost 命令"></a>3.2.1  onehost 命令</h4><p>使用 onehost 命令删除之前 web 创建的主机,如下:</p>
<pre><code># su - oneadmin
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
1 10.249.7.247    -           0      0 / 3200 (0%)   0K / 125.7G (0%) on
$ onehost delete 1
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
</code></pre><p> 然后我们再使用 onehost 命令创建主机：</p>
<pre><code>$ onehost create   10.249.7.247 --im kvm --vm kvm --net dummy
ID: 2
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
2 10.249.7.247    -           0                  -                  - init
$ onehost list
ID NAME            CLUSTER   RVM      ALLOCATED_CPU      ALLOCATED_MEM STAT
2 10.249.7.247    -           0      0 / 3200 (0%)   0K / 125.7G (0%) on
</code></pre><ul>
<li>-i, –im im_mad           Set the information driver for the host   //信息管理 driver. 可选: kvm, xen, vmware, ec2, ganglia, dummy.</li>
<li>-v, –vm vmm_mad          Set the virtualization driver for the host //虚拟化管理 driver. 可选: kvm, xen, vmware, ec2, dummy.</li>
<li>-n, –net vnet_mad        Set the network driver for the host  //虚拟网络driver.可选：802.1Q,dummy,ebtables,fw,ovswitch,vmware.</li>
</ul>
<p>了解更多 onehost 命令用法请查看man手册。</p>
<h2 id="四、制作系统镜像-1"><a href="#四、制作系统镜像-1" class="headerlink" title="四、制作系统镜像"></a>四、制作系统镜像</h2><p>虚拟机有多种镜像格式可供选择,常见的有如 raw、vdi、 qcow2、vmdk、qed、vhd 等格式。</p>
<p>虚拟机镜像和服务器之间的关系如下图所示：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/2533DDFD-5676-437A-9788-B173ECE01179.png" alt=""></p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/4B51B99B-FF41-4806-839A-8927817F314C.png" alt=""></p>
<h3 id="4-1-qemu-img命令"><a href="#4-1-qemu-img命令" class="headerlink" title="4.1 qemu-img命令"></a>4.1 qemu-img命令</h3><p>qemu-img 是 QEMU 的磁盘管理工具,支持多种虚拟镜像格式。</p>
<pre><code># qemu-img  -h | grep Supported
Supported formats: vvfat vpc vmdk vhdx vdi sheepdog sheepdog sheepdog rbd raw host_cdrom host_floppy host_device file qed qcow2 qcow parallels nbd nbd nbd dmg tftp ftps ftp https http cow cloop bochs blkverify blkdebug
</code></pre><p>qemu-img 默认创建的格式是 raw，常用的格式为 raw、qcow2等。qemu-img常用的命令有：</p>
<pre><code># qemu-img check [-f fmt]  filename    //对磁盘镜像文件进行一致性检查,查找镜像文件中的错误,目前仅支持对“qcow2”、“qed”、“vdi”格式文件的检查。
# qemu-img create [-f fmt] filename [size]   //创建一个格式为 fmt 大小为 size 文件名为filename 的镜像文件。
# qemu-img info [-f fmt] filename  //显示 filename 镜像文件的信息。
</code></pre><p>这里我们使用 qemu-img 命令创建一个 50G 大小格式为 qcow2 的系统镜像：</p>
<pre><code># qemu-img  create -f qcow2 ubuntu14.04.qcow2 50G
</code></pre><p>关于 qemu-img 的更多高级用法可以参考 man 手册。</p>
<h3 id="4-2-qemu-kvm（-kvm-）命令"><a href="#4-2-qemu-kvm（-kvm-）命令" class="headerlink" title="4.2 qemu-kvm（ kvm ）命令"></a>4.2 qemu-kvm（ kvm ）命令</h3><p>在centos中该命令为 qemu-kvm, 而在ubuntu的系统中该命令为kvm，由于我的测试机为ubuntu的系统所以后面会使用到 kvm 命令。</p>
<p>安装系统：</p>
<pre><code># kvm -m 1024 -cdrom /work-space/ubuntu-14.04.3-server-amd64.iso \ 
-drive file=/work-space/ubuntu14.04.qcow2,if=virtio -net nic,model=virtio \
-net tap,script=no -boot d -nographic -vnc :0
</code></pre><p>以上参数释义如下，更多 kvm 的参数使用说明请参考 man 手册：</p>
<ul>
<li>-m  指定内存大小</li>
<li>-cdrom   指定系统 iso 镜像</li>
<li>-drive file=xx,if=xx   指定硬盘镜像,file=镜像文件名,if=镜像格式类型 </li>
<li>-net nic,model=xx   表示网卡配置,model=模拟网卡类型,默认 rt18139</li>
<li>-net tap,script=no   虚拟设备,桥接网络,script 表启动虚拟机自动执行网络配置脚本,<br>如果不需要启动,则写 no </li>
<li>-boot d  系统启动顺序,d表示表示cdrom </li>
<li>-nographic  关闭图形输出</li>
<li>-vnc:0 开启vnc监听</li>
</ul>
<p>输入以上命令之后,通过 VNC 客户端连接按照正常的安装流程安装系统即可：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/E2156E2D-BF0F-4EFD-A37D-9E685DA900FD.png" alt=""></p>
<h3 id="4-3-系统优化"><a href="#4-3-系统优化" class="headerlink" title="4.3 系统优化"></a>4.3 系统优化</h3><p>在母盘上装好系统之后，可以进行一些优化如 selinux、iptables、软件源、相关服务等，这样后面使用该母盘创建的虚拟机就可以省去优化的步骤。</p>
<pre><code># kvm -m 1024  -drive file=/work-space/ubuntu14.04.qcow2,if=virtio \
-net nic,model=virtio -net tap,script=no  -nographic -vnc :0
</code></pre><p>输入以上命令之后,通过 VNC 客户端连接就能进入刚装好的系统。</p>
<h2 id="五、导入镜像-1"><a href="#五、导入镜像-1" class="headerlink" title="五、导入镜像"></a>五、导入镜像</h2><p>添加主机可以使用 web 页面添加,也可以使用命令添加,导入镜像 web 和命令也都可以实现。</p>
<h3 id="5-1-web界面导入映像"><a href="#5-1-web界面导入映像" class="headerlink" title="5.1 web界面导入映像"></a>5.1 web界面导入映像</h3><p>1.选择映像管理—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/A408EEF7-7ADC-4B3F-86EB-FACB978093B4.png" alt=""></p>
<p>2.点击添加之后出现如下弹框,根据实际填写<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C32678CF-1D95-4AB6-B56A-7F31FFEB8297.png" alt=""></p>
<p>持久性:如果您在虚拟机模板中使用了持久性的磁盘映像,你只能够基于该模板创建一个正在运行的虚拟机。这是因为一个持久型的磁盘映像只能够同时被应用到一台正在运行的虚拟机上。如果您在虚拟机模板中使用的是临时性的磁盘映像,则可以同时基于该模板创建 多个虚拟机。</p>
<p>3.导入后初始状态为锁定<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/49406625-17E8-4914-834B-4967587B66D1.png" alt=""></p>
<p>4.导入完成之后就会显示就绪状态<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/F08296E6-2554-462C-9215-62D4F4938FF0.png" alt=""></p>
<h3 id="5-2-命令行导入映像"><a href="#5-2-命令行导入映像" class="headerlink" title="5.2 命令行导入映像"></a>5.2 命令行导入映像</h3><h4 id="5-2-1-oneimg-命令"><a href="#5-2-1-oneimg-命令" class="headerlink" title="5.2.1 oneimg 命令"></a>5.2.1 oneimg 命令</h4><pre><code># su - oneadmin
$ oneimage list
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
</code></pre><p>使用 oneimg 导入系统映像 </p>
<pre><code>$ cat ubuntu14.04_test.one   //创建相关配置文件
NAME    = &quot;ubuntu14.04_test&quot;
PATH    = /work-space/ubuntu14.04.qcow2
TYPE    = OS
DESCRIPTION = &quot;ubuntu14.04_test&quot;
DRIVER  = qcow2
$ onedatastore list  //选择数据仓库,这里选择default
ID NAME                SIZE AVAIL CLUSTER      IMAGES TYPE DS      TM      STAT
0 system              2.6T 95%   -                 0 sys  -       shared  on
1 default             2.6T 95%   -                 1 img  fs      ssh     on
2 files               2.6T 95%   -                 0 fil  fs      ssh     on
$ oneimage create ubuntu14.04_test.one  --datastore default
ID: 2
$ oneimage list   //初始状态 lock
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No lock    0
$ oneimage list  //再次查看状态变为 rdy
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No rdy     0
</code></pre><p>使用 oneimage 命令和创建 ubuntu14.04_test.one 文件在web 页面创建映像的高级模式中同样能实现：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/CF777085-1F87-484F-AD7E-F8B0B966688B.png" alt=""></p>
<p>克隆镜像：oneimage clone  \<imageid>  \<name></name></imageid></p>
<p>有时需要修改某个镜像,在修改之前我们可以通过克隆的方式备份这个镜像</p>
<pre><code>$ oneimage list
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No rdy     0
$ oneimage  clone 1  ubuntu14.04_bak  // 指定克隆的映像id
ID: 3
$ oneimage list
ID USER       GROUP      NAME            DATASTORE     SIZE TYPE PER STAT RVMS
1 oneadmin   oneadmin   ubuntu14.04_50G default        50G OS    No rdy     0
2 oneadmin   oneadmin   ubuntu14.04_tes default        50G OS    No rdy     0
3 oneadmin   oneadmin   ubuntu14.04_bak default        50G OS    No rdy     0
</code></pre><p>删除镜像 :  oneimage delete \<imageid |="" imagename=""></imageid></p>
<p>查看镜像详细信息：oneimage show</p>
<pre><code>$ oneimage show 1
IMAGE 1 INFORMATION
ID             : 1
NAME           : ubuntu14.04_50G
USER           : oneadmin
GROUP          : oneadmin
DATASTORE      : default
TYPE           : OS
REGISTER TIME  : 04/24 12:18:33
PERSISTENT     : No
SOURCE         : /var/lib/one//datastores/1/06f1f1d5f87d7aa92a528800b61e5983
PATH           : /work-space/ubuntu14.04.qcow2
SIZE           : 50G
STATE          : rdy
RUNNING_VMS    : 0

PERMISSIONS
OWNER          : um-
GROUP          : ---
OTHER          : ---

IMAGE TEMPLATE
DESCRIPTION=&quot;ubuntu14.04_50G&quot;
DEV_PREFIX=&quot;hd&quot;
DRIVER=&quot;qcow2&quot;

VIRTUAL MACHINES
</code></pre><h2 id="六、虚拟网络-1"><a href="#六、虚拟网络-1" class="headerlink" title="六、虚拟网络"></a>六、虚拟网络</h2><ul>
<li>eth0 为管理网口</li>
<li>eth1 为trunk口用作虚拟机通信，通过桥接br0</li>
</ul>
<h3 id="6-1-web界面添加虚拟网络"><a href="#6-1-web界面添加虚拟网络" class="headerlink" title="6.1 web界面添加虚拟网络"></a>6.1 web界面添加虚拟网络</h3><p>1.选择虚拟网络—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/6A422EA5-D7E3-4934-BEEF-A2DD5DA5D5B7.png" alt=""></p>
<p>2.点击添加之后出现如下弹框,根据实际填写<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/ADDF280D-B87F-4490-9A4E-85B6EE2D301B.png" alt=""><br>3.将网桥br0绑定到eth1 (网络模式和vlan概念还有点疑惑)<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/E2758C26-77CA-46EB-9441-EE923BFB3E69.png" alt=""><br>4.添加地址范围<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/726A4927-11ED-4726-A2F8-12A904BEED02.png" alt=""></p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/8717FB7C-97F4-4BC8-8505-DAD4C363A946.png" alt=""><br>5.完成其他相关配置，点击创建<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/EFFC8DC0-7B4B-4F0F-B1DF-F6878E731AAE.png" alt=""></p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/DAF058BB-9617-4D6C-A32F-225788F98BCD.png" alt=""></p>
<h3 id="6-2-命令行添加虚拟网络"><a href="#6-2-命令行添加虚拟网络" class="headerlink" title="6.2 命令行添加虚拟网络"></a>6.2 命令行添加虚拟网络</h3><h4 id="6-2-1-onevnet-命令"><a href="#6-2-1-onevnet-命令" class="headerlink" title="6.2.1 onevnet 命令"></a>6.2.1 onevnet 命令</h4><pre><code>$ onevnet list    //显示当前的虚拟网络
ID USER            GROUP        NAME                CLUSTER    BRIDGE   LEASES
0 oneadmin        oneadmin     test-network        -          br0           0
</code></pre><p>添加虚拟网络:</p>
<pre><code>$ cat onevnet_test.net
NAME    = &quot;onevnet_test&quot;
TYPE    = RANGED
BRIDGE = br0
NETWORK_ADDRESS = 10.249.6.0/24
IP_START        = 10.249.6.105
IP_END          = 10.249.6.107

GATEWAY = 10.249.6.254
DNS     = 10.249.6.100
$ onevnet create onevnet_test.net     // 添加虚拟网络
ID: 1
$ onevnet list
ID USER            GROUP        NAME                CLUSTER    BRIDGE   LEASES
0 oneadmin        oneadmin     test-network        -          br0           0
1 oneadmin        oneadmin     onevnet_test        -          br0           0
</code></pre><p>以上.net 文件中的内容可以直接输入到 web 创建虚拟网络的高级模式中创建。</p>
<p>删除虚拟网络:</p>
<pre><code>$ onevnet  delete 1
</code></pre><p>查看虚拟网络详细信息:</p>
<pre><code>$ onevnet  show 0
VIRTUAL NETWORK 0 INFORMATION
ID             : 0
NAME           : test-network
USER           : oneadmin
GROUP          : oneadmin
CLUSTER        : -
BRIDGE         : br0
VLAN           : Yes
PHYSICAL DEVICE: eth1
VLAN ID        : 6
USED LEASES    : 0

......
VIRTUAL NETWORK TEMPLATE
BRIDGE=&quot;br0&quot;
DESCRIPTION=&quot;test-network&quot;
DNS=&quot;10.249.6.100&quot;
GATEWAY=&quot;10.249.6.254&quot;
NETWORK_ADDRESS=&quot;10.249.6.0&quot;
NETWORK_MASK=&quot;255.255.255.0&quot;
PHYDEV=&quot;eth1&quot;
SECURITY_GROUPS=&quot;0&quot;
VLAN=&quot;YES&quot;
VLAN_ID=&quot;6&quot;
......
</code></pre><h2 id="七、制作模板-1"><a href="#七、制作模板-1" class="headerlink" title="七、制作模板"></a>七、制作模板</h2><p>模板就是包括创建虚拟机时使用到的系统镜像、以及各种配置的一个定义。</p>
<h3 id="7-1-web-界面制作模板"><a href="#7-1-web-界面制作模板" class="headerlink" title="7.1  web 界面制作模板"></a>7.1  web 界面制作模板</h3><p>1.选择模板管理—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/F02F53A0-473C-4F70-93E0-98B2B22F7191.png" alt=""><br>2.点击添加之后出现如下弹框,根据实际填写</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/3837A134-D0C5-4EE3-9E8D-83CD18693A85.png" alt=""><br>3.存储<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/87F81732-EEC1-4429-9868-2B6BD3D36382.png" alt=""><br>4.网络<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/80FA24E1-7D22-48F8-A57C-41AACBF326AC.png" alt=""><br>5.引导<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/3B448D17-02A9-4355-BA30-04407A83CDE0.png" alt=""><br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/9BEAEBE4-C0EA-4605-8727-6081260085BB.png" alt=""><br>6.输入输出<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/7AAABE0F-E3A1-4754-83B6-6C7E0D63C1E8.png" alt=""><br>7.Context功能<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/634670E1-53E7-4084-B0BF-84E639726AE7.png" alt=""><br>8.其他几个保持默认就行，填写完点击创建即可。</p>
<h3 id="7-2-Context初始化功能"><a href="#7-2-Context初始化功能" class="headerlink" title="7.2  Context初始化功能"></a>7.2  Context初始化功能</h3><p>Context原理图如下：</p>
<p><img src="http://7vzmp5.com1.z0.glb.clouddn.com/34977BFC-C6FE-4E0B-B3F1-2DCA0CDA56C9.png" alt=""></p>
<p>Context 通过 ISO 镜像的方式配置新启动的虚拟机,即创建虚拟机的时候 Server 管理端 会把相关的配置文件和脚本打包生成到一个 ISO 文件中,新启动的虚拟机会挂载该 ISO 镜像 并执行其中的脚本以达到自动初始化虚拟机的目的。</p>
<h4 id="7-2-1-修改母盘镜像"><a href="#7-2-1-修改母盘镜像" class="headerlink" title="7.2.1 修改母盘镜像"></a>7.2.1 修改母盘镜像</h4><pre><code># oneimage show ubuntu14.04_50G  | grep SOURCE   //获取之前创建镜像位置
SOURCE         : /var/lib/one//datastores/1/06f1f1d5f87d7aa92a528800b61e5983
# kvm -m 1024  -drive file=/var/lib/one//datastores/1/06f1f1d5f87d7aa92a528800b61e5983,if=virtio \
-net nic,model=virtio -net tap,script=no  -nographic -vnc :0
</code></pre><p>通过 VNC View 连接,登陆系统,新建 context 脚本:</p>
<pre><code># chmod +x  /etc/init.d/vmcontext
# cat  /etc/init.d/vmcontext
#!/bin/bash
if [ ! -d /mnt/cdrom ]; then
        mkdir /mnt/cdrom
fi
    mount /dev/cdrom /mnt/cdrom
if [ -f /mnt/cdrom/context.sh ]; then
        bash /mnt/cdrom/context.sh
        bash /mnt/cdrom/init.sh

fi
umount /mnt/cdrom
</code></pre><p>加入开机启动执行,在rc.local中加入: bash  /etc/init.d/vmcontext</p>
<p>这里有两个文件：</p>
<p><strong>/mnt/cdrom/context.sh</strong>   //Context variables generated by OpenNebula,开通虚拟机时从平台里获取到的变量，如网卡相关的配置信息等。</p>
<p><strong>/mnt/cdrom/init.sh</strong>    //自己编写放置在Server端的脚本，主要功能就是让虚拟机能自动配置上context.sh中的变量</p>
<pre><code>$ pwd
/var/lib/one/context
$ ls
centos  ubuntu  windows
$ cd ubuntu/
$ ls
init.sh
$ cat init.sh    // init.sh 脚本内容，简单实例
#!/bin/bash

INTERFACE=&quot;/etc/network/interfaces&quot;
. /mnt/cdrom/context.sh
if [ $HOSTNAME ]; then
    hostname $HOSTNAME
    echo &quot;$HOSTNAME&quot; &gt; /etc/hostname
fi

echo -ne &quot;auto lo\n&quot; &gt; $INTERFACE
echo -ne &quot;iface lo inet loopback\n&quot; &gt;&gt; $INTERFACE

for i in 0 1 2 3; do
    grep &quot;ETH${i}_IP&quot; /mnt/cdrom/context.sh &gt;&gt; /dev/null 2&gt;&amp;1

if [ $? -eq 0 ]; then
    echo -ne &quot;\nauto eth$i\n&quot;               &gt;&gt; $INTERFACE
    echo -ne &quot;iface eth$i inet static\n&quot;    &gt;&gt; $INTERFACE
    echo -ne &quot;address &quot;                     &gt;&gt; $INTERFACE
    eval echo \$ETH${i}_IP                  &gt;&gt; $INTERFACE
    echo -ne &quot;netmask &quot;                     &gt;&gt; $INTERFACE
    eval echo \$ETH${i}_MASK                &gt;&gt; $INTERFACE
    echo -ne &quot;gateway &quot;                     &gt;&gt; $INTERFACE
    eval echo \$ETH${i}_GATEWAY             &gt;&gt; $INTERFACE

    if [ $i -eq 0 ]; then
        echo -ne &quot;dns-nameservers &quot; &gt;&gt; $INTERFACE
        eval echo \$ETH${i}_DNS &gt;&gt; $INTERFACE
        echo -ne &quot;dns-search i.ajkdns.com\n&quot; &gt;&gt; $INTERFACE
    fi
fi
done

/sbin/ifdown eth0
/sbin/ifup eth0
rm -rf /etc/init.d/vmcontext
sed  -i &apos;/vmcontext/d&apos; /etc/rc.local
ifconfig eth0 &gt;/dev/null 2&gt;1
    if [ &quot;$?&quot; != &quot;0&quot; ]; then
    rm -f /etc/udev/rules.d/70-persistent-net.rules
fi
reboot
</code></pre><h2 id="八、创建虚拟机-1"><a href="#八、创建虚拟机-1" class="headerlink" title="八、创建虚拟机"></a>八、创建虚拟机</h2><h3 id="8-1-web界面创建虚拟机"><a href="#8-1-web界面创建虚拟机" class="headerlink" title="8.1 web界面创建虚拟机"></a>8.1 web界面创建虚拟机</h3><p>1.选择虚机管理—&gt; 添加<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/88C9F701-7418-4948-96D3-703EE759FA40.png" alt=""></p>
<p>2.点击添加选择模板，设置主机名<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/OpenNebula%20Sunstone%20%20Cloud%20Operations%20Center.png" alt=""></p>
<p>3.点击创建后，主机初始状态为PENDING<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/2C3C8F5B-A2EA-4AB6-ADC7-0A981D27A7E4.png" alt=""></p>
<p>4.勾选主机并部署<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/4116E61F-F971-430F-A572-D3E0506E5033.png" alt=""></p>
<p>5.部署到主机<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C816CFBA-4A02-4D39-9CDB-F8FCBF392883.png" alt=""></p>
<p>6.部署完毕后，如果一切正常，虚拟机的状态为PROLOG—&gt; BOOT —&gt; 运行，后面即可ssh登录<br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/C3182977-E4C6-481A-ADEE-B4DBA7880D2E.png" alt=""><br><img src="http://7vzmp5.com1.z0.glb.clouddn.com/3C0DC59D-C31E-4DDE-8467-2D5AAB680C15.png" alt=""></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/08/Create-A-deb-Package-Repository/" class="post-link">Create A .deb Package Repository</a></h2><span class="post-time">Mar 8, 2016</span><div class="post-content"><h3 id="Install-Reprepro-and-Generate-Key"><a href="#Install-Reprepro-and-Generate-Key" class="headerlink" title="Install Reprepro and Generate Key"></a>Install Reprepro and Generate Key</h3><p>安装软件包并生成密钥</p>
<pre><code># sudo apt-get  install reprepro gnupg -y
</code></pre><p>创建gpg key需要大量的随机操作，使用rng-tools产生大量随机操作    </p>
<pre><code># apt-get install rng-tools -y

# vim /etc/default/rng-tools   

[...]

HRNGDEVICE=/dev/urandom

[...]

# /etc/init.d/rng-tools start
</code></pre><p>Generate a gpg key using gnupg  </p>
<pre><code># gpg --gen-key
......
Please select what kind of key you want:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sign only)
(4) RSA (sign only)
Your selection? 4
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
        0 = key does not expire
    &lt;n&gt;  = key expires in n days
    &lt;n&gt;w = key expires in n weeks
    &lt;n&gt;m = key expires in n months
    &lt;n&gt;y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
 &quot;Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;&quot;

Real name: Mr-zhao
Email address: zhifanzhao@gmail.com
Comment: ops deb
Enter passphrase:****
You selected this USER-ID:
    &quot;Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;&quot;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
You need a Passphrase to protect your secret key.

You don&apos;t want a passphrase - this is probably a *bad* idea!
I will do it anyway.  You can change your passphrase at any time,
using this program with the option &quot;--edit-key&quot;.

We need to generate a lot of random bytes.
 It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy.

......
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key D94F748F marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   4096R/D94F748F 2016-03-08
    Key fingerprint = 7D96 2419 19C6 B7C3 7F97  F4BB 63BF 6A4F D94F 748F
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

Note that this key cannot be used for encryption.  You may want to use
the command &quot;--edit-key&quot; to generate a subkey for this purpose. 
</code></pre><p>查看和修改 gpg key</p>
<pre><code># gpg --list-keys
/root/.gnupg/pubring.gpg
------------------------
pub   4096R/D94F748F 2016-03-08
uid                  Mr-zhao (ops deb) &lt;zhifanzhao@gmail.com&gt;

# gpg --edit-key
usage: gpg [options] --edit-key user-id [commands]
</code></pre><h3 id="Create-a-Package-Repository-and-Export-Key"><a href="#Create-a-Package-Repository-and-Export-Key" class="headerlink" title="Create a Package Repository and Export Key"></a>Create a Package Repository and Export Key</h3><pre><code># cd /data
# mkdir apt
# mkdir -p ./apt/conf

#vim  ./apt/conf/distributions
Origin:        ops-ubuntu
Label:         ops-ubuntu
Suite:         trusty
Codename:      trusty
Version:       14.04
Architectures: amd64 i386
Components:    main restricted multiverse universe
Description:   private main deb repository for trusty
SignWith: yes

#vim ./apt/conf/options   //reprepro --options命令的集合
verbose
basedir  .
ask-passphrase
distdir  /data/apt/repos/dists   //dist文件的输出位置
outdir   /data/apt/repos    //pool输出的位置
</code></pre><p>Create the repository tree</p>
<pre><code># reprepro --ask-passphrase -Vb /data/apt/ export
</code></pre><p>Export Key</p>
<pre><code># gpg --armor --export Mr-zhao zhifanzhao@gmail.com &gt;&gt; ./repos/public.key
</code></pre><h3 id="Add-Packages-to-Newly-Created-Repository"><a href="#Add-Packages-to-Newly-Created-Repository" class="headerlink" title="Add Packages to Newly Created Repository"></a>Add Packages to Newly Created Repository</h3><pre><code>#reprepro -b . -C main includedeb trusty /tmp/packages.deb  //add

#reprepro remove trusty packages   //remove 
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.tecmint.com/create-deb-pacakge-repository-in-ubuntu/" target="_blank" rel="external">Create A .deb Package Repository</a><br><a href="https://wikitech.wikimedia.org/wiki/Reprepro" target="_blank" rel="external">wiki reprepro</a><br><a href="https://wiki.debian.org/SecureApt" target="_blank" rel="external">SecureApt)</a><br><a href="http://irtfweb.ifa.hawaii.edu/~lockhart/gpg/" target="_blank" rel="external">gpg-cheat</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="external">gpg</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/05/Feb_tips/" class="post-link">Work Tips</a></h2><span class="post-time">Mar 5, 2016</span><div class="post-content"><h3 id="1-无交互修改系统密码"><a href="#1-无交互修改系统密码" class="headerlink" title="1.无交互修改系统密码"></a><u>1.无交互修改系统密码</u></h3><p>CentOS</p>
<pre><code>echo 123456 |  passwd --stdin root
</code></pre><p>Ubuntu</p>
<pre><code>echo &quot;root:123456&quot; | chpasswd   //ubuntu是BSD 非标准的不能用
</code></pre><p>CentOS和Ubuntu还有一个地方要注意，CentOS默认新建的普通用户是没有sudo权限的，需要在/etc/sudoers文件中加入用户和权限才能执行sudo，而Ubuntu执行sudo 默认输入当前用户密码即可执行。</p>
<h3 id="2-deb包的字段含义"><a href="#2-deb包的字段含义" class="headerlink" title="2.deb包的字段含义"></a><u>2.deb包的字段含义</u></h3><pre><code>root@Mr-zhao:~# aptitude search node
p   ansible-node-fireball                           - Ansible fireball transport support for nodes
p   ax25-node                                       - Amateur Packet Radio Node program
p   ax25-node:i386                                  - Amateur Packet Radio Node program
p   knode                                           - graphical news reader
p   knode:i386                                      - graphical news reader
p   leafnode                                        - NNTP server for small sites
p   leafnode:i386                                   - NNTP server for small sites
p   libjs-node-uuid                                 - simple, fast generation of RFC4122 UUIDs - JavaScript libr
v   libnode-node-expat                              -
v   libnode-node-expat:i386                         -
</code></pre><blockquote>
<p>current state of the package: <code>the most common states are p, meaning that no trace of the packageexists on the system, c, meaning that the package was deleted but its configuration files remain on the system, i, meaning that the package is installed, and v, meaning that the package is virtual.</code> ( man aptitude )</p>
</blockquote>
<h3 id="3-apt-get-update-NO-PUBKEY"><a href="#3-apt-get-update-NO-PUBKEY" class="headerlink" title="3.apt-get update NO_PUBKEY"></a><u>3.apt-get update NO_PUBKEY</u></h3><p>将私有镜像仓库的key添加到本地trusted数据库</p>
<pre><code># curl -l http://mirrors.corp.ops.com/ops/public.key|apt-key add -
</code></pre><p>如果还有报错，则使用以下命令：</p>
<pre><code># apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 3B4FE6ACC0B21F32

# apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 40976EAF437D05B5
</code></pre><h3 id="4-Cacti-weathermap-插件-editor-php-的安全性设置"><a href="#4-Cacti-weathermap-插件-editor-php-的安全性设置" class="headerlink" title="4.Cacti weathermap 插件 editor.php 的安全性设置"></a><u>4.Cacti weathermap 插件 editor.php 的安全性设置</u></h3><p>Cacti weathermap采用.htaccess的验证方法</p>
<p>首先在/var/www/html/plugins/weathermap下创建一个验证文件</p>
<pre><code>#htpasswd -cb /var/www/html/plugins/weathermap/.htpasswd cacti catiuser
//cacti是用户名，cactiuser是密码
</code></pre><p>创建好验证文件后，在apache的配置文件末尾加上如下的代码</p>
<pre><code>&lt;Directory/var/www/html/plugins/weathermap&gt;
&lt;Files editor.php&gt;
AuthType Basic
AuthName &quot;Please input your username and password.&quot;
AuthUserFile /var/www/html/plugins/weathermap/.htpasswd
require valid-user
&lt;/Files&gt;
&lt;/Directory&gt;
</code></pre><h3 id="5-SSD磁盘分区4K对齐检测"><a href="#5-SSD磁盘分区4K对齐检测" class="headerlink" title="5.SSD磁盘分区4K对齐检测"></a><u>5.SSD磁盘分区4K对齐检测</u></h3><p>使用fdisk分区，则查看start能否被8整除</p>
<pre><code>fdisk -lu |awk &apos;$1==&quot;/dev/sdb1&quot; {print $2/8}&apos;
</code></pre><p>使用parted分区</p>
<pre><code>root@Mr-zhao:~# parted /dev/sdb
GNU Parted 2.1
Using /dev/sdb
Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.
(parted) print
Model: DELL PERC H730P Mini (scsi)
Disk /dev/sdb: 1439GB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt

Number  Start   End     Size    File system  Name     Flags
1      1049kB  1439GB  1439GB  xfs          primary

(parted) align-check opt 1
1 aligned   #返回aligned，即对齐
(parted)
</code></pre><h3 id="6-drop-caches"><a href="#6-drop-caches" class="headerlink" title="6.drop caches"></a><u>6.drop caches</u></h3><p>Writing to this will cause the kernel to drop clean caches, dentries and inodes from memory, causing thatmemory to become free.</p>
<p>To free pagecache:</p>
<pre><code>echo 1 &gt; /proc/sys/vm/drop_caches
</code></pre><p>To free dentries and inodes:</p>
<pre><code>echo 2 &gt; /proc/sys/vm/drop_caches
</code></pre><p>To free pagecache, dentries andinodes:</p>
<pre><code>echo 3 &gt; /proc/sys/vm/drop_caches
</code></pre><p>As this is a non-destructiveoperation and dirty objects are not freeable, the user should run sync first.</p>
<h3 id="7-系统快速求援"><a href="#7-系统快速求援" class="headerlink" title="7.系统快速求援"></a><u>7.系统快速求援</u></h3><blockquote>
<ul>
<li>at the grub prompt,hit a to append options</li>
<li>add init=/bin/bash to the kernel command line</li>
<li>mount -o remount,rw /</li>
<li>vim /etc/fstab</li>
<li>reboot</li>
</ul>
</blockquote>
<h3 id="8-修改网卡规则（设置显示为eth0）"><a href="#8-修改网卡规则（设置显示为eth0）" class="headerlink" title="8.修改网卡规则（设置显示为eth0）"></a><u>8.修改网卡规则（设置显示为eth0）</u></h3><pre><code>编辑 /etc/udev/rules.d/70-persistent-net.rules  修改网卡规则
</code></pre><h3 id="9-重启网卡失败：device-eth0-does-not-seem-to-be-present-delaying-initialization"><a href="#9-重启网卡失败：device-eth0-does-not-seem-to-be-present-delaying-initialization" class="headerlink" title="9.重启网卡失败：device eth0 does not seem to be present, delaying initialization"></a><u>9.重启网卡失败：device eth0 does not seem to be present, delaying initialization</u></h3><pre><code>/etc/udev/rules.d/70-persistent-net.rules 删除后重启机器
</code></pre><h3 id="10-查看磁盘的rebuild-进度"><a href="#10-查看磁盘的rebuild-进度" class="headerlink" title="10.查看磁盘的rebuild 进度"></a><u>10.查看磁盘的rebuild 进度</u></h3><pre><code># MegaCli -PDRbld -ShowProg -PhysDrv [32:3] -a0
Rebuild Progress on Device at Enclosure 32, Slot 3 Completed 95% in 50 Minutes.
</code></pre><h3 id="11-sed-i-破坏链接文件属性"><a href="#11-sed-i-破坏链接文件属性" class="headerlink" title="11.sed -i  破坏链接文件属性"></a><u>11.sed -i  破坏链接文件属性</u></h3><pre><code>--follow-symlinks

          follow symlinks when processing in place; hard links will still be broken.

-i[SUFFIX], --in-place[=SUFFIX]

          edit  files in place (makes backup if extension supplied).  The default operation mode
          is to break symbolic and hard links.  This can be changed with  --follow-symlinks  and
          --copy.

-c, --copy

          use  copy  instead  of  rename when shuffling files in -i mode.  While this will avoid
          breaking links (symbolic or hard), the resulting  editing  operation  is  not  atomic.
          This  is  rarely the desired mode; --follow-symlinks is usually enough, and it is both
          faster and more secure.
</code></pre><p> mannul中释义 -i选项对软链接和硬链接都会破坏，加上 –follow-symlinks选项只对软链接有效，硬链接还是会被破坏，加上 -c选项则软硬链接都不会遭到破坏。</p>
<h3 id="12-文本内容操作，合并去重"><a href="#12-文本内容操作，合并去重" class="headerlink" title="12.文本内容操作，合并去重"></a><u>12.文本内容操作，合并去重</u></h3><pre><code>cat /etc/rc.local  /etc/rc.d/rc.local |  awk &apos;!a[$0]++&apos;
</code></pre><h3 id="13-ssh登陆信息显示-etc-motd"><a href="#13-ssh登陆信息显示-etc-motd" class="headerlink" title="13.ssh登陆信息显示 /etc/motd"></a><u>13.ssh登陆信息显示 /etc/motd</u></h3><p>/etc/motd/etc/motd即messageoftoday（布告栏信息），每次用户登录时，/etc/motd文件的内容会显示在用户的终端,如果用户登录系统是图形界面，这些信息则不会显示。</p>
<h3 id="14-SSD磁盘型号与系列"><a href="#14-SSD磁盘型号与系列" class="headerlink" title="14.SSD磁盘型号与系列"></a><u>14.SSD磁盘型号与系列</u></h3><pre><code>SSDSC2BB480G4   属于S3500系列
SSDSC2BA800G4   属于S3710系列
SSDSC2BA800G3   属于S3700系列
SSDSC2BX800G4   属于S3610系列
800、480表示磁盘容量
</code></pre><p>  <a href="http://ark.intel.com/ZH-CN#@SolidStateDrives" target="_blank" rel="external">Intel SSD 官网查询</a>  </p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/03/03/free/" class="post-link">free查看内存相关信息</a></h2><span class="post-time">Mar 3, 2016</span><div class="post-content"><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="manual-description"><a href="#manual-description" class="headerlink" title="manual description"></a>manual description</h4><blockquote>
<p>free  displays  the total amount of free and used physical and swap memory in the system, as well as the buffers used bythe kernel.</p>
<p>The shared memory column represents either the MemShared value (2.4 series kernels) or the Shmem value (2.6 series kernels and later) taken from the /proc/meminfo file. The value is zero if none of the entries is exported by the kernel.</p>
</blockquote>
<h4 id="buffers-and-cached"><a href="#buffers-and-cached" class="headerlink" title="buffers and cached"></a>buffers and cached</h4><blockquote>
<p><strong>What is the difference between buffers and Cache?</strong></p>
<p>A buffer is a temporary location to store data for a particular application and this data is not used by any other application. This is similar to bandwidth concept. When you try to send burst of data through network, if your network card is capable of sending less data, it will keep these huge amounts of data in buffer so that it can send data constantly in lesser speeds. In other hand Cache is a memory location to store frequently used data for faster access. Other difference between a buffer and a cache is that cache can be used multiple times where as buffer is used single time. And both are temporary store for your data processing.</p>
</blockquote>
<ul>
<li>A buffer is something that has yet to be “written” to disk.</li>
<li>A cache is something that has been “read” from the disk and stored for later use.</li>
</ul>
<p>buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。   这二者是为了提高IO性能的。为了提高IO read的性能，总是要多cache一些数据，这也就是为什么cached memor比较大，而比较小的原因。</p>
<pre><code>root@Mr-zhao:~# free -m
             total       used       free     shared    buffers     cached
Mem:          2001        979       1021          0         58        774
-/+ buffers/cache:        146       1854
Swap:         4092          0       4092
</code></pre><p>当我们第一次读一个大文件时耗时可能会比第二次长，原因就是第二次读取时已有cache数据。</p>
<ul>
<li><p>-/+ buffers/cache(used): 表示一个应用程序认为系统被用掉多少内存；</p>
<p>  -/+ buffers/cache(used) = Mem(used) – Mem(buffers) – Mem(cached)</p>
</li>
<li><p>-/+ buffers/cache(free)，表示一个应用程序认为系统还有多少内存；</p>
<p>  -/+ buffers/cache(free) = Mem(free) + Mem(buffers) + Mem(cached)</p>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="external">Linux上的free命令详解</a><br><a href="http://www.freelinuxconsole.info/understanding-free-command-in-linuxunix-2/" target="_blank" rel="external">Understanding free command in Linux/Unix</a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/02/28/minicom/" class="post-link">minicom的使用</a></h2><span class="post-time">Feb 28, 2016</span><div class="post-content"><h3 id="minicom的介绍"><a href="#minicom的介绍" class="headerlink" title="minicom的介绍"></a>minicom的介绍</h3><p>Linux下的Minicom的功能与Windows下的超级终端功能相似，<strong>可以通过串口控制外部的硬件设备</strong>，适于在linux通过超级终端对嵌入式设备行管理。</p>
<h3 id="minicom的安装配置和使用"><a href="#minicom的安装配置和使用" class="headerlink" title="minicom的安装配置和使用"></a>minicom的安装配置和使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code># apt-get install minicom
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p> 实际案例：交换机的consle转usb口连接到服务器，通过minicom对交换机进行配置</p>
<pre><code># lsusb   //查看USB的状态
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse
Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 002 Device 004: ID 0e0f:0008 VMware, Inc.
Bus 002 Device 005: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port

# dmesg |grep ttyUSB  //USB已经连接
[11991.918691] usb 2-2.2: pl2303 converter now attached to ttyUSB0

# minicom -s   //进行配置

+-----[configuration]------+
| Filenames and paths      |
| File transfer protocols  |
| Serial port setup        |
| Modem and dialing        |
| Screen and keyboard      |
| Save setup as dfl        |
| Save setup as..          |
| Exit                     |
| Exit from Minicom        |
+--------------------------+

#选择进入Serial port setup，按照之前查看的信息进行配置

+-----------------------------------------------------------------------+
| A -    Serial Device      : /dev/ttyUSB0                              |
| B - Lockfile Location     : /var/lock                                 |
| C -   Callin Program      :                                           |
| D -  Callout Program      :                                           |
| E -    Bps/Par/Bits       : 115200 8N1                                |
| F - Hardware Flow Control : Yes                                       |
| G - Software Flow Control : No                                        |
|                                                                       |
|    Change which setting?                                              |
+-----------------------------------------------------------------------+
    | Screen and keyboard      |
    | Save setup as dfl        |
    | Save setup as..          |
    | Exit                     |
    | Exit from Minicom        |
    +--------------------------+

#Enter退出，选择Save setup as dfl  保存为默认配置
</code></pre><p>  然后进入终端输入minicom 就能连接进入交换机配置</p>
</div></article></li></ul><div class="paginator"><a href="/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/page/3/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="https://github.com/Abnerzhao" title="github" class="iconfont icon-github"></a><a href="mailto:opsabnerzhao@gmail.com" title="email" class="iconfont icon-email"></a><a href="http://weibo.com/2863179107/profile?topnav=1&amp;wvr=6&amp;is_all=1" title="weibo" class="iconfont icon-weibo"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2015-2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Abnerzhao</span></p></div><div id="back2top"><i class="iconfont icon-up"></i></div></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>